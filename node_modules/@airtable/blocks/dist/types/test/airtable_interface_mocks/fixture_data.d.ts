import { BaseId } from '../../src/types/base';
import { TableId } from '../../src/types/table';
import { FieldId, FieldType } from '../../src/types/field';
import { ViewId, ViewType } from '../../src/types/view';
import { RecordId } from '../../src/types/record';
import { CollaboratorData } from '../../src/types/collaborator';
import { Color } from '../../src/colors';
import { ObjectMap } from '../../src/private_utils';
import { SdkInitData } from '../../src/types/airtable_interface';
export declare function convertFixtureDataToSdkInitData(fixtureData: FixtureData): SdkInitData;
/**
 * A complete set of information necessary to initialize a simulated Airtable
 * Base in automated test environments. This is currently copied from
 * block-testing.
 * TODO(fredz): consider moving this into src/testing and exporting it as
 * part of unstable_testing_utils.
 *
 * Unlike SdkInitData which does not contain record data by design,
 * FixtureData contains it in fixtureData.base.tables[number].records,
 * and relies on dependent modules to simulate the hyperbase behavior of
 * only making those records after corresponding necessary calls to
 * AirtableInterface.
 */
export interface FixtureData {
    /** A representation of the state of an Airtable Base */
    base: {
        id: BaseId;
        name: string;
        color?: string;
        tables: Array<TableFixtureData>;
        collaborators: Array<CollaboratorData & {
            isActive: boolean;
        }>;
    };
}
/** A representation of the state of a Table */
interface TableFixtureData {
    /** A unique identifier for the simulated Table */
    id: TableId;
    /** The name to assign to the simulated Table */
    name: string;
    /** The description to assign to the simulated Table */
    description: string | null;
    /**
     * Fixture data for the simulated Fields that should be present in the
     * simulated Table when it is initialized.
     */
    fields: Array<FieldFixtureData>;
    /**
     * Fixture data for the simulated Views that should be present in the
     * simulated Table when it is initialized.
     */
    views: Array<ViewFixtureData>;
    /**
     * Fixture data for the simulated Records that should be present in the
     * simulated Table when it is initialized.
     */
    records: Array<RecordFixtureData>;
}
/** A representation of the state of a Field */
interface FieldFixtureData {
    /** A unique identifier for the simulated Field */
    id: FieldId;
    /** The name to assign to the simulated Field */
    name: string;
    /** The description to assign to the simulated Field */
    description: string | null;
    /** The type of the simulated Field */
    type: FieldType;
    /** Options associated with the simulated Field */
    options: null | {
        [key: string]: unknown;
    };
}
/** A representation of the state of a View */
interface ViewFixtureData {
    /** A unique identifier for the simulated View */
    id: ViewId;
    /** The name to assign to the simulated View */
    name: string;
    /** The type of the simulated view */
    type: ViewType;
    /**
     * A description of how simulated Fields should be sequenced within the
     * simulated View
     */
    fieldOrder: {
        fieldIds: Array<FieldId>;
        visibleFieldCount: number;
    };
    /**
     * A set of references to Records contained within the simulated view. This
     * is distinct from the complete fixture data for the simulated Records.
     */
    records: Array<ViewRecordFixtureData>;
    /**
     * Optional boolean denoting if the view is locked. By default tests assume
     * the view is unlocked if undefined.
     */
    isLockedView?: boolean;
}
/**
 * A reference to Record contained within a simulated view. This is disctinct
 * from the complete fixture data for the simulated Record.
 */
interface ViewRecordFixtureData {
    /** A value which uniquely identifies a Record within a base. */
    id: RecordId;
    /** The color associated with a Record's membership in a View. */
    color: Color | null;
}
/** A representation of the state of a Record */
interface RecordFixtureData {
    /** A unique identifier for the simulated Record */
    id: RecordId;
    /** The number of comments to assign to the simulated record */
    commentCount: number;
    /** The time the simulated record should appear to have been created */
    createdTime: string;
    /** A mapping of field identifiers to cell values */
    cellValuesByFieldId: ObjectMap<FieldId, unknown>;
}
export {};
//# sourceMappingURL=fixture_data.d.ts.map