"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _private_utils = require("./private_utils");
var _error_utils = require("./error_utils");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; } /** @module @airtable/blocks/models: Abstract models */ /** */
/**
 * Abstract superclass for watchable models. All watchable models expose `watch`
 * and `unwatch` methods that allow consumers to subscribe to changes to that model.
 *
 * This class should not be used directly.
 *
 * @docsPath models/advanced/Watchable
 */
var Watchable = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function Watchable() {
    (0, _classCallCheck2.default)(this, Watchable);
    /** @internal */
    (0, _defineProperty2.default)(this, "_changeCount", 0);
    /** @internal */
    (0, _defineProperty2.default)(this, "_watchableId", (0, _private_utils.getLocallyUniqueId)());
    /** @internal */
    (0, _defineProperty2.default)(this, "_changeWatchersByKey", void 0);
    this._changeWatchersByKey = {};
  }
  // React integrations (e.g. useSubscription) rely on referential equality (===) to determine
  // when things have changed. This doesn't work with our mutable models, since the identity
  // of the model doesn't change, but the data inside it might. Rather than never returning two equal values
  // those integrations can use __getWatchableKey, a string key that is guaranteed to be unique
  // to each watchable and will change whenever the watch keys are fired.
  /**
   * @internal
   */
  return (0, _createClass2.default)(Watchable, [{
    key: "__getWatchableKey",
    value: function __getWatchableKey() {
      return "".concat(this._watchableId, " ").concat(this._changeCount);
    }
    /**
     * Helper method to get only the valid watchable keys - or throw if a key is invalid
     *
     * @param keys
     * @internal
     */
  }, {
    key: "_getWatchableValidKeysOrThrow",
    value: function _getWatchableValidKeysOrThrow(keys, errorMethodName, shouldWarnInsteadOfThrow) {
      var arrayKeys = Array.isArray(keys) ? keys : [keys];
      var validKeys = [];
      var _iterator = _createForOfIteratorHelper(arrayKeys),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          if (this.constructor._isWatchableKey(key)) {
            validKeys.push(key);
          } else {
            var className = this.constructor._className;
            var errorString = "Invalid key to ".concat(errorMethodName, " for ").concat(className, ": ").concat(key);
            if (shouldWarnInsteadOfThrow) {
              // eslint-disable-next-line no-console
              console.warn(errorString);
            } else {
              throw (0, _error_utils.spawnError)(errorString);
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return validKeys;
    }
    /**
     * Get notified of changes to the model.
     *
     * Every call to `.watch` should have a matching call to `.unwatch`.
     *
     * Returns the array of keys that were watched.
     *
     * @param keys the keys to watch
     * @param callback a function to call when those keys change
     * @param context an optional context for `this` in `callback`.
     */
  }, {
    key: "watch",
    value: function watch(keys, callback, context) {
      var validKeys = this._getWatchableValidKeysOrThrow(keys, 'watch');
      var _iterator2 = _createForOfIteratorHelper(validKeys),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var key = _step2.value;
          if (!this._changeWatchersByKey[key]) {
            this._changeWatchersByKey[key] = [];
          }
          // Rather than pushing onto this array, we initialize a new array.
          // This is necessary since watches can change as a result of an
          // event getting triggered. It would be bad if as we iterate over
          // our watchers, new watchers get pushed onto the array that we
          // are iterating over.
          // TODO(jb): as a perf optimization, we *could* push onto this array
          // as long as we are not in the middle of iterating over it.
          this._changeWatchersByKey[key] = [...this._changeWatchersByKey[key], {
            callback,
            context
          }];
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return validKeys;
    }
    /**
     * Unwatch keys watched with `.watch`.
     *
     * Should be called with the same arguments given to `.watch`.
     *
     * Returns the array of keys that were unwatched.
     *
     * @param keys the keys to unwatch
     * @param callback the function passed to `.watch` for these keys
     * @param context the context that was passed to `.watch` for this `callback`
     */
  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      var validKeys = this._getWatchableValidKeysOrThrow(keys, 'unwatch', true);
      var _iterator3 = _createForOfIteratorHelper(validKeys),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var key = _step3.value;
          var watchers = this._changeWatchersByKey[key];
          if (watchers) {
            var filteredWatchers = watchers.filter(watcher => {
              return watcher.callback !== callback || watcher.context !== context;
            });
            if (filteredWatchers.length > 0) {
              this._changeWatchersByKey[key] = filteredWatchers;
            } else {
              delete this._changeWatchersByKey[key];
            }
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return validKeys;
    }
    /**
     * @internal
     */
  }, {
    key: "_onChange",
    value: function _onChange(key) {
      this._changeCount += 1;
      var watchers = this._changeWatchersByKey[key];
      if (watchers) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        var _iterator4 = _createForOfIteratorHelper(watchers),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var watcher = _step4.value;
            watcher.callback.call(watcher.context, this, key, ...args);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    }
  }], [{
    key: "_isWatchableKey",
    value: /** @internal */
    function _isWatchableKey(_key) {
      // Override to return whether `key` is a valid watchable key.
      return false;
    }
  }]);
}();
/** @internal */
(0, _defineProperty2.default)(Watchable, "_className", 'Watchable');
var _default = exports.default = Watchable;