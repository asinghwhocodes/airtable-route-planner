"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WatchablePerformRecordActionKeys = exports.PerformRecordAction = void 0;
exports.__injectSdkIntoPerformRecordAction = __injectSdkIntoPerformRecordAction;
exports.registerRecordActionDataCallback = registerRecordActionDataCallback;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _error_utils = require("./error_utils");
var _abstract_model_with_async_data = _interopRequireDefault(require("./models/abstract_model_with_async_data"));
var _private_utils = require("./private_utils");
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/** @hidden */
var WatchablePerformRecordActionKeys = exports.WatchablePerformRecordActionKeys = Object.freeze({
  // isDataLoaded must be a watchable key for a LoadableModel.
  isDataLoaded: 'isDataLoaded',
  recordActionData: 'recordActionData'
});

/** @hidden */

/**
 * Returned by {@link registerRecordActionDataCallback}. Call it to unregister the previously
 * registered function. Do this before registering another function or unmounting the component.
 * */
/**
 * This class exists to manage registering a callback to receive "Open block" / "Perform record
 * action" messages.
 * This is different to other message handlers (_registerHandlers) since the callback is specified
 * by the block: it registers it during first render (vs the SDK registering during initialisation).
 *
 * On the liveapp side, we ensure that pending messages are held until the block registers the
 * callback (or another message is sent). If there's a pending message, it is returned at
 * registration.
 *
 * This class implements AbstractModelWithAsyncData in order to take advantage of useLoadable's
 * suspense handling. "Loading" the model means registering the handler with liveapp. This allows us
 * to suspend the block and return the initial pending message on first render.
 *
 * One difference is that _unloadData will not unregister the airtableInterface handler. We don't
 * support unregistering it at this time for simplicity.
 *
 * This class is internal: users should use registerRecordActionDataCallback or useRecordActionData.
 *
 * @internal
 * */
var PerformRecordAction = exports.PerformRecordAction = /*#__PURE__*/function (_AbstractModelWithAsy) {
  /** @hidden */
  function PerformRecordAction(sdk, airtableInterface) {
    var _this;
    (0, _classCallCheck2.default)(this, PerformRecordAction);
    _this = _callSuper(this, PerformRecordAction, [sdk, 'performRecordAction']);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_airtableInterface", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_hasRegisteredHandler", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_hasCompletedInitialDataLoad", void 0);
    /**
     * The data from the latest record action, or null if none have occurred yet.
     *
     * @internal */
    (0, _defineProperty2.default)(_this, "recordActionData", void 0);
    _this._airtableInterface = airtableInterface;
    _this._hasRegisteredHandler = false;
    _this._hasCompletedInitialDataLoad = false;
    _this.recordActionData = null;
    _this._handlePerformRecordAction = _this._handlePerformRecordAction.bind(_this);
    return _this;
  }

  /** @internal */
  (0, _inherits2.default)(PerformRecordAction, _AbstractModelWithAsy);
  return (0, _createClass2.default)(PerformRecordAction, [{
    key: "_handlePerformRecordAction",
    value: /** @hidden */
    function _handlePerformRecordAction(data) {
      this.recordActionData = data;
      this._onChange(WatchablePerformRecordActionKeys.recordActionData, data);
    }

    /**
     * This accessor method is defined solely to satisfy the contract of the
     * AbstractModel class.
     *
     * @internal */
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      return (0, _error_utils.invariant)(false, 'The `data` property of PerformRecordAction should not be referenced');
    }

    /**
     * This accessor method is defined because the parent implementation uses _dataOrNullIfDeleted
     *
     * @inheritdoc */
  }, {
    key: "isDeleted",
    get: function get() {
      return false;
    }

    /**
     * AbstractModelWithAsyncData implementation
     */

    /** @internal */
  }, {
    key: "_onChangeIsDataLoaded",
    value: function _onChangeIsDataLoaded() {
      this._onChange(WatchablePerformRecordActionKeys.isDataLoaded);

      // Handle the case where there was a pending action whilst we were registering the handler.
      // We only want to do this on the very initial load when we're actually registering the
      // handler: avoid triggering this when the data is "unloaded" and "loaded".
      if (!this._hasCompletedInitialDataLoad) {
        this._hasCompletedInitialDataLoad = true;
        if (this.recordActionData) {
          this._handlePerformRecordAction(this.recordActionData);
        }
      }
    }

    /** @internal */
  }, {
    key: "_loadDataAsync",
    value: (function () {
      var _loadDataAsync2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this._hasRegisteredHandler) {
                _context.next = 5;
                break;
              }
              this._hasRegisteredHandler = true;
              _context.next = 4;
              return this._airtableInterface.fetchAndSubscribeToPerformRecordActionAsync(this._handlePerformRecordAction);
            case 4:
              this.recordActionData = _context.sent;
            case 5:
              return _context.abrupt("return", []);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _loadDataAsync() {
        return _loadDataAsync2.apply(this, arguments);
      }
      return _loadDataAsync;
    }() /** @internal */)
  }, {
    key: "_unloadData",
    value: function _unloadData() {
      // Hack: Don't do anything, since "loading" means registering a handler, and we don't need
      // to unregister it.
    }

    /** @internal */
  }], [{
    key: "_isWatchableKey",
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchablePerformRecordActionKeys, key);
    }
  }, {
    key: "_shouldLoadDataForKey",
    value: function _shouldLoadDataForKey(key) {
      // Watching recordActionData will load data (aka register handler with liveapp) and trigger
      // callback when done.
      return key === WatchablePerformRecordActionKeys.recordActionData;
    }
  }]);
}(_abstract_model_with_async_data.default);
/**
 * Registers a callback to handle "open block" / "perform record action" events (from button field).
 *
 * Returns a unsubscribe function that should be used to unregister the callback for cleanup on
 * component unmount, or if you wish to register a different function.
 *
 * Also see {@link useRecordActionData}, which subscribes to the same events in a synchronous way.
 *
 * Your block will not receive "perform record action" events until a callback is registered -
 * they're held until registration to ensure the block is ready to handle the event (e.g. has
 * finished loading).
 *
 * Because of this, we recommend only registering a callback once, in your top level component -
 * otherwise, messages could be received while not all callbacks have been successfully registered.
 * Similarly, using both `registerRecordActionDataCallback` and `useRecordActionData` is not
 * supported.
 *
 * You can test your block in development by sending "perform record action" events to your block
 * in the "Advanced" panel of the block developer tools.
 *
 * After releasing your block, you can use it with a button field by choosing the "Open custom
 * block" action and selecting your block.
 *
 * @example
 * ```js
 * import React, {useEffect, useState} from 'react';
 * import {registerRecordActionDataCallback} from '@airtable/blocks/ui';
 *
 * function LatestRecordAction() {
 *     const [recordActionData, setRecordActionData] = useState(null);
 *
 *     const callback = (data) => {
 *         console.log('Record action received', data);
 *         setRecordActionData(data);
 *     }
 *
 *     useEffect(() => {
 *         // Return the unsubscribe function so it's run on cleanup.
 *         return registerRecordActionDataCallback(callback);
 *     }, [callback]);
 *
 *     if (recordActionData === null) {
 *         return <span>No events yet</span>;
 *     }
 *
 *     return (
 *         <ul>
 *             <li>Record id: {recordActionData.recordId}</li>
 *             <li>View id: {recordActionData.viewId}</li>
 *             <li>Table id: {recordActionData.tableId}</li>
 *         </ul>
 *     );
 * }
 * ```
 *
 */
function registerRecordActionDataCallback(callback) {
  var _sdk2 = sdk,
    performRecordAction = _sdk2.performRecordAction;
  var wrappedCallback = (model, key, data) => {
    callback(data);
  };
  performRecordAction.watch(WatchablePerformRecordActionKeys.recordActionData, wrappedCallback);
  return () => performRecordAction.unwatch(WatchablePerformRecordActionKeys.recordActionData, wrappedCallback);
}
var sdk;

// The application-level Sdk instance must be injected dynamically to avoid
// circular dependencies at the time of module resolution.
function __injectSdkIntoPerformRecordAction(_sdk) {
  sdk = _sdk;
}