"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.array.find-index.js");
require("core-js/modules/es.array.index-of.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.splice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _error_utils = require("../error_utils");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; } /** @hidden */ /** */
var WEAK_RETAIN_TIME_MS = 10000;
var ObjectPool = /*#__PURE__*/function () {
  /** @hidden */
  function ObjectPool(ctor) {
    (0, _classCallCheck2.default)(this, ObjectPool);
    /** @internal */
    (0, _defineProperty2.default)(this, "_objectsByKey", {});
    /** @internal */
    (0, _defineProperty2.default)(this, "_weakObjectsByKey", {});
    /** @internal */
    (0, _defineProperty2.default)(this, "_Ctor", void 0);
    this._Ctor = ctor;
  }

  // we have two different ways we can register an object for reuse - weak and strong. This one,
  // strong, will make sure that the object is kept in the pool until it is explicitly removed.
  /** @hidden */
  return (0, _createClass2.default)(ObjectPool, [{
    key: "registerObjectForReuseStrong",
    value: function registerObjectForReuseStrong(object) {
      this._unregisterObjectForReuseWeakIfExists(object);
      var objectKey = object.__poolKey;
      var pooledObjects = this._objectsByKey[objectKey];
      if (pooledObjects) {
        pooledObjects.push(object);
      } else {
        this._objectsByKey[objectKey] = [object];
      }
    }
    /** @hidden */
  }, {
    key: "unregisterObjectForReuseStrong",
    value: function unregisterObjectForReuseStrong(object) {
      var objectKey = object.__poolKey;
      var pooledObjects = this._objectsByKey[objectKey];
      (0, _error_utils.invariant)(pooledObjects, 'pooledObjects');
      var index = pooledObjects.indexOf(object);
      (0, _error_utils.invariant)(index !== -1, 'object not registered');
      pooledObjects.splice(index, 1);
      if (pooledObjects.length === 0) {
        // `delete` causes de-opts, which slows down subsequent reads,
        // so set to undefined instead (unverified that this is actually faster).
        this._objectsByKey[objectKey] = undefined;
      }
    }

    // we have two different ways we can register an object for reuse - weak and strong. This one,
    // weak, will automatically unregister the object after a few seconds go by without it being
    // used.
    /** @hidden */
  }, {
    key: "_registerObjectForReuseWeak",
    value: function _registerObjectForReuseWeak(object) {
      var objectKey = object.__poolKey;
      var pooledObjects = this._weakObjectsByKey[objectKey];
      var toStore = {
        object,
        timeoutId: setTimeout(() => this._unregisterObjectForReuseWeakIfExists(object), WEAK_RETAIN_TIME_MS)
      };
      if (pooledObjects) {
        pooledObjects.push(toStore);
      } else {
        this._weakObjectsByKey[objectKey] = [toStore];
      }
    }
    /** @internal */
  }, {
    key: "_unregisterObjectForReuseWeakIfExists",
    value: function _unregisterObjectForReuseWeakIfExists(object) {
      var objectKey = object.__poolKey;
      var pooledObjects = this._weakObjectsByKey[objectKey];
      if (!pooledObjects) {
        return false;
      }
      var index = pooledObjects.findIndex(stored => stored.object === object);
      if (index === -1) {
        return false;
      }
      var stored = pooledObjects[index];
      clearTimeout(stored.timeoutId);
      pooledObjects.splice(index, 1);
      if (pooledObjects.length === 0) {
        // `delete` causes de-opts, which slows down subsequent reads,
        // so set to undefined instead (unverified that this is actually faster).
        this._weakObjectsByKey[objectKey] = undefined;
      }
      return true;
    }

    /** @internal */
  }, {
    key: "_getObjectForReuseStrong",
    value: function _getObjectForReuseStrong(key) {
      var pooledObjects = this._objectsByKey[key];
      if (pooledObjects) {
        // We expect that there won't be too many QueryResults for a given
        // model, so iterating over them should be okay. If this assumption
        // ends up being wrong, we can hash the opts or something.
        var _iterator = _createForOfIteratorHelper(pooledObjects),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var object = _step.value;
            if (object.__poolKey === key) {
              return object;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      return null;
    }
    /** @internal */
  }, {
    key: "_getObjectForReuseWeak",
    value: function _getObjectForReuseWeak(key) {
      var pooledObjects = this._weakObjectsByKey[key];
      if (!pooledObjects) {
        return null;
      }
      var stored = pooledObjects.find(_ref => {
        var object = _ref.object;
        return object.__poolKey === key;
      });
      if (!stored) {
        return null;
      }
      var object = stored.object,
        timeoutId = stored.timeoutId;

      // reset the timer on this object if it's reused
      clearTimeout(timeoutId);
      stored.timeoutId = setTimeout(() => this._unregisterObjectForReuseWeakIfExists(object), WEAK_RETAIN_TIME_MS);
      return object;
    }
    /** @hidden */
  }, {
    key: "getObjectForReuse",
    value: function getObjectForReuse() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var newObject = new this._Ctor(...args);
      var key = newObject.__poolKey;
      var existingObject = this._getObjectForReuseStrong(key) || this._getObjectForReuseWeak(key);
      if (existingObject) {
        return existingObject;
      }
      this._registerObjectForReuseWeak(newObject);
      return newObject;
    }
  }]);
}();
var _default = exports.default = ObjectPool;