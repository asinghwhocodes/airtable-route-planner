"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.WatchableRecordStoreKeys = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.object.entries.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _private_utils = require("../private_utils");
var _error_utils = require("../error_utils");
var _abstract_model_with_async_data = _interopRequireDefault(require("./abstract_model_with_async_data"));
var _record = _interopRequireDefault(require("./record"));
var _view_data_store = _interopRequireDefault(require("./view_data_store"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var WatchableRecordStoreKeys = exports.WatchableRecordStoreKeys = Object.freeze({
  records: 'records',
  recordIds: 'recordIds',
  cellValues: 'cellValues'
});
var WatchableCellValuesInFieldKeyPrefix = 'cellValuesInField:';

/**
 * The string case is to accommodate prefix keys
 *
 * @internal
 */
/**
 * One RecordStore exists per table, and contains all the record data associated with that table.
 * Table itself is for schema information only, so isn't the appropriate place for this data.
 *
 * @internal
 */
var RecordStore = /*#__PURE__*/function (_AbstractModelWithAsy) {
  function RecordStore(sdk, tableId) {
    var _this;
    (0, _classCallCheck2.default)(this, RecordStore);
    _this = _callSuper(this, RecordStore, [sdk, "".concat(tableId, "-RecordStore")]);
    (0, _defineProperty2.default)(_this, "tableId", void 0);
    (0, _defineProperty2.default)(_this, "_recordModelsById", {});
    (0, _defineProperty2.default)(_this, "_primaryFieldId", void 0);
    (0, _defineProperty2.default)(_this, "_airtableInterface", void 0);
    (0, _defineProperty2.default)(_this, "_viewDataStoresByViewId", {});
    // There is a lot of duplication here and in AbstractModelWithAsyncData.
    // Alternatively, phase out AbstractModelWithAsyncData as a superclass
    // and instead create a helper class for managing each part of the data
    // tree that is loaded.
    (0, _defineProperty2.default)(_this, "_areCellValuesLoadedByFieldId", {});
    (0, _defineProperty2.default)(_this, "_pendingCellValuesLoadPromiseByFieldId", {});
    (0, _defineProperty2.default)(_this, "_cellValuesRetainCountByFieldId", {});
    (0, _defineProperty2.default)(_this, "_timeoutForRemovingFieldIds", null);
    _this._airtableInterface = sdk.__airtableInterface;
    _this.tableId = tableId;
    // A bit of a hack, but we use the primary field ID to load record
    // metadata (see _getFieldIdForCausingRecordMetadataToLoad). We copy the
    // ID here instead of calling this.primaryField.id since that would crash
    // when the table is getting unloaded after being deleted.
    _this._primaryFieldId = _this._data.primaryFieldId;
    return _this;
  }
  (0, _inherits2.default)(RecordStore, _AbstractModelWithAsy);
  return (0, _createClass2.default)(RecordStore, [{
    key: "getViewDataStore",
    value: function getViewDataStore(viewId) {
      if (this._viewDataStoresByViewId[viewId]) {
        return this._viewDataStoresByViewId[viewId];
      }
      (0, _error_utils.invariant)(this._data.viewsById[viewId], 'view must exist');
      var viewDataStore = new _view_data_store.default(this._sdk, this, viewId);
      this._viewDataStoresByViewId[viewId] = viewDataStore;
      return viewDataStore;
    }
  }, {
    key: "watch",
    value: function watch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(RecordStore.prototype), "watch", this).call(this, keys, callback, context);
      var fieldIdsToLoad = this._getFieldIdsToLoadFromWatchableKeys(validKeys);
      if (fieldIdsToLoad.length > 0) {
        (0, _private_utils.fireAndForgetPromise)(this.loadCellValuesInFieldIdsAsync.bind(this, fieldIdsToLoad));
      }
      return validKeys;
    }
  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(RecordStore.prototype), "unwatch", this).call(this, keys, callback, context);
      var fieldIdsToUnload = this._getFieldIdsToLoadFromWatchableKeys(validKeys);
      if (fieldIdsToUnload.length > 0) {
        this.unloadCellValuesInFieldIds(fieldIdsToUnload);
      }
      return validKeys;
    }
  }, {
    key: "_getFieldIdsToLoadFromWatchableKeys",
    value: function _getFieldIdsToLoadFromWatchableKeys(keys) {
      var fieldIdsToLoad = [];
      var _iterator = _createForOfIteratorHelper(keys),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          if (key.startsWith(WatchableCellValuesInFieldKeyPrefix)) {
            var fieldId = key.substring(WatchableCellValuesInFieldKeyPrefix.length);
            fieldIdsToLoad.push(fieldId);
          } else if (key === WatchableRecordStoreKeys.records || key === WatchableRecordStoreKeys.recordIds) {
            fieldIdsToLoad.push(this._getFieldIdForCausingRecordMetadataToLoad());
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return fieldIdsToLoad;
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      var _this$_baseData$table;
      return (_this$_baseData$table = this._baseData.tablesById[this.tableId]) !== null && _this$_baseData$table !== void 0 ? _this$_baseData$table : null;
    }
  }, {
    key: "_onChangeIsDataLoaded",
    value: function _onChangeIsDataLoaded() {
      // noop
    }

    /**
     * The records in this table. The order is arbitrary since records are
     * only ordered in the context of a specific view.
     */
  }, {
    key: "records",
    get: function get() {
      var recordsById = this._data.recordsById;
      (0, _error_utils.invariant)(recordsById, 'Record metadata is not loaded');
      var records = Object.keys(recordsById).map(recordId => {
        var record = this.getRecordByIdIfExists(recordId);
        (0, _error_utils.invariant)(record, 'record');
        return record;
      });
      return records;
    }

    /**
     * The record IDs in this table. The order is arbitrary since records are
     * only ordered in the context of a specific view.
     */
  }, {
    key: "recordIds",
    get: function get() {
      var recordsById = this._data.recordsById;
      (0, _error_utils.invariant)(recordsById, 'Record metadata is not loaded');
      return Object.keys(recordsById);
    }
  }, {
    key: "getRecordByIdIfExists",
    value: function getRecordByIdIfExists(recordId) {
      var recordsById = this._data.recordsById;
      (0, _error_utils.invariant)(recordsById, 'Record metadata is not loaded');
      (0, _error_utils.invariant)(typeof recordId === 'string', 'getRecordById expects a string');
      if (!recordsById[recordId]) {
        return null;
      } else {
        if (this._recordModelsById[recordId]) {
          return this._recordModelsById[recordId];
        }
        var newRecord = new _record.default(this._sdk, this, this._sdk.base.getTableById(this.tableId), recordId);
        this._recordModelsById[recordId] = newRecord;
        return newRecord;
      }
    }
  }, {
    key: "__onDataDeletion",
    value: function __onDataDeletion() {
      // also need to call unloadCellValuesInFieldIds because otherwise
      // on the hyperbase side, the old record store would still be subscribed
      // to the cell values and it will refuse a request for new subscription
      for (var _i = 0, _Object$keys = Object.keys(this._cellValuesRetainCountByFieldId); _i < _Object$keys.length; _i++) {
        var fieldId = _Object$keys[_i];
        while (this._cellValuesRetainCountByFieldId[fieldId] && this._cellValuesRetainCountByFieldId[fieldId] > 0) {
          this.unloadCellValuesInFieldIds([fieldId]);
        }
      }
      this._forceUnload();

      // similarly unsubscribe from the view data.
      // this comes after _forceUnload to avoid over releasing the table data.
      var _iterator2 = _createForOfIteratorHelper((0, _private_utils.values)(this._viewDataStoresByViewId)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var viewDataStore = _step2.value;
          viewDataStore.__onDataDeletion();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    /**
     * Record metadata means record IDs, createdTime, and commentCount are loaded.
     * Record metadata must be loaded before creating, deleting, or updating records.
     */
  }, {
    key: "isRecordMetadataLoaded",
    get: function get() {
      return !!this._data.recordsById;
    }
  }, {
    key: "loadRecordMetadataAsync",
    value: function () {
      var _loadRecordMetadataAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.loadCellValuesInFieldIdsAsync([this._getFieldIdForCausingRecordMetadataToLoad()]);
            case 2:
              return _context.abrupt("return", _context.sent);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function loadRecordMetadataAsync() {
        return _loadRecordMetadataAsync.apply(this, arguments);
      }
      return loadRecordMetadataAsync;
    }()
  }, {
    key: "unloadRecordMetadata",
    value: function unloadRecordMetadata() {
      this.unloadCellValuesInFieldIds([this._getFieldIdForCausingRecordMetadataToLoad()]);
    }
  }, {
    key: "_getFieldIdForCausingRecordMetadataToLoad",
    value: function _getFieldIdForCausingRecordMetadataToLoad() {
      // As a shortcut, we'll load the primary field cell values to
      // cause record metadata (id, createdTime, commentCount) to be loaded
      // and subscribed to. In the future, we could add an explicit model
      // bridge to fetch and subscribe to row metadata.
      return this._primaryFieldId;
    }
  }, {
    key: "areCellValuesLoadedForFieldId",
    value: function areCellValuesLoadedForFieldId(fieldId) {
      return this.isDataLoaded || this._areCellValuesLoadedByFieldId[fieldId] || false;
    }
  }, {
    key: "loadCellValuesInFieldIdsAsync",
    value: function () {
      var _loadCellValuesInFieldIdsAsync2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(fieldIds) {
        var fieldIdsWhichAreNotAlreadyLoadedOrLoading, pendingLoadPromises, _iterator3, _step3, _fieldId, pendingLoadPromise, loadFieldsWhichAreNotAlreadyLoadedOrLoadingPromise, _iterator4, _step4, fieldId;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this._assertNotForceUnloaded();
              fieldIdsWhichAreNotAlreadyLoadedOrLoading = [];
              pendingLoadPromises = [];
              _iterator3 = _createForOfIteratorHelper(fieldIds);
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  _fieldId = _step3.value;
                  if (this._cellValuesRetainCountByFieldId[_fieldId] !== undefined) {
                    this._cellValuesRetainCountByFieldId[_fieldId]++;
                  } else {
                    this._cellValuesRetainCountByFieldId[_fieldId] = 1;
                  }

                  // NOTE: we don't use this.areCellValuesLoadedForFieldId() here because
                  // that will return true if the cell values are loaded as a result
                  // of the entire table being loaded. In that scenario, we still
                  // want to separately load the cell values for the field so there
                  // is a separate subscription. Otherwise, when the table data unloads,
                  // the field data would unload as well. This can be improved by just
                  // subscribing to the field data without fetching it, since the cell
                  // values are already in the block frame.
                  if (!this._areCellValuesLoadedByFieldId[_fieldId]) {
                    pendingLoadPromise = this._pendingCellValuesLoadPromiseByFieldId[_fieldId];
                    if (pendingLoadPromise) {
                      pendingLoadPromises.push(pendingLoadPromise);
                    } else {
                      fieldIdsWhichAreNotAlreadyLoadedOrLoading.push(_fieldId);
                    }
                  }
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              if (fieldIdsWhichAreNotAlreadyLoadedOrLoading.length > 0) {
                // Could inline _loadCellValuesInFieldIdsAsync, but following the
                // pattern from AbstractModelWithAsyncData where the public method
                // is responsible for updating retain counts and the private method
                // actually fetches data.
                loadFieldsWhichAreNotAlreadyLoadedOrLoadingPromise = this._loadCellValuesInFieldIdsAsync(fieldIdsWhichAreNotAlreadyLoadedOrLoading);
                pendingLoadPromises.push(loadFieldsWhichAreNotAlreadyLoadedOrLoadingPromise);
                _iterator4 = _createForOfIteratorHelper(fieldIdsWhichAreNotAlreadyLoadedOrLoading);
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    fieldId = _step4.value;
                    this._pendingCellValuesLoadPromiseByFieldId[fieldId] = loadFieldsWhichAreNotAlreadyLoadedOrLoadingPromise;
                  }
                  // Doing `.then` instead of performing these actions directly in
                  // _loadCellValuesInFieldIdsAsync so this is similar to
                  // AbstractModelWithAsyncData. The idea is to refactor to avoid code
                  // duplication, so keeping them similar for now hopefully will make the
                  // refactor simpler.
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
                loadFieldsWhichAreNotAlreadyLoadedOrLoadingPromise.then(changedKeys => {
                  var _iterator5 = _createForOfIteratorHelper(fieldIdsWhichAreNotAlreadyLoadedOrLoading),
                    _step5;
                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                      var fieldId = _step5.value;
                      this._areCellValuesLoadedByFieldId[fieldId] = true;
                      this._pendingCellValuesLoadPromiseByFieldId[fieldId] = undefined;
                    }
                  } catch (err) {
                    _iterator5.e(err);
                  } finally {
                    _iterator5.f();
                  }
                  var _iterator6 = _createForOfIteratorHelper(changedKeys),
                    _step6;
                  try {
                    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                      var key = _step6.value;
                      this._onChange(key);
                    }
                  } catch (err) {
                    _iterator6.e(err);
                  } finally {
                    _iterator6.f();
                  }
                });
              }
              // Since we are incrementing fieldIds, it's necessary to restart any pending timeouts
              // to unload data. This is because it's possible for a timeout to fire while a queryResult
              // is actively unloading, and erroneously unload data. Data must be unloaded _after_ the queryResult.
              this._restartTimeoutToUnloadFieldIdsIfTimeoutIsActive();
              _context2.next = 9;
              return Promise.all(pendingLoadPromises);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function loadCellValuesInFieldIdsAsync(_x) {
        return _loadCellValuesInFieldIdsAsync2.apply(this, arguments);
      }
      return loadCellValuesInFieldIdsAsync;
    }()
  }, {
    key: "_loadCellValuesInFieldIdsAsync",
    value: function () {
      var _loadCellValuesInFieldIdsAsync3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(fieldIds) {
        var _yield$this$_airtable, newRecordsById, existingRecordsById, _iterator7, _step7, _step7$value, recordId, newRecordObj, existingRecordObj, isCommentCountTypesSame, isCreatedTimeTypesSame, existingCellValuesByFieldId, i, fieldId, changedKeys;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this._airtableInterface.fetchAndSubscribeToCellValuesInFieldsAsync(this.tableId, fieldIds);
            case 2:
              _yield$this$_airtable = _context3.sent;
              newRecordsById = _yield$this$_airtable.recordsById;
              // Merge with existing data.
              if (!this._data.recordsById) {
                this._data.recordsById = {};
              }
              existingRecordsById = this._data.recordsById;
              _iterator7 = _createForOfIteratorHelper((0, _private_utils.entries)((0, _private_utils.cast)(newRecordsById)));
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  _step7$value = (0, _slicedToArray2.default)(_step7.value, 2), recordId = _step7$value[0], newRecordObj = _step7$value[1];
                  if (!(0, _private_utils.has)(existingRecordsById, recordId)) {
                    existingRecordsById[recordId] = newRecordObj;
                  } else {
                    existingRecordObj = existingRecordsById[recordId]; // Metadata (createdTime, commentCount) should generally be up to date,
                    // but can be out of date in the rare scenario where realtime
                    // data has not yet been delivered to the SDK, but is populated in hyperbase
                    // at the time this new fetch is executed.
                    // istanbul ignore next
                    if (existingRecordObj.commentCount !== newRecordObj.commentCount) {
                      isCommentCountTypesSame = typeof existingRecordObj.commentCount !== typeof newRecordObj.commentCount;
                      (0, _error_utils.logErrorToSentry)('comment count out of sync - types are same: %s', {
                        isCommentCountTypesSame
                      });
                    }

                    // istanbul ignore next
                    if (existingRecordObj.createdTime !== newRecordObj.createdTime) {
                      isCreatedTimeTypesSame = typeof existingRecordObj.createdTime !== typeof newRecordObj.createdTime;
                      (0, _error_utils.logErrorToSentry)('created time out of sync - types are same: %s', {
                        isCreatedTimeTypesSame
                      });
                    }
                    if (!existingRecordObj.cellValuesByFieldId) {
                      existingRecordObj.cellValuesByFieldId = {};
                    }
                    existingCellValuesByFieldId = existingRecordObj.cellValuesByFieldId;
                    for (i = 0; i < fieldIds.length; i++) {
                      fieldId = fieldIds[i];
                      existingCellValuesByFieldId[fieldId] = newRecordObj.cellValuesByFieldId ? newRecordObj.cellValuesByFieldId[fieldId] : undefined;
                    }
                  }
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
              changedKeys = fieldIds.map(fieldId => WatchableCellValuesInFieldKeyPrefix + fieldId); // Need to trigger onChange for records and recordIds since watching either
              // of those causes record metadata to be loaded (via _getFieldIdForCausingRecordMetadataToLoad)
              // and by convention we trigger a change event when data loads.
              changedKeys.push(WatchableRecordStoreKeys.records);
              changedKeys.push(WatchableRecordStoreKeys.recordIds);
              // Also trigger cellValues changes since the cell values in the fields
              // are now loaded.
              changedKeys.push(WatchableRecordStoreKeys.cellValues);
              return _context3.abrupt("return", changedKeys);
            case 13:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _loadCellValuesInFieldIdsAsync(_x2) {
        return _loadCellValuesInFieldIdsAsync3.apply(this, arguments);
      }
      return _loadCellValuesInFieldIdsAsync;
    }()
  }, {
    key: "unloadCellValuesInFieldIds",
    value: function unloadCellValuesInFieldIds(fieldIds) {
      if (this._isForceUnloaded) {
        return;
      }
      var _iterator8 = _createForOfIteratorHelper(fieldIds),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var fieldId = _step8.value;
          var fieldRetainCount = this._cellValuesRetainCountByFieldId[fieldId] || 0;
          fieldRetainCount--;
          if (fieldRetainCount < 0) {
            console.log('Field data over-released'); // eslint-disable-line no-console
            fieldRetainCount = 0;
          }
          this._cellValuesRetainCountByFieldId[fieldId] = fieldRetainCount;
        }
        // Don't unload immediately. Wait a while in case something else
        // requests the data, so we can avoid going back to liveapp or
        // the network.
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      this._startTimeoutToUnloadForFieldIdsIfNeeded();
    }

    // This unloads all fields where the retain count is at zero, and if any other
    // request to unload fields is pending - cancels it and restarts it.
    // This is important because fields must always be unloaded at least __DATA_UNLOAD_DELAY_MS
    // after the unload is requested so that any QueryResults relying on them properly
    // unload either first, or at the same time
  }, {
    key: "_startTimeoutToUnloadForFieldIdsIfNeeded",
    value: function _startTimeoutToUnloadForFieldIdsIfNeeded() {
      var fieldIdsWithZeroRetainCount = [];
      for (var _i2 = 0, _Object$entries = Object.entries(this._cellValuesRetainCountByFieldId); _i2 < _Object$entries.length; _i2++) {
        var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i2], 2),
          fieldId = _Object$entries$_i[0],
          retainCount = _Object$entries$_i[1];
        if (retainCount === 0) {
          fieldIdsWithZeroRetainCount.push(fieldId);
        }
      }

      // Cancel any pending timeouts before proceeding
      // This should be canceled even if there aren't any fields to unload as that means
      // that there has been loading that's occured that makes the pending request invalid
      if (this._timeoutForRemovingFieldIds) {
        clearTimeout(this._timeoutForRemovingFieldIds);
        this._timeoutForRemovingFieldIds = null;
      }
      if (fieldIdsWithZeroRetainCount.length > 0) {
        this._timeoutForRemovingFieldIds = setTimeout(() => {
          // Make sure the retain count is still zero, since it may
          // have been incremented before the timeout fired.
          var fieldIdsToUnload = fieldIdsWithZeroRetainCount.filter(fieldId => {
            // It's necessary to also check that the field is loaded, as it's possible
            // for an unload to trigger with fields that have already been removed.
            return this._cellValuesRetainCountByFieldId[fieldId] === 0 && this._areCellValuesLoadedByFieldId[fieldId];
          });
          // istanbul ignore else
          if (fieldIdsToUnload.length > 0) {
            // Set _areCellValuesLoadedByFieldId to false before calling _unloadCellValuesInFieldIds
            // since _unloadCellValuesInFieldIds will check if *any* fields are still loaded.
            var _iterator9 = _createForOfIteratorHelper(fieldIdsToUnload),
              _step9;
            try {
              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                var _fieldId2 = _step9.value;
                this._areCellValuesLoadedByFieldId[_fieldId2] = false;
              }
            } catch (err) {
              _iterator9.e(err);
            } finally {
              _iterator9.f();
            }
            this._unloadCellValuesInFieldIds(fieldIdsToUnload);
          } else {
            // This shouldn't be possible because we always cancel the timer if fieldIds loadedness
            // status ever changes
            (0, _error_utils.logErrorToSentry)('fieldIdsToUnload is empty, this likely means the unload timer is not properly reset.');
          }
          this._timeoutForRemovingFieldIds = null;
        }, _abstract_model_with_async_data.default.__DATA_UNLOAD_DELAY_MS);
      }
    }
  }, {
    key: "_restartTimeoutToUnloadFieldIdsIfTimeoutIsActive",
    value: function _restartTimeoutToUnloadFieldIdsIfTimeoutIsActive() {
      if (this._timeoutForRemovingFieldIds) {
        this._startTimeoutToUnloadForFieldIdsIfNeeded();
      }
    }
  }, {
    key: "_unloadCellValuesInFieldIds",
    value: function _unloadCellValuesInFieldIds(fieldIds) {
      this._airtableInterface.unsubscribeFromCellValuesInFields(this.tableId, fieldIds);
      this._afterUnloadDataOrUnloadCellValuesInFieldIds(fieldIds);
    }
  }, {
    key: "_loadDataAsync",
    value: function () {
      var _loadDataAsync2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
        var tableData, changedKeys, _iterator10, _step10, fieldId;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this._airtableInterface.fetchAndSubscribeToTableDataAsync(this.tableId);
            case 2:
              tableData = _context4.sent;
              this._data.recordsById = tableData.recordsById;
              changedKeys = [WatchableRecordStoreKeys.records, WatchableRecordStoreKeys.recordIds, WatchableRecordStoreKeys.cellValues];
              _iterator10 = _createForOfIteratorHelper((0, _private_utils.keys)(this._data.fieldsById));
              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  fieldId = _step10.value;
                  changedKeys.push(WatchableCellValuesInFieldKeyPrefix + fieldId);
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
              return _context4.abrupt("return", changedKeys);
            case 8:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function _loadDataAsync() {
        return _loadDataAsync2.apply(this, arguments);
      }
      return _loadDataAsync;
    }()
  }, {
    key: "_unloadData",
    value: function _unloadData() {
      this._airtableInterface.unsubscribeFromTableData(this.tableId);
      this._afterUnloadDataOrUnloadCellValuesInFieldIds();
    }
  }, {
    key: "_afterUnloadDataOrUnloadCellValuesInFieldIds",
    value: function _afterUnloadDataOrUnloadCellValuesInFieldIds(unloadedFieldIds) {
      var areAnyFieldsLoaded = this.isDataLoaded || (0, _private_utils.values)(this._areCellValuesLoadedByFieldId).some(isLoaded => isLoaded);
      if (!this.isDeleted) {
        if (!areAnyFieldsLoaded) {
          this._data.recordsById = undefined;
        } else if (!this.isDataLoaded) {
          var fieldIdsToClear;
          // This should be impossible - for fields should always be loaded
          // when attempting to unload specific fields. This codepath was previously possible
          // due to a bug. It could be converted to an invariant, but that is higher risk.
          // istanbul ignore if
          if (unloadedFieldIds) {
            // Specific fields were unloaded, so clear out the cell values for those fields.
            fieldIdsToClear = unloadedFieldIds;
            (0, _error_utils.logErrorToSentry)('Field Ids are being unloaded when record_store is unloaded');
          } else {
            // The entire table was unloaded, but some individual fields are still loaded.
            // We need to clear out the cell values of every field that was unloaded.
            // This is kind of slow, but hopefully uncommon.
            var fieldIds = Object.keys(this._data.fieldsById);
            fieldIdsToClear = fieldIds.filter(fieldId => !this._areCellValuesLoadedByFieldId[fieldId]);
          }
          var recordsById = this._data.recordsById;
          var _iterator11 = _createForOfIteratorHelper((0, _private_utils.values)(recordsById || {})),
            _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var recordObj = _step11.value;
              for (var i = 0; i < fieldIdsToClear.length; i++) {
                var fieldId = fieldIdsToClear[i];
                if (recordObj.cellValuesByFieldId) {
                  recordObj.cellValuesByFieldId[fieldId] = undefined;
                }
              }
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
        }
      }
      if (!areAnyFieldsLoaded) {
        this._recordModelsById = {};
      }
    }
  }, {
    key: "triggerOnChangeForDirtyPaths",
    value: function triggerOnChangeForDirtyPaths(dirtyPaths) {
      if (this.isRecordMetadataLoaded && dirtyPaths.recordsById) {
        // Since tables don't have a record order, need to detect if a record
        // was created or deleted and trigger onChange for records.
        var dirtyFieldIdsSet = {};
        var addedRecordIds = [];
        var removedRecordIds = [];
        for (var _i3 = 0, _arr = (0, _private_utils.entries)(dirtyPaths.recordsById); _i3 < _arr.length; _i3++) {
          var _arr$_i = (0, _slicedToArray2.default)(_arr[_i3], 2),
            recordId = _arr$_i[0],
            dirtyRecordPaths = _arr$_i[1];
          if (dirtyRecordPaths && dirtyRecordPaths._isDirty) {
            // If the entire record is dirty, it was either created or deleted.
            (0, _error_utils.invariant)(this._data.recordsById, 'No recordsById');
            if ((0, _private_utils.has)(this._data.recordsById, recordId)) {
              addedRecordIds.push(recordId);
            } else {
              removedRecordIds.push(recordId);
              var recordModel = this._recordModelsById[recordId];
              if (recordModel) {
                // Remove the Record model if it was deleted.
                delete this._recordModelsById[recordId];
              }
            }
          } else {
            var _recordModel = this._recordModelsById[recordId];
            if (_recordModel) {
              _recordModel.__triggerOnChangeForDirtyPaths(dirtyRecordPaths);
            }
          }
          var cellValuesByFieldId = dirtyRecordPaths.cellValuesByFieldId;
          if (cellValuesByFieldId) {
            for (var _i4 = 0, _Object$keys2 = Object.keys(cellValuesByFieldId); _i4 < _Object$keys2.length; _i4++) {
              var fieldId = _Object$keys2[_i4];
              dirtyFieldIdsSet[fieldId] = true;
            }
          }
        }

        // Now that we've composed our created/deleted record ids arrays, let's fire
        // the records onChange event if any records were created or deleted.
        if (addedRecordIds.length > 0 || removedRecordIds.length > 0) {
          this._onChange(WatchableRecordStoreKeys.records, {
            addedRecordIds,
            removedRecordIds
          });
          this._onChange(WatchableRecordStoreKeys.recordIds, {
            addedRecordIds,
            removedRecordIds
          });
        }

        // NOTE: this is an experimental (and somewhat messy) way to watch
        // for changes to cells in a table, as an alternative to implementing
        // full event bubbling. For now, it unblocks the things we want to
        // build, but we may replace it.
        // If we keep it, could be more efficient by not calling _onChange
        // if there are no subscribers.
        // TODO: don't trigger changes for fields that aren't supposed to be loaded
        // (in some cases, e.g. record created, liveapp will send cell values
        // that we're not subscribed to).
        var fieldIds = Object.freeze(Object.keys(dirtyFieldIdsSet));
        var recordIds = Object.freeze(Object.keys(dirtyPaths.recordsById));
        if (fieldIds.length > 0 && recordIds.length > 0) {
          this._onChange(WatchableRecordStoreKeys.cellValues, {
            recordIds,
            fieldIds
          });
        }
        var _iterator12 = _createForOfIteratorHelper(fieldIds),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var _fieldId3 = _step12.value;
            this._onChange(WatchableCellValuesInFieldKeyPrefix + _fieldId3, recordIds, _fieldId3);
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
      }
      if (dirtyPaths.viewOrder) {
        // clean up deleted views
        var _iterator13 = _createForOfIteratorHelper((0, _private_utils.entries)(this._viewDataStoresByViewId)),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var _step13$value = (0, _slicedToArray2.default)(_step13.value, 2),
              viewId = _step13$value[0],
              viewDataStore = _step13$value[1];
            if (viewDataStore.isDeleted) {
              viewDataStore.__onDataDeletion();
              delete this._viewDataStoresByViewId[viewId];
            }
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }
    }
  }], [{
    key: "_isWatchableKey",
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableRecordStoreKeys, key) || key.startsWith(WatchableCellValuesInFieldKeyPrefix);
    }
  }, {
    key: "_shouldLoadDataForKey",
    value: function _shouldLoadDataForKey(key) {
      // "Data" means *all* cell values in the table. If only watching records/recordIds,
      // we'll just load record metadata (id, createdTime, commentCount).
      // If only watching specific fields, we'll just load cell values in those
      // fields. Both of those scenarios are handled manually by this class,
      // instead of relying on AbstractModelWithAsyncData.
      return key === WatchableRecordStoreKeys.cellValues;
    }
  }]);
}(_abstract_model_with_async_data.default);
/** @internal */
(0, _defineProperty2.default)(RecordStore, "_className", 'RecordStore');
var _default = exports.default = RecordStore;