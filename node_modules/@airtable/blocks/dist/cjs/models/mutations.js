"use strict";

require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.string.includes.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _airtable_interface = require("../types/airtable_interface");
var _mutations = require("../types/mutations");
var _private_utils = require("../private_utils");
var _error_utils = require("../error_utils");
var _mutation_constants = require("./mutation_constants");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// Limit for how many items can be updated from a single batch mutation.
// This is number of records for MULTIPLE_RECORDS type mutations, and number of global config paths
// for SET_MULTIPLE_GLOBAL_CONFIG_PATHS.
// Same limit is enforced liveapp-side
var MUTATIONS_MAX_BATCH_SIZE = 50;

// Liveapp requests must be under 2mb in size: we enforce a 1.9mb limit here to allow space for
// the other parts of the request
var MUTATIONS_MAX_BODY_SIZE = 1.9 * 1024 * 1024;
var MUTATION_HOLD_FOR_MS = 100;

/** @internal */
var Mutations = /*#__PURE__*/function () {
  /** @hidden */
  function Mutations(sdk, session, base, applyModelChanges, applyGlobalConfigUpdates) {
    (0, _classCallCheck2.default)(this, Mutations);
    /** @internal */
    (0, _defineProperty2.default)(this, "_airtableInterface", void 0);
    /** @internal */
    (0, _defineProperty2.default)(this, "_session", void 0);
    /** @internal */
    (0, _defineProperty2.default)(this, "_sdk", void 0);
    /** @internal */
    (0, _defineProperty2.default)(this, "_base", void 0);
    /** @internal */
    (0, _defineProperty2.default)(this, "_applyModelChanges", void 0);
    /** @internal */
    (0, _defineProperty2.default)(this, "_applyGlobalConfigUpdates", void 0);
    this._airtableInterface = sdk.__airtableInterface;
    this._session = session;
    this._sdk = sdk;
    this._base = base;
    this._applyModelChanges = applyModelChanges;
    this._applyGlobalConfigUpdates = applyGlobalConfigUpdates;
  }

  /** @hidden */
  return (0, _createClass2.default)(Mutations, [{
    key: "applyMutationAsync",
    value: (function () {
      var _applyMutationAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(mutation) {
        var permissionCheck, didApplyOptimisticUpdates;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this._assertMutationIsValid(mutation);
              // Limit check is after validity check so that we display errors for when users pass in
              // objects correctly (eg updating linked records cell value to be a record object) -
              // otherwise the limit check will fail due to circular objects being converted to JSON first
              this._assertMutationUnderLimits(mutation);
              permissionCheck = this.checkPermissionsForMutation(mutation);
              if (permissionCheck.hasPermission) {
                _context.next = 5;
                break;
              }
              throw (0, _error_utils.spawnError)('Cannot apply %s mutation: %s', mutation.type, permissionCheck.reasonDisplayString);
            case 5:
              didApplyOptimisticUpdates = this._applyOptimisticUpdatesForMutation(mutation);
              _context.prev = 6;
              _context.next = 9;
              return this._airtableInterface.applyMutationAsync(mutation, {
                holdForMs: MUTATION_HOLD_FOR_MS
              });
            case 9:
              _context.next = 20;
              break;
            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](6);
              if (!didApplyOptimisticUpdates) {
                _context.next = 19;
                break;
              }
              // if we applied optimistic updates, we can't gracefully handle a promise rejection
              // here - we can't un-apply optimistic updates, so the SDK's internal data model is
              // in an unexpected state. Instead of letting this promise get rejected, throw an
              // error after an async gap to crash the block, and make this promise await
              // something that will never resolve so we don't run any of the developers error-
              // handling code.
              setTimeout(() => {
                throw _context.t0;
              }, 0);
              _context.next = 17;
              return new Promise(() => {});
            case 17:
              _context.next = 20;
              break;
            case 19:
              throw _context.t0;
            case 20:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[6, 11]]);
      }));
      function applyMutationAsync(_x) {
        return _applyMutationAsync.apply(this, arguments);
      }
      return applyMutationAsync;
    }() /** @hidden */)
  }, {
    key: "checkPermissionsForMutation",
    value: function checkPermissionsForMutation(mutation) {
      return this._airtableInterface.checkPermissionsForMutation(mutation, this._base.__getBaseData());
    }

    /** @internal */
  }, {
    key: "_assertMutationUnderLimits",
    value: function _assertMutationUnderLimits(mutation) {
      // Two limits to check here:
      // - for record-related mutations, it isn't above MUTATIONS_MAX_BATCH_SIZE
      // - mutation payload size won't exceed liveapp request payload size limit
      // Requests are sent as form-encoded utf-8 (1 byte characters)
      if (encodeURIComponent(JSON.stringify(mutation)).length > MUTATIONS_MAX_BODY_SIZE) {
        throw (0, _error_utils.spawnError)('Request exceeds maximum size limit of %s bytes', MUTATIONS_MAX_BODY_SIZE);
      }
      if (this._doesMutationExceedBatchSizeLimit(mutation)) {
        throw (0, _error_utils.spawnError)('Request exceeds maximum batch size limit of %s items', MUTATIONS_MAX_BATCH_SIZE);
      }
    }

    /** @internal */
  }, {
    key: "_doesMutationExceedBatchSizeLimit",
    value: function _doesMutationExceedBatchSizeLimit(mutation) {
      switch (mutation.type) {
        case _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES:
        case _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS:
          return mutation.records.length > MUTATIONS_MAX_BATCH_SIZE;
        case _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS:
          return mutation.recordIds.length > MUTATIONS_MAX_BATCH_SIZE;
        case _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
          return mutation.updates.length > MUTATIONS_MAX_BATCH_SIZE;
        // The "default" case cannot be reached because this method is only
        // invoked after the mutation type has been validated.
        // istanbul ignore next
        default:
          return false;
      }
    }

    /** @internal */
  }, {
    key: "_assertFieldIsValidForMutation",
    value: function _assertFieldIsValidForMutation(field) {
      if (field.isComputed) {
        throw (0, _error_utils.spawnError)("Can't set cell values: Field '%s' is computed and cannot be set", field.name);
      }
    }

    /** @internal */
  }, {
    key: "_assertFieldNameIsValidForMutation",
    value: function _assertFieldNameIsValidForMutation(name, table) {
      if (!name) {
        throw (0, _error_utils.spawnError)("Can't create or update field: must provide non-empty name");
      }
      if (name.length > _mutation_constants.MAX_FIELD_NAME_LENGTH) {
        throw (0, _error_utils.spawnError)("Can't create or update field: name '%s' exceeds maximum length of %s characters", name, _mutation_constants.MAX_FIELD_NAME_LENGTH);
      }

      // Verify the new name doesn't collide with any existing field name.
      var existingLowercaseFieldNames = table.fields.map(field => field.name.toLowerCase());
      if (existingLowercaseFieldNames.includes(name.toLowerCase())) {
        throw (0, _error_utils.spawnError)("Can't create or update field: field with name '%s' already exists", name);
      }
    }

    /** @internal */
  }, {
    key: "_assertMutationIsValid",
    value: function _assertMutationIsValid(mutation) {
      // We call validate the data (including any cell values) because if the data required for
      // us to do that is already loaded in the block, we can error out before applying
      // optimistic updates or sending the update to liveapp. That means that the error is
      // recoverable. Once we apply optimistic updates, if liveapp rejects the update then we
      // can't recover from that - we have to crash the block. We _could_ skip over these
      // validations - it wouldn't cause issues outside of the block frame. But running them
      // gives us slightly more confidence that we can do something other than completely crash
      // the block in the event of an invalid mutation.

      var appInterface = this._sdk.__appInterface;
      var billingPlanGrouping = this._base.__billingPlanGrouping;
      switch (mutation.type) {
        case _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES:
          {
            var tableId = mutation.tableId,
              records = mutation.records;
            var table = this._base.getTableByIdIfExists(tableId);
            if (!table) {
              throw (0, _error_utils.spawnError)("Can't set cell values: No table with id %s exists", tableId);
            }

            // For every mutation, we check that we're not trying to set fields that we don't support
            // mutations for yet. When record data is loaded, we also check that the record we're
            // updating actually exists and that the cell values are valid.
            var recordStore = this._base.__getRecordStore(tableId);
            var checkedFieldIds = new Set();
            var _iterator = _createForOfIteratorHelper(records),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var record = _step.value;
                var existingRecord = null;
                if (recordStore.isRecordMetadataLoaded) {
                  existingRecord = recordStore.getRecordByIdIfExists(record.id);
                  if (!existingRecord) {
                    throw (0, _error_utils.spawnError)("Can't set cell values: No record with id %s exists", record.id);
                  }
                }
                for (var _i = 0, _Object$keys = Object.keys(record.cellValuesByFieldId); _i < _Object$keys.length; _i++) {
                  var fieldId = _Object$keys[_i];
                  var field = table.getFieldByIdIfExists(fieldId);
                  if (!field) {
                    throw (0, _error_utils.spawnError)("Can't set cell values: No field with id %s exists in table '%s'", fieldId, table.name);
                  }
                  if (!checkedFieldIds.has(fieldId)) {
                    this._assertFieldIsValidForMutation(field);
                    checkedFieldIds.add(fieldId);
                  }
                  if (existingRecord && recordStore.areCellValuesLoadedForFieldId(fieldId)) {
                    var validationResult = this._airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, record.cellValuesByFieldId[fieldId], existingRecord._getRawCellValue(field), field._data);
                    if (!validationResult.isValid) {
                      throw (0, _error_utils.spawnError)("Can't set cell values: invalid cell value for field '%s'.\n%s", field.name, validationResult.reason);
                    }
                  }
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            return;
          }
        case _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS:
          {
            var _tableId = mutation.tableId,
              recordIds = mutation.recordIds;
            var _table = this._base.getTableByIdIfExists(_tableId);
            if (!_table) {
              throw (0, _error_utils.spawnError)("Can't delete records: No table with id %s exists", _tableId);
            }
            var _recordStore = this._base.__getRecordStore(_tableId);
            if (_recordStore.isRecordMetadataLoaded) {
              var _iterator2 = _createForOfIteratorHelper(recordIds),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var recordId = _step2.value;
                  var _record = _recordStore.getRecordByIdIfExists(recordId);
                  if (!_record) {
                    throw (0, _error_utils.spawnError)("Can't delete records: No record with id %s exists in table '%s'", recordId, _table.name);
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
            return;
          }
        case _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS:
          {
            var _tableId2 = mutation.tableId,
              _records = mutation.records;
            var _checkedFieldIds = new Set();
            var _table2 = this._base.getTableByIdIfExists(_tableId2);
            if (!_table2) {
              throw (0, _error_utils.spawnError)("Can't create records: No table with id %s exists", _tableId2);
            }
            var _iterator3 = _createForOfIteratorHelper(_records),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _record2 = _step3.value;
                for (var _i2 = 0, _Object$keys2 = Object.keys(_record2.cellValuesByFieldId); _i2 < _Object$keys2.length; _i2++) {
                  var _fieldId = _Object$keys2[_i2];
                  var _field = _table2.getFieldByIdIfExists(_fieldId);
                  if (!_field) {
                    throw (0, _error_utils.spawnError)("Can't create records: No field with id %s exists in table '%s'", _fieldId, _table2.name);
                  }
                  if (!_checkedFieldIds.has(_fieldId)) {
                    this._assertFieldIsValidForMutation(_field);
                    _checkedFieldIds.add(_fieldId);
                  }

                  // Current cell value is null since the record doesn't exist.
                  var _validationResult = this._airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, _record2.cellValuesByFieldId[_fieldId], null, _field._data);
                  if (!_validationResult.isValid) {
                    throw (0, _error_utils.spawnError)("Can't create records: invalid cell value for field '%s'.\n%s", _field.name, _validationResult.reason);
                  }
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            return;
          }
        case _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
          {
            // globalConfig update is a special case: globalConfig handles validation before
            // invoking this mutation, since it relies on internal state to validate the
            // paths being set.
            return;
          }
        case _mutations.MutationTypes.CREATE_SINGLE_FIELD:
          {
            var _tableId3 = mutation.tableId,
              name = mutation.name,
              config = mutation.config,
              description = mutation.description;
            var _table3 = this._base.getTableByIdIfExists(_tableId3);
            if (!_table3) {
              throw (0, _error_utils.spawnError)("Can't create field: No table with id %s exists", _tableId3);
            }
            if (_table3.fields.length >= _mutation_constants.MAX_NUM_FIELDS_PER_TABLE) {
              throw (0, _error_utils.spawnError)("Can't create field: table already has the maximum of %s fields", _mutation_constants.MAX_NUM_FIELDS_PER_TABLE);
            }
            this._assertFieldNameIsValidForMutation(name, _table3);

            // Current config / field data is null since the field doesn't exist.
            var _validationResult2 = this._airtableInterface.fieldTypeProvider.validateConfigForUpdate(appInterface, config, null, null, billingPlanGrouping);
            if (!_validationResult2.isValid) {
              throw (0, _error_utils.spawnError)("Can't create field: invalid field config.\n%s", _validationResult2.reason);
            }
            if (description && description.length > _mutation_constants.MAX_FIELD_DESCRIPTION_LENGTH) {
              throw (0, _error_utils.spawnError)("Can't create field: description exceeds maximum length of %s characters", _mutation_constants.MAX_FIELD_DESCRIPTION_LENGTH);
            }
            return;
          }
        case _mutations.MutationTypes.UPDATE_SINGLE_FIELD_CONFIG:
          {
            var _tableId4 = mutation.tableId,
              id = mutation.id,
              _config = mutation.config,
              opts = mutation.opts;
            var _table4 = this._base.getTableByIdIfExists(_tableId4);
            if (!_table4) {
              throw (0, _error_utils.spawnError)("Can't update field: No table with id %s exists", _tableId4);
            }
            var _field2 = _table4.getFieldByIdIfExists(id);
            if (!_field2) {
              throw (0, _error_utils.spawnError)("Can't update field: No field with id %s exists", id);
            }

            // we get the config directly instead of using field.type/field.options to get it
            // in one call and because field.options returns null instead of undefined when
            // a field does not have options, whilst we need to pass undefined
            var currentConfig = this._airtableInterface.fieldTypeProvider.getConfig(appInterface, _field2._data, _field2.parentTable.__getFieldNamesById());
            var _validationResult3 = this._airtableInterface.fieldTypeProvider.validateConfigForUpdate(appInterface, _config, currentConfig, _field2._data, billingPlanGrouping, opts);
            if (!_validationResult3.isValid) {
              throw (0, _error_utils.spawnError)("Can't update field: invalid field config.\n%s", _validationResult3.reason);
            }
            return;
          }
        case _mutations.MutationTypes.UPDATE_SINGLE_FIELD_DESCRIPTION:
          {
            var _tableId5 = mutation.tableId,
              _id = mutation.id,
              _description = mutation.description;
            var _table5 = this._base.getTableByIdIfExists(_tableId5);
            if (!_table5) {
              throw (0, _error_utils.spawnError)("Can't update field: No table with id %s exists", _tableId5);
            }
            var _field3 = _table5.getFieldByIdIfExists(_id);
            if (!_field3) {
              throw (0, _error_utils.spawnError)("Can't update field: No field with id %s exists", _id);
            }
            if (_description && _description.length > _mutation_constants.MAX_FIELD_DESCRIPTION_LENGTH) {
              throw (0, _error_utils.spawnError)("Can't update field: description exceeds maximum length of %s characters", _mutation_constants.MAX_FIELD_DESCRIPTION_LENGTH);
            }
            return;
          }
        case _mutations.MutationTypes.UPDATE_SINGLE_FIELD_NAME:
          {
            var _tableId6 = mutation.tableId,
              _id2 = mutation.id,
              _name = mutation.name;
            var _table6 = this._base.getTableByIdIfExists(_tableId6);
            if (!_table6) {
              throw (0, _error_utils.spawnError)("Can't update field: No table with id %s exists", _tableId6);
            }
            var _field4 = _table6.getFieldByIdIfExists(_id2);
            if (!_field4) {
              throw (0, _error_utils.spawnError)("Can't update field: No field with id %s exists", _id2);
            }

            // We skip name validation if it's the same name:
            // If it's exactly same name, this will result in no-op;
            // If it's only case change, we allow update and we know this name is already validated before;
            if (_field4.name.toLowerCase() !== _name.toLowerCase()) {
              this._assertFieldNameIsValidForMutation(_name, _table6);
            }
            return;
          }
        case _mutations.MutationTypes.CREATE_SINGLE_TABLE:
          {
            var _name2 = mutation.name,
              fields = mutation.fields;
            if (!_name2) {
              throw (0, _error_utils.spawnError)("Can't create table: must provide non-empty name");
            }
            if (_name2.length > _mutation_constants.MAX_TABLE_NAME_LENGTH) {
              throw (0, _error_utils.spawnError)("Can't create table: name '%s' exceeds maximum length of %s characters", _name2, _mutation_constants.MAX_TABLE_NAME_LENGTH);
            }
            var existingLowercaseTableNames = this._base.tables.map(table => table.name.toLowerCase());
            if (existingLowercaseTableNames.includes(_name2.toLowerCase())) {
              throw (0, _error_utils.spawnError)("Can't create table: table with name '%s' already exists", _name2);
            }
            if (fields.length === 0) {
              throw (0, _error_utils.spawnError)("Can't create table: must specify at least one field");
            }
            if (fields.length > _mutation_constants.MAX_NUM_FIELDS_PER_TABLE) {
              throw (0, _error_utils.spawnError)("Can't create table: number of fields exceeds maximum of %s", _mutation_constants.MAX_NUM_FIELDS_PER_TABLE);
            }
            var lowercaseFieldNames = new Set();
            var _iterator4 = _createForOfIteratorHelper(fields),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var _field5 = _step4.value;
                if (!_field5.name) {
                  throw (0, _error_utils.spawnError)("Can't create table: must provide non-empty name for every field");
                }
                if (_field5.name.length > _mutation_constants.MAX_FIELD_NAME_LENGTH) {
                  throw (0, _error_utils.spawnError)("Can't create table: field name '%s' exceeds maximum length of %s characters", _field5.name, _mutation_constants.MAX_FIELD_NAME_LENGTH);
                }
                var lowercaseFieldName = _field5.name.toLowerCase();
                if (lowercaseFieldNames.has(lowercaseFieldName)) {
                  throw (0, _error_utils.spawnError)("Can't create table: duplicate field name '%s'", _field5.name);
                }
                lowercaseFieldNames.add(lowercaseFieldName);

                // Current config / field data is null since the field doesn't exist.
                var _validationResult4 = this._airtableInterface.fieldTypeProvider.validateConfigForUpdate(appInterface, _field5.config, null, null, billingPlanGrouping);
                if (!_validationResult4.isValid) {
                  throw (0, _error_utils.spawnError)("Can't create table: invalid field config for field '%s'.\n%s", _field5.name, _validationResult4.reason);
                }
                if (_field5.description && _field5.description.length > _mutation_constants.MAX_FIELD_DESCRIPTION_LENGTH) {
                  throw (0, _error_utils.spawnError)("Can't create table: description for field '%s' exceeds maximum length of %s characters", _field5.name, _mutation_constants.MAX_FIELD_DESCRIPTION_LENGTH);
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            var primaryField = fields[0];
            if (!this._airtableInterface.fieldTypeProvider.canBePrimary(appInterface, primaryField.config, billingPlanGrouping)) {
              throw (0, _error_utils.spawnError)("Can't create table: first field '%s' has type '%s' which cannot be a primary field", primaryField.name, primaryField.config.type);
            }
            return;
          }
        case _mutations.MutationTypes.UPDATE_VIEW_METADATA:
          {
            var _tableId7 = mutation.tableId,
              viewId = mutation.viewId;
            var runContext = this._airtableInterface.sdkInitData.runContext;
            if (runContext.type !== _airtable_interface.BlockRunContextType.VIEW) {
              throw (0, _error_utils.spawnError)('Setting view metadata is only valid for views');
            }
            if (runContext.viewId !== viewId || runContext.tableId !== _tableId7) {
              throw (0, _error_utils.spawnError)('Custom views can only set view metadata on themselves');
            }
            var _table7 = this._base.getTableByIdIfExists(_tableId7);
            if (!_table7) {
              throw (0, _error_utils.spawnError)("Can't update metadata: No table with id %s exists", _tableId7);
            }
            var view = _table7.getViewByIdIfExists(viewId);
            if (!view) {
              throw (0, _error_utils.spawnError)("Can't update metadata: No view with id %s exists", viewId);
            }
            return;
          }
        default:
          throw (0, _error_utils.spawnUnknownSwitchCaseError)('mutation type', mutation, 'type');
      }
    }

    /** @internal */
  }, {
    key: "_applyOptimisticUpdatesForMutation",
    value: function _applyOptimisticUpdatesForMutation(mutation) {
      // GlobalConfig updates are different to other mutations (on models): for models, we
      // only apply optimistic updates if the relevant models are loaded, whereas for
      // SET_MULTIPLE_GLOBAL_CONFIG_PATHS we always apply optimistic updates.
      if (mutation.type === _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS) {
        this._applyGlobalConfigUpdates(mutation.updates);
        return true;
      }
      var modelChanges = this._getOptimisticModelChangesForMutation(mutation);
      if (modelChanges.length > 0) {
        this._applyModelChanges(modelChanges);
        return true;
      }
      return false;
    }

    /** @internal */
  }, {
    key: "_getOptimisticModelChangesForMutation",
    value: function _getOptimisticModelChangesForMutation(mutation) {
      switch (mutation.type) {
        case _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES:
          {
            var tableId = mutation.tableId,
              records = mutation.records;
            var recordStore = this._base.__getRecordStore(tableId);
            return records.flatMap(record => Object.keys(record.cellValuesByFieldId).filter(fieldId => recordStore.areCellValuesLoadedForFieldId(fieldId)).map(fieldId => ({
              path: ['tablesById', tableId, 'recordsById', record.id, 'cellValuesByFieldId', fieldId],
              value: record.cellValuesByFieldId[fieldId]
            })));
          }
        case _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS:
          {
            var _tableId8 = mutation.tableId,
              recordIds = mutation.recordIds;
            var _recordStore2 = this._base.__getRecordStore(_tableId8);
            if (!_recordStore2.isRecordMetadataLoaded) {
              return [];
            }
            return [...recordIds.map(recordId => ({
              path: ['tablesById', _tableId8, 'recordsById', recordId],
              value: undefined
            })), ...this._base.getTableById(_tableId8).views.flatMap(view => {
              var viewDataStore = _recordStore2.getViewDataStore(view.id);
              if (!viewDataStore.isDataLoaded) {
                return [];
              }
              return viewDataStore.__generateChangesForParentTableDeleteMultipleRecords(recordIds);
            })];
          }
        case _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS:
          {
            var _tableId9 = mutation.tableId,
              _records2 = mutation.records;
            var _recordStore3 = this._base.__getRecordStore(_tableId9);
            if (!_recordStore3.isRecordMetadataLoaded) {
              return [];
            }
            return [..._records2.map(record => {
              // Only apply optimistic changes for fields that are loaded
              var filteredCellValuesByFieldId = {};
              var _iterator5 = _createForOfIteratorHelper((0, _private_utils.entries)(record.cellValuesByFieldId)),
                _step5;
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  var _step5$value = (0, _slicedToArray2.default)(_step5.value, 2),
                    fieldId = _step5$value[0],
                    cellValue = _step5$value[1];
                  if (_recordStore3.areCellValuesLoadedForFieldId(fieldId)) {
                    filteredCellValuesByFieldId[fieldId] = cellValue;
                  }
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              return {
                path: ['tablesById', _tableId9, 'recordsById', record.id],
                value: {
                  id: record.id,
                  cellValuesByFieldId: filteredCellValuesByFieldId,
                  commentCount: 0,
                  createdTime: new Date().toJSON()
                }
              };
            }), ...this._base.getTableById(_tableId9).views.flatMap(view => {
              var viewDataStore = _recordStore3.getViewDataStore(view.id);
              if (!viewDataStore.isDataLoaded) {
                return [];
              }
              return viewDataStore.__generateChangesForParentTableAddMultipleRecords(_records2.map(record => record.id));
            })];
          }

        // The following branch is unreachable because this method's only
        // call site is preceded by an explicit guard for this condition.
        // istanbul ignore next
        case _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS:
          {
            throw (0, _error_utils.spawnError)('attempting to generate model updates for SET_MULTIPLE_GLOBAL_CONFIG_PATH');
          }
        case _mutations.MutationTypes.CREATE_SINGLE_FIELD:
        case _mutations.MutationTypes.UPDATE_SINGLE_FIELD_CONFIG:
        case _mutations.MutationTypes.UPDATE_SINGLE_FIELD_DESCRIPTION:
        case _mutations.MutationTypes.UPDATE_SINGLE_FIELD_NAME:
        case _mutations.MutationTypes.UPDATE_VIEW_METADATA:
        case _mutations.MutationTypes.CREATE_SINGLE_TABLE:
          {
            // No optimistic updates for field, view metadata, or table mutations.
            return [];
          }

        // The following branch is unreachable because this method's only
        // call site is preceded by an explicit guard for this condition.
        // istanbul ignore next
        default:
          throw (0, _error_utils.spawnUnknownSwitchCaseError)('mutation type', mutation, 'type');
      }
    }
  }]);
}();
var _default = exports.default = Mutations;