"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _private_utils = require("../private_utils");
var _error_utils = require("../error_utils");
var _abstract_model = _interopRequireDefault(require("./abstract_model"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks/models: Abstract models */ /** */
/**
 * Abstract superclass for all Blocks SDK models that need to fetch async data.
 *
 * @docsPath models/advanced/AbstractModelWithAsyncData
 */
var AbstractModelWithAsyncData = /*#__PURE__*/function (_AbstractModel) {
  /** @hidden */
  function AbstractModelWithAsyncData(sdk, modelId) {
    var _this;
    (0, _classCallCheck2.default)(this, AbstractModelWithAsyncData);
    _this = _callSuper(this, AbstractModelWithAsyncData, [sdk, modelId]);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_isDataLoaded", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_pendingDataLoadPromise", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_dataRetainCount", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_unloadDataTimeoutId", void 0);
    /**
     * This flag is used to keep track of models that have been
     * forced to unload (regardless of the retain count). The force
     * unload happens via _forceUnload method and the only proper use
     * of that function is when the underlying data gets deleted while
     * the model is still active. e.g. when a table is deleted in the
     * main extension while an instance of record_store is still alive.
     * NOTE: Once set to true, it never goes back to false.
     *
     * @internal
     */
    (0, _defineProperty2.default)(_this, "_isForceUnloaded", false);
    _this._isDataLoaded = false;
    _this._pendingDataLoadPromise = null;
    _this._dataRetainCount = 0;
    _this._unloadDataTimeoutId = null;
    return _this;
  }
  /**
   * Watching a key that needs to load data asynchronously will automatically
   * cause the data to be fetched. Once the data is available, the callback
   * will be called.
   *
   * @inheritdoc
   */
  (0, _inherits2.default)(AbstractModelWithAsyncData, _AbstractModel);
  return (0, _createClass2.default)(AbstractModelWithAsyncData, [{
    key: "watch",
    value: function watch(keys, callback, context) {
      this._assertNotForceUnloaded();
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(AbstractModelWithAsyncData.prototype), "watch", this).call(this, keys, callback, context);
      var _iterator = _createForOfIteratorHelper(validKeys),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          if (this.constructor._shouldLoadDataForKey(key)) {
            // Note: for simplicity, we will call loadData for every key that needs
            // needs data, relying on the retain count to unload once all keys have
            // been unwatched.
            (0, _private_utils.fireAndForgetPromise)(this.loadDataAsync.bind(this));
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return validKeys;
    }
    /**
     * Unwatching a key that needs to load data asynchronously will automatically
     * cause the data to be released. Once the data is available, the callback
     * will be called.
     *
     * @inheritdoc
     */
  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(AbstractModelWithAsyncData.prototype), "unwatch", this).call(this, keys, callback, context);
      var _iterator2 = _createForOfIteratorHelper(validKeys),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var key = _step2.value;
          if (this.constructor._shouldLoadDataForKey(key)) {
            // We called loadDataAsync for every key that needs data so call
            // unloadData for every key to balance the retain count.
            this.unloadData();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return validKeys;
    }
    /** @inheritdoc */
  }, {
    key: "isDeleted",
    get: function get() {
      if (this._isForceUnloaded) {
        return true;
      }
      return (0, _get2.default)((0, _getPrototypeOf2.default)(AbstractModelWithAsyncData.prototype), "isDeleted", this);
    }
    /** */
  }, {
    key: "isDataLoaded",
    get: function get() {
      if (this.isDeleted) {
        return false;
      }
      return this._isDataLoaded;
    }
    /** @internal */
  }, {
    key: "loadDataAsync",
    value: // Override this method if your model is dependent on other models.
    // Do NOT load other models' data from _loadDataAsync, since it can lead to
    // unexpected behavior.
    // IMPORTANT: always call super.loadDataAsync() from your override.
    /**
     * Will cause all the async data to be fetched and retained. Every call to
     * `loadDataAsync` should have a matching call to `unloadData`.
     *
     * Returns a Promise that will resolve once the data is loaded.
     */
    function () {
      var _loadDataAsync2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this._assertNotForceUnloaded();
              if (this._unloadDataTimeoutId !== null) {
                // If we set a timeout to unload data, clear it since we are incrementing
                // the retain count and loading data.
                clearTimeout(this._unloadDataTimeoutId);
                this._unloadDataTimeoutId = null;
              }

              // We keep a count of how many things have loaded the data so we don't
              // actually unload the data until the retain count comes back down to zero.
              this._dataRetainCount++;
              if (!this._isDataLoaded) {
                _context.next = 5;
                break;
              }
              return _context.abrupt("return");
            case 5:
              if (!this._pendingDataLoadPromise) {
                this._pendingDataLoadPromise = this._loadDataAsync().then(changedKeys => {
                  this._isDataLoaded = true;
                  this._pendingDataLoadPromise = null;
                  var _iterator3 = _createForOfIteratorHelper(changedKeys),
                    _step3;
                  try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                      var key = _step3.value;
                      this._onChange(key);
                    }
                  } catch (err) {
                    _iterator3.e(err);
                  } finally {
                    _iterator3.f();
                  }
                  this._onChangeIsDataLoaded();
                  return changedKeys;
                });
              }
              _context.next = 8;
              return this._pendingDataLoadPromise;
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function loadDataAsync() {
        return _loadDataAsync2.apply(this, arguments);
      }
      return loadDataAsync;
    }() // Override this method if your model is dependent on other models.
    // Do NOT unload other models' data from _unloadData, since it can lead to
    // unexpected behavior.
    // IMPORTANT: always call super.unloadData() from your override.
    /** */
  }, {
    key: "unloadData",
    value: function unloadData() {
      if (this._isForceUnloaded) {
        return;
      }
      this._dataRetainCount--;
      if (this._dataRetainCount < 0) {
        console.warn("Block ".concat(this.constructor._className, " data over-released")); // eslint-disable-line no-console
        this._dataRetainCount = 0;
      }
      if (this._dataRetainCount === 0) {
        // Don't unload immediately. Wait a while in case something else
        // requests the data, so we can avoid going back to liveapp or
        // the network.
        this._unloadDataTimeoutId = setTimeout(() => {
          (0, _error_utils.invariant)(this._dataRetainCount === 0, 'Unload data timeout fired with non-zero retain count');

          // Set _isDataLoaded to false before calling _unloadData in case
          // _unloadData reads from isDataLoaded.
          this._isDataLoaded = false;
          this._unloadData();
          this._onChangeIsDataLoaded();
        }, AbstractModelWithAsyncData.__DATA_UNLOAD_DELAY_MS);
      }
    }
  }, {
    key: "_forceUnload",
    value: function _forceUnload() {
      while (this._dataRetainCount > 0) {
        this.unloadData();
      }
      this._isForceUnloaded = true;
    }
  }, {
    key: "_assertNotForceUnloaded",
    value: function _assertNotForceUnloaded() {
      (0, _error_utils.invariant)(!this._isForceUnloaded, 'model (%s) permanently deleted', this.id);
    }
  }], [{
    key: "_shouldLoadDataForKey",
    value: /** @internal */
    function _shouldLoadDataForKey(key) {
      // Override to return whether watching the key should trigger the
      // data to be loaded for this model.
      return false;
    }
  }]);
}(_abstract_model.default);
/** @internal */
(0, _defineProperty2.default)(AbstractModelWithAsyncData, "__DATA_UNLOAD_DELAY_MS", 1000);
var _default = exports.default = AbstractModelWithAsyncData;