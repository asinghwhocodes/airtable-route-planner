"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.string.includes.js");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _error_utils = require("../error_utils");
var _private_utils = require("../private_utils");
var _mutations = require("../types/mutations");
var _abstract_model = _interopRequireDefault(require("./abstract_model"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks/models: Session */ /** */
/** @hidden */

var WatchableSessionKeys = Object.freeze({
  permissionLevel: 'permissionLevel',
  // NOTE: the current user's identity will never change, but their name/email/profile pic/etc. can.
  currentUser: 'currentUser'
});

/**
 * Watchable keys in {@link Session}.
 * - `currentUser`
 * - `permissionLevel`
 */
/**
 * Model class representing the current user's session.
 *
 * @example
 * ```js
 * import {useSession} from '@airtable/blocks/ui';
 *
 * function Username() {
 *     const session = useSession();
 *
 *     if (session.currentUser !== null) {
 *         return <span>The current user's name is {session.currentUser.name}</span>;
 *     } else {
 *         return <span>This extension is being viewed in a public share</span>;
 *     }
 * }
 * ```
 * @docsPath models/Session
 */
var Session = /*#__PURE__*/function (_AbstractModel) {
  /**
   * @internal
   */
  function Session(sdk) {
    var _this;
    (0, _classCallCheck2.default)(this, Session);
    _this = _callSuper(this, Session, [sdk, 'session']);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_airtableInterface", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_sessionData", void 0);
    _this._airtableInterface = sdk.__airtableInterface;
    var _this$_airtableInterf = _this._airtableInterface.sdkInitData.baseData,
      permissionLevel = _this$_airtableInterf.permissionLevel,
      currentUserId = _this$_airtableInterf.currentUserId,
      enabledFeatureNames = _this$_airtableInterf.enabledFeatureNames;
    _this._sessionData = {
      permissionLevel,
      currentUserId,
      enabledFeatureNames
    };
    Object.seal(_this);
    return _this;
  }

  /**
   * @internal
   */
  (0, _inherits2.default)(Session, _AbstractModel);
  return (0, _createClass2.default)(Session, [{
    key: "_dataOrNullIfDeleted",
    get: function get() {
      return this._sessionData;
    }

    /**
     * The current user, or `null` if the extension is running in a publicly shared base.
     *
     * @example
     * ```js
     * import {useSession} from '@airtable/blocks/ui';
     *
     * function CurrentUser() {
     *     const session = useSession();
     *
     *     if (!session.currentUser) {
     *         return <div>This extension is being used in a public share.</div>;
     *     }
     *
     *     return <ul>
     *         <li>ID: {session.currentUser.id}</li>
     *         <li>E-mail: {session.currentUser.email}</li>
     *         <li>Name: {session.currentUser.name}</li>
     *     </ul>;
     * }
     * ```
     */
  }, {
    key: "currentUser",
    get: function get() {
      var userId = this._sessionData.currentUserId;
      if (!userId) {
        return null;
      } else {
        var base = this._sdk.base;
        return base.getCollaboratorByIdIfExists(userId);
      }
    }
    /**
     * Checks whether the current user has permission to update any records in the current base. For
     * more granular permission checks, see {@link Table.checkPermissionsForUpdateRecords}.
     *
     * Returns `{hasPermission: true}` if the current user can update records,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may
     * be used to display an error message to the user.
     *
     * @example
     * ```js
     * import {useSession} from '@airtable/blocks/ui';
     *
     * function UpdateButton({onClick}) {
     *     const session = useSession();
     *     const updateRecordsCheckResult = session.checkPermissionsForUpdateRecords();
     *     const deniedReason = updateRecordsCheckResult.hasPermission
     *         ? <span>{updateRecordsCheckResult.reasonDisplayString}</span>
     *         : null;
     *
     *     return <div>
     *         {deniedReason}
     *         <button onClick={onClick} disabled={!!deniedReason}>
     *             Update
     *         </button>
     *     </div>;
     * }
     */
  }, {
    key: "checkPermissionsForUpdateRecords",
    value: function checkPermissionsForUpdateRecords() {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES,
        tableId: undefined,
        records: undefined
      });
    }
    /**
     * An alias for `session.checkPermissionsForUpdateRecords().hasPermission`. For more granular
     * permission checks, see {@link Table.hasPermissionToUpdateRecords}.
     */
  }, {
    key: "hasPermissionToUpdateRecords",
    value: function hasPermissionToUpdateRecords() {
      return this.checkPermissionsForUpdateRecords().hasPermission;
    }
    /**
     * Checks whether the current user has permission to create any records in the current base. For
     * more granular permission checks, see {@link Table.checkPermissionsForCreateRecords}.
     *
     * Returns `{hasPermission: true}` if the current user can create records,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @example
     * ```js
     * import {useSession} from '@airtable/blocks/ui';
     *
     * function CreateButton({onClick}) {
     *     const session = useSession();
     *     const updateRecordsCheckResult = session.checkPermissionsForCreateRecords();
     *     const deniedReason = updateRecordsCheckResult.hasPermission
     *         ? <span>{updateRecordsCheckResult.reasonDisplayString}</span>
     *         : null;
     *
     *     return <div>
     *         {deniedReason}
     *         <button onClick={onClick} disabled={!!deniedReason}>
     *             Create
     *         </button>
     *     </div>;
     * }
     */
  }, {
    key: "checkPermissionsForCreateRecords",
    value: function checkPermissionsForCreateRecords() {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS,
        tableId: undefined,
        records: undefined
      });
    }
    /**
     * An alias for `session.checkPermissionsForCreateRecords().hasPermission`. For more granular
     * permission checks, see {@link Table.hasPermissionToCreateRecords}.
     */
  }, {
    key: "hasPermissionToCreateRecords",
    value: function hasPermissionToCreateRecords() {
      return this.checkPermissionsForCreateRecords().hasPermission;
    }
    /**
     * Checks whether the current user has permission to delete any records in the current base. For
     * more granular permission checks, see {@link Table.checkPermissionsForDeleteRecords}.
     *
     * Returns `{hasPermission: true}` if the current user can delete records,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @example
     * ```js
     * import {useSession} from '@airtable/blocks/ui';
     *
     * function DeleteButton({onClick}) {
     *     const session = useSession();
     *     const updateRecordsCheckResult = session.checkPermissionsForDeleteRecords();
     *     const deniedReason = updateRecordsCheckResult.hasPermission
     *         ? <span>{updateRecordsCheckResult.reasonDisplayString}</span>
     *         : null;
     *
     *     return <div>
     *         {deniedReason}
     *         <button onClick={onClick} disabled={!!deniedReason}>
     *             Delete
     *         </button>
     *     </div>;
     */
  }, {
    key: "checkPermissionsForDeleteRecords",
    value: function checkPermissionsForDeleteRecords() {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS,
        tableId: undefined,
        recordIds: undefined
      });
    }
    /**
     * An alias for `session.checkPermissionsForDeleteRecords().hasPermission`. For more granular
     * permission checks, see {@link Table.hasPermissionToDeleteRecords}.
     */
  }, {
    key: "hasPermissionToDeleteRecords",
    value: function hasPermissionToDeleteRecords() {
      return this.checkPermissionsForDeleteRecords().hasPermission;
    }
    /**
     * Returns true if `featureName` is enabled and automatically tracks an exposure.
     *
     * @internal
     */
  }, {
    key: "__isFeatureEnabled",
    value: function __isFeatureEnabled(featureName) {
      this._airtableInterface.trackExposure(featureName);
      return this.__peekIfFeatureIsEnabled(featureName);
    }

    /**
     * Returns true if `featureName` is enabled; does not track an exposure.
     *
     * @internal
     */
  }, {
    key: "__peekIfFeatureIsEnabled",
    value: function __peekIfFeatureIsEnabled(featureName) {
      return this._sessionData.enabledFeatureNames.includes(featureName);
    }

    /**
     * @internal
     */
  }, {
    key: "__applyChangesWithoutTriggeringEvents",
    value: function __applyChangesWithoutTriggeringEvents(changes) {
      var changedKeys = {
        [WatchableSessionKeys.permissionLevel]: false,
        [WatchableSessionKeys.currentUser]: false
      };
      var _iterator = _createForOfIteratorHelper(changes),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
            path = _step$value.path,
            value = _step$value.value;
          if (path[0] === 'permissionLevel') {
            (0, _error_utils.invariant)(path.length === 1, 'cannot set within permissionLevel');

            // NOTE: just verify that the permission level is a string (rather than
            // checking isEnumValue against PermissionLevels) in case new permission
            // levels are added on the liveapp side. Permissions behavior gets routed
            // through the checkPermissionsForMutation AirtableInterface helper, so we
            // should still be able to handle unknown permission levels.
            (0, _error_utils.invariant)(typeof value === 'string', 'permissionLevel must be a string');
            this._sessionData.permissionLevel = value;
            changedKeys[WatchableSessionKeys.permissionLevel] = true;
          }

          // TODO(emma): fire change only when the current user's info changes
          if (path[0] === 'collaboratorsById') {
            changedKeys[WatchableSessionKeys.currentUser] = true;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return changedKeys;
    }
    /**
     * @internal
     */
  }, {
    key: "__triggerOnChangeForChangedKeys",
    value: function __triggerOnChangeForChangedKeys(changedKeys) {
      var _iterator2 = _createForOfIteratorHelper((0, _private_utils.entries)(changedKeys)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
            key = _step2$value[0],
            didChange = _step2$value[1];
          if (didChange) {
            this._onChange(key);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }], [{
    key: "_isWatchableKey",
    value: /** @internal */
    function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableSessionKeys, key);
    }
  }]);
}(_abstract_model.default);
/** @internal */
(0, _defineProperty2.default)(Session, "_className", 'Session');
var _default = exports.default = Session;