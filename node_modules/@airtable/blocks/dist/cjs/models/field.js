"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.set.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _mutations = require("../types/mutations");
var _field = require("../types/field");
var _private_utils = require("../private_utils");
var _abstract_model = _interopRequireDefault(require("./abstract_model"));
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks/models: Field */ /** */
// This doesn't follow our enum naming conventions because we want the keys
// to mirror the method/getter names on the model class.
var WatchableFieldKeys = Object.freeze({
  name: 'name',
  type: 'type',
  options: 'options',
  isComputed: 'isComputed',
  description: 'description',
  isFieldSynced: 'isFieldSynced'
});

/**
 * All the watchable keys in a field.
 * - `name`
 * - `type`
 * - `options`
 * - `isComputed`
 * - `description`
 */
/**
 * Model class representing a field in a table.
 *
 * @example
 * ```js
 * import {base} from '@airtable/blocks';
 *
 * const table = base.getTableByName('Table 1');
 * const field = table.getFieldByName('Name');
 * console.log('The type of this field is', field.type);
 * ```
 * @docsPath models/Field
 */
var Field = /*#__PURE__*/function (_AbstractModel) {
  /**
   * @internal
   */
  function Field(sdk, parentTable, fieldId) {
    var _this;
    (0, _classCallCheck2.default)(this, Field);
    _this = _callSuper(this, Field, [sdk, fieldId]);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_parentTable", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_cachedFieldTypeConfigOrNull", void 0);
    _this._parentTable = parentTable;
    _this._cachedFieldTypeConfigOrNull = null;
    return _this;
  }

  /**
   * @internal
   */
  (0, _inherits2.default)(Field, _AbstractModel);
  return (0, _createClass2.default)(Field, [{
    key: "_dataOrNullIfDeleted",
    get: function get() {
      var _tableData$fieldsById;
      var tableData = this._baseData.tablesById[this.parentTable.id];
      return (_tableData$fieldsById = tableData === null || tableData === void 0 ? void 0 : tableData.fieldsById[this._id]) !== null && _tableData$fieldsById !== void 0 ? _tableData$fieldsById : null;
    }
    /**
     * The table that this field belongs to. Should never change because fields aren't moved between tables.
     *
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * @example
     * ```js
     * const field = myTable.getFieldByName('Name');
     * console.log(field.parentTable.id === myTable.id);
     * // => true
     * ```
     */
  }, {
    key: "parentTable",
    get: function get() {
      return this._parentTable;
    }
    /**
     * The name of the field. Can be watched.
     *
     * @example
     * ```js
     * console.log(myField.name);
     * // => 'Name'
     * ```
     */
  }, {
    key: "name",
    get: function get() {
      return this._data.name;
    }
    /**
     * The type of the field. Can be watched.
     *
     * @example
     * ```js
     * console.log(myField.type);
     * // => 'singleLineText'
     * ```
     */
  }, {
    key: "type",
    get: function get() {
      var _this$_getCachedConfi = this._getCachedConfigFromFieldTypeProvider(),
        type = _this$_getCachedConfi.type;
      // We intend to switch from "lookup" to "multipleLookupValues", but need to support both
      // until the transition is complete. See <https://airtable.quip.com/VxaMAmAfUscs> for more.
      // @ts-ignore
      if (type === 'lookup') {
        return _field.FieldType.MULTIPLE_LOOKUP_VALUES;
      } else {
        return type;
      }
    }
    /**
     * The configuration options of the field. The structure of the field's
     * options depend on the field's type. `null` if the field has no options.
     * Can be watched.
     *
     * @see {@link FieldType}
     * @example
     * ```js
     * import {FieldType} from '@airtable/blocks/models';
     *
     * if (myField.type === FieldType.CURRENCY) {
     *     console.log(myField.options.symbol);
     *     // => '$'
     * }
     * ```
     */
  }, {
    key: "options",
    get: function get() {
      var _this$_getCachedConfi2 = this._getCachedConfigFromFieldTypeProvider(),
        options = _this$_getCachedConfi2.options;

      // TODO: In the next breaking release freeze (inside of the cache) and replace
      // FieldOptions with readonly<FieldOptions>.
      // Today this is required because we re-use the fieldTypeProvider.getConfig response.
      return options ? (0, _private_utils.cloneDeep)(options) : null;
    }

    // We use a cached response from FieldTypeProvider because getting the config can
    // be an expensive operation. In particular when fieldConfigs are extremely large
    // (eg: Select fields with lots of select options)
  }, {
    key: "_getCachedConfigFromFieldTypeProvider",
    value: function _getCachedConfigFromFieldTypeProvider() {
      if (this._cachedFieldTypeConfigOrNull !== null) {
        return this._cachedFieldTypeConfigOrNull;
      }
      var airtableInterface = this._sdk.__airtableInterface;
      var appInterface = this._sdk.__appInterface;
      this._cachedFieldTypeConfigOrNull = airtableInterface.fieldTypeProvider.getConfig(appInterface, this._data, this.parentTable.__getFieldNamesById());
      return this._cachedFieldTypeConfigOrNull;
    }
  }, {
    key: "_clearCachedConfig",
    value: function _clearCachedConfig() {
      this._cachedFieldTypeConfigOrNull = null;
    }

    /**
     * The type and options of the field to make type narrowing `FieldOptions` easier.
     *
     * @see {@link FieldConfig}
     * @example
     * const fieldConfig = field.config;
     * if (fieldConfig.type === FieldType.SINGLE_SELECT) {
     *     return fieldConfig.options.choices;
     * } else if (fieldConfig.type === FieldType.MULTIPLE_LOOKUP_VALUES && fieldConfig.options.isValid) {
     *     if (fieldConfig.options.result.type === FieldType.SINGLE_SELECT) {
     *         return fieldConfig.options.result.options.choices;
     *     }
     * }
     * return DEFAULT_CHOICES;
     */
  }, {
    key: "config",
    get: function get() {
      return {
        type: this.type,
        options: this.options
      };
    }
    /**
     * Checks whether the current user has permission to perform the given options update.
     *
     * Accepts partial input, in the same format as {@link updateOptionsAsync}.
     *
     * Returns `{hasPermission: true}` if the current user can update the specified field,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param options new options for the field
     *
     * @example
     * ```js
     * const updateFieldCheckResult = field.checkPermissionsForUpdateOptions();
     *
     * if (!updateFieldCheckResult.hasPermission) {
     *     alert(updateFieldCheckResult.reasonDisplayString);
     * }
     * ```
     */
  }, {
    key: "checkPermissionsForUpdateOptions",
    value: function checkPermissionsForUpdateOptions(options) {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.UPDATE_SINGLE_FIELD_CONFIG,
        tableId: this.parentTable.id,
        id: this.id,
        config: {
          type: this.type,
          options: options
        }
      });
    }

    /**
     * An alias for `checkPermissionsForUpdateOptions(options).hasPermission`.
     *
     * Checks whether the current user has permission to perform the options update.
     *
     * Accepts partial input, in the same format as {@link updateOptionsAsync}.
     *
     * @param options new options for the field
     *
     * @example
     * ```js
     * const canUpdateField = field.hasPermissionToUpdateOptions();
     *
     * if (!canUpdateField) {
     *     alert('not allowed!');
     * }
     * ```
     */
  }, {
    key: "hasPermissionToUpdateOptions",
    value: function hasPermissionToUpdateOptions(options) {
      return this.checkPermissionsForUpdateOptions(options).hasPermission;
    }

    /**
     * Updates the options for this field.
     *
     * Throws an error if the user does not have permission to update the field, if invalid
     * options are provided, if this field has no writable options, or if updates to this field
     * type is not supported.
     *
     * Refer to {@link FieldType} for supported field types, the write format for options, and
     * other specifics for certain field types.
     *
     * This action is asynchronous. Unlike updates to cell values, updates to field options are
     * **not** applied optimistically locally. You must `await` the returned promise before
     * relying on the change in your extension.
     *
     * Optionally, you can pass an `opts` object as the second argument. See {@link UpdateFieldOptionsOpts}
     * for available options.
     *
     * @param options new options for the field
     * @param opts optional options to affect the behavior of the update
     *
     * @example
     * ```js
     * async function addChoiceToSelectField(selectField, nameForNewOption) {
     *     const updatedOptions = {
     *         choices: [
     *             ...selectField.options.choices,
     *             {name: nameForNewOption},
     *         ]
     *     };
     *
     *     if (selectField.hasPermissionToUpdateOptions(updatedOptions)) {
     *         await selectField.updateOptionsAsync(updatedOptions);
     *     }
     * }
     * ```
     */
  }, {
    key: "updateOptionsAsync",
    value: (function () {
      var _updateOptionsAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(options) {
        var opts,
          _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.next = 3;
              return this._sdk.__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.UPDATE_SINGLE_FIELD_CONFIG,
                tableId: this.parentTable.id,
                id: this.id,
                config: {
                  type: this.type,
                  options: options
                },
                opts
              });
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function updateOptionsAsync(_x) {
        return _updateOptionsAsync.apply(this, arguments);
      }
      return updateOptionsAsync;
    }()
    /**
     * Checks whether the current user has permission to perform the given name update.
     *
     * Accepts partial input, in the same format as {@link updateNameAsync}.
     *
     * Returns `{hasPermission: true}` if the current user can update the specified field,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param name new name for the field
     *
     * @example
     * ```js
     * const updateFieldCheckResult = field.checkPermissionsForUpdateName();
     *
     * if (!updateFieldCheckResult.hasPermission) {
     *     alert(updateFieldCheckResult.reasonDisplayString);
     * }
     * ```
     */
    )
  }, {
    key: "checkPermissionsForUpdateName",
    value: function checkPermissionsForUpdateName(name) {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.UPDATE_SINGLE_FIELD_NAME,
        tableId: this.parentTable.id,
        id: this.id,
        name
      });
    }

    /**
     * An alias for `checkPermissionsForUpdateName(options).hasPermission`.
     *
     * Checks whether the current user has permission to perform the name update.
     *
     * Accepts partial input, in the same format as {@link updateNameAsync}.
     *
     * @param name new name for the field
     *
     * @example
     * ```js
     * const canUpdateField = field.hasPermissionToUpdateName();
     *
     * if (!canUpdateField) {
     *     alert('not allowed!');
     * }
     * ```
     */
  }, {
    key: "hasPermissionToUpdateName",
    value: function hasPermissionToUpdateName(name) {
      return this.checkPermissionsForUpdateName(name).hasPermission;
    }

    /**
     * Updates the name for this field.
     *
     * Throws an error if the user does not have permission to update the field, or if an invalid
     * name is provided.
     *
     * This action is asynchronous. Unlike updates to cell values, updates to field name are
     * **not** applied optimistically locally. You must `await` the returned promise before
     * relying on the change in your extension.
     *
     * @param name new name for the field
     *
     * @example
     * ```js
     * await myTextField.updateNameAsync('My New Name');
     * ```
     */
  }, {
    key: "updateNameAsync",
    value: (function () {
      var _updateNameAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(name) {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this._sdk.__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.UPDATE_SINGLE_FIELD_NAME,
                tableId: this.parentTable.id,
                id: this.id,
                name
              });
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function updateNameAsync(_x2) {
        return _updateNameAsync.apply(this, arguments);
      }
      return updateNameAsync;
    }()
    /**
     * Checks whether the current user has permission to perform the given description update.
     *
     * Accepts partial input, in the same format as {@link updateDescriptionAsync}.
     *
     * Returns `{hasPermission: true}` if the current user can update the specified field,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param description new description for the field
     *
     * @example
     * ```js
     * const updateFieldCheckResult = field.checkPermissionsForUpdateDescription();
     *
     * if (!updateFieldCheckResult.hasPermission) {
     *     alert(updateFieldCheckResult.reasonDisplayString);
     * }
     * ```
     */
    )
  }, {
    key: "checkPermissionsForUpdateDescription",
    value: function checkPermissionsForUpdateDescription(description) {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.UPDATE_SINGLE_FIELD_DESCRIPTION,
        tableId: this.parentTable.id,
        id: this.id,
        description
      });
    }

    /**
     * An alias for `checkPermissionsForUpdateDescription(options).hasPermission`.
     *
     * Checks whether the current user has permission to perform the description update.
     *
     * Accepts partial input, in the same format as {@link updateDescriptionAsync}.
     *
     * @param description new description for the field
     *
     * @example
     * ```js
     * const canUpdateField = field.hasPermissionToUpdateDescription();
     *
     * if (!canUpdateField) {
     *     alert('not allowed!');
     * }
     * ```
     */
  }, {
    key: "hasPermissionToUpdateDescription",
    value: function hasPermissionToUpdateDescription(description) {
      return this.checkPermissionsForUpdateDescription(description).hasPermission;
    }

    /**
     * Updates the description for this field.
     *
     * To remove an existing description, pass `''` as the new description.
     * `null` is also accepted and will be coerced to `''` for consistency with field creation.
     *
     * Throws an error if the user does not have permission to update the field, or if an invalid
     * description is provided.
     *
     * This action is asynchronous. Unlike updates to cell values, updates to field descriptions are
     * **not** applied optimistically locally. You must `await` the returned promise before
     * relying on the change in your extension.
     *
     * @param description new description for the field
     *
     * @example
     * ```js
     * await myTextField.updateDescriptionAsync('This is a text field');
     * ```
     */
  }, {
    key: "updateDescriptionAsync",
    value: (function () {
      var _updateDescriptionAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(description) {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this._sdk.__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.UPDATE_SINGLE_FIELD_DESCRIPTION,
                tableId: this.parentTable.id,
                id: this.id,
                description
              });
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateDescriptionAsync(_x3) {
        return _updateDescriptionAsync.apply(this, arguments);
      }
      return updateDescriptionAsync;
    }()
    /**
     * `true` if this field is synced, `false` otherwise. A field is
     * "synced" if it's source is from another airtable base or external data source
     * like Google Calendar, Jira, etc..
     *
     * @hidden
     */
    )
  }, {
    key: "isFieldSynced",
    get: function get() {
      var _this$_data$isSynced;
      return (_this$_data$isSynced = this._data.isSynced) !== null && _this$_data$isSynced !== void 0 ? _this$_data$isSynced : false;
    }

    /**
     * `true` if this field is computed, `false` otherwise. A field is
     * "computed" if it's value is not set by user input (e.g. autoNumber, formula,
     * etc.). Can be watched
     *
     * @example
     * ```js
     * console.log(mySingleLineTextField.isComputed);
     * // => false
     * console.log(myAutoNumberField.isComputed);
     * // => true
     * ```
     */
  }, {
    key: "isComputed",
    get: function get() {
      var airtableInterface = this._sdk.__airtableInterface;
      return airtableInterface.fieldTypeProvider.isComputed(this._data);
    }
    /**
     * `true` if this field is its parent table's primary field, `false` otherwise.
     * Should never change because the primary field of a table cannot change.
     */
  }, {
    key: "isPrimaryField",
    get: function get() {
      return this.id === this.parentTable.primaryField.id;
    }

    /**
     * The description of the field, if it has one. Can be watched.
     *
     * @example
     * ```js
     * console.log(myField.description);
     * // => 'This is my field'
     * ```
     */
  }, {
    key: "description",
    get: function get() {
      return this._data.description;
    }
    // The following method is untested because its implementation resists
    // testing and because it is expected to be redesigned.
    // istanbul ignore next
    /**
     * A list of available aggregators given this field's configuration.
     *
     * @example
     * ```js
     * const fieldAggregators = myField.availableAggregators;
     * ```
     */
  }, {
    key: "availableAggregators",
    get: function get() {
      var airtableInterface = this._sdk.__airtableInterface;
      var availableAggregatorKeysSet = new Set(airtableInterface.aggregators.getAvailableAggregatorKeysForField(this._data));
      var _require = require('./models'),
        aggregators = _require.aggregators;
      return (0, _private_utils.values)(aggregators).filter(aggregator => {
        return availableAggregatorKeysSet.has(aggregator.key);
      });
    }
    // The following method is untested because its implementation resists
    // testing and because it is expected to be redesigned.
    // istanbul ignore next
    /**
     * Checks if the given aggregator is available for this field.
     *
     * @param aggregator The aggregator object or aggregator key.
     * @example
     * ```js
     * import {aggregators} from '@airtable/blocks/models';
     * const aggregator = aggregators.totalAttachmentSize;
     *
     * // Using an aggregator object
     * console.log(myAttachmentField.isAggregatorAvailable(aggregator));
     * // => true
     *
     * // Using an aggregator key
     * console.log(myTextField.isAggregatorAvailable('totalAttachmentSize'));
     * // => false
     * ```
     */
  }, {
    key: "isAggregatorAvailable",
    value: function isAggregatorAvailable(aggregator) {
      var aggregatorKey = typeof aggregator === 'string' ? aggregator : aggregator.key;
      var airtableInterface = this._sdk.__airtableInterface;
      var availableAggregatorKeys = airtableInterface.aggregators.getAvailableAggregatorKeysForField(this._data);
      return availableAggregatorKeys.some(key => key === aggregatorKey);
    }
    /**
     * Attempt to parse a given string and return a valid cell value for the field's current config.
     * Returns `null` if unable to parse the given string.
     *
     * @param string The string to parse.
     * @example
     * ```js
     * const inputString = '42';
     * const cellValue = myNumberField.convertStringToCellValue(inputString);
     * console.log(cellValue === 42);
     * // => true
     * ```
     */
  }, {
    key: "convertStringToCellValue",
    value: function convertStringToCellValue(string) {
      var airtableInterface = this._sdk.__airtableInterface;
      var appInterface = this._sdk.__appInterface;
      var cellValue = airtableInterface.fieldTypeProvider.convertStringToCellValue(appInterface, string, this._data,
      // The opt parseDateCellValueInColumnTimeZone is used here to ensure date string
      // inputs are interpreted correctly according to the `timeZone` of the dateTime field.
      {
        parseDateCellValueInColumnTimeZone: this.type === _field.FieldType.DATE_TIME
      });

      // Temporarily bail out of validating computed values (since validation will crash)
      // while we work out if we actually have to validate or not. Ideally we just delete all
      // the validation
      // TODO(emma): delete me or tidy me up
      if (this.isComputed) {
        return cellValue;
      }

      // TODO(emma): do we need to validate here?
      var validationResult = airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, cellValue, null, this._data);
      if (validationResult.isValid) {
        return cellValue;
      } else {
        return null;
      }
    }
    /**
     * @internal
     */
  }, {
    key: "__triggerOnChangeForDirtyPaths",
    value: function __triggerOnChangeForDirtyPaths(dirtyPaths) {
      // Always clear the cached config when anything on the field data model changes
      this._clearCachedConfig();
      if (dirtyPaths.name) {
        this._onChange(WatchableFieldKeys.name);
      }
      if (dirtyPaths.type) {
        this._onChange(WatchableFieldKeys.type);

        // TODO: it would be better if we only trigger this when
        // we know isComputed changed.
        this._onChange(WatchableFieldKeys.isComputed);
      }
      if (dirtyPaths.typeOptions) {
        this._onChange(WatchableFieldKeys.options);
      }
      if (dirtyPaths.description) {
        this._onChange(WatchableFieldKeys.description);
      }
      if (dirtyPaths.isSynced) {
        this._onChange(WatchableFieldKeys.isFieldSynced);
      }
    }
  }], [{
    key: "_isWatchableKey",
    value: /** @internal */
    function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableFieldKeys, key);
    }
  }]);
}(_abstract_model.default);
/** @internal */
(0, _defineProperty2.default)(Field, "_className", 'Field');
var _default = exports.default = Field;