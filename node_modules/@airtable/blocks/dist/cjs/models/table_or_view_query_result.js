"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.get-own-property-descriptors.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/es.weak-map.js");
require("core-js/modules/web.dom-collections.for-each.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _private_utils = require("../private_utils");
var _error_utils = require("../error_utils");
var _table = _interopRequireWildcard(require("./table"));
var _record_query_result = _interopRequireDefault(require("./record_query_result"));
var _record_coloring = require("./record_coloring");
var _object_pool = _interopRequireDefault(require("./object_pool"));
var _record_store = require("./record_store");
var _view_data_store = _interopRequireWildcard(require("./view_data_store"));
var _grouped_record_query_result = _interopRequireDefault(require("./grouped_record_query_result"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks/models: RecordQueryResult */ /** */
/** @hidden */
/**
 * Represents a set of records directly from a view or table. See {@link RecordQueryResult} for main
 * documentation.
 *
 * Do not instantiate. You can get instances of this class by calling
 * `table.selectRecords` or `view.selectRecords`.
 *
 * @docsPath models/query results/TableOrViewQueryResult
 */
var TableOrViewQueryResult = /*#__PURE__*/function (_RecordQueryResult) {
  /** @internal */
  function TableOrViewQueryResult(sdk, sourceModel, normalizedOpts) {
    var _this;
    (0, _classCallCheck2.default)(this, TableOrViewQueryResult);
    _this = _callSuper(this, TableOrViewQueryResult, [sdk, normalizedOpts]);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_sourceModel", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_mostRecentSourceModelLoadPromise", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_table", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_fieldIdsSetToLoadOrNullIfAllFields", void 0);
    // If custom sorts or groups are specified, we'll use a VisList to handle sorting.
    // If no sorts are specified, we'll use the underlying row order of the source model.
    // Note: we're currently handling visibility tracking for view query results within this class,
    // not in the VisList. In other words, only visible records are added to the visList.
    /** @internal */
    (0, _defineProperty2.default)(_this, "_visList", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_sorts", void 0);
    // These is the groupLevels provided to us by the user when executing a query
    /** @internal */
    (0, _defineProperty2.default)(_this, "_groupLevels", void 0);
    // This is the ordered list of record ids.
    /** @internal */
    (0, _defineProperty2.default)(_this, "_orderedRecordIds", void 0);
    // This is the ordered list of groups.
    /** @internal */
    (0, _defineProperty2.default)(_this, "_orderedGroups", void 0);
    // An ordered list of group levels returned to us from hyperbase, this should not be
    // read from directly, but instead via this.data.groupLevels (Writing to this on hyperbase updates).
    // (which check's that this model has not been not deleted)
    /** @internal */
    (0, _defineProperty2.default)(_this, "_loadedGroupLevels", void 0);
    // lazily generated set of record ids
    /** @internal */
    (0, _defineProperty2.default)(_this, "_recordIdsSet", null);
    // NOTE: when a cellValue key (cellValues or cellValuesInField:) is watched, we want
    // to make sure we watch the associated key on the table. However, we need to make
    // sure that we only watch the table once for each key. Otherwise, the callbacks
    // for each key will get called more than once for each change event. This is because
    // Watchable stores references to callbacks for each key, and on each _onChange event
    // calls each callback for that key. If we watch the table more than once, then we'll
    // call _onChange more than once, and each callback will be called more than once, which
    // is undesirable. Instead, we'll store watch counts for each key to make sure we only
    // watch the table once.
    /** @internal */
    (0, _defineProperty2.default)(_this, "_cellValueKeyWatchCounts", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "__groupedRecordQueryResultPool", void 0);
    _this._sourceModel = sourceModel;
    _this._mostRecentSourceModelLoadPromise = null;
    _this._table = normalizedOpts.table;
    var sorts = _this._normalizedOpts.sorts;
    _this._sorts = sorts !== null && sorts !== void 0 ? sorts : null;
    // TODO (SeanKeenan): Placeholder until we support groups from normalizedOpts
    _this._groupLevels = null;
    _this._visList = null;
    _this._orderedRecordIds = null;
    _this._orderedGroups = null;
    _this._loadedGroupLevels = null;
    _this._cellValueKeyWatchCounts = {};
    var fieldIdsSetToLoadOrNullIfAllFields = null;
    if (_this._normalizedOpts.fieldIdsOrNullIfAllFields) {
      fieldIdsSetToLoadOrNullIfAllFields = {};
      var _iterator = _createForOfIteratorHelper(_this._normalizedOpts.fieldIdsOrNullIfAllFields),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var fieldId = _step.value;
          fieldIdsSetToLoadOrNullIfAllFields[fieldId] = true;
        }
        // Need to load data for fields we're sorting by, even if
        // they're not explicitly requested in the `fields` opt.
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (_this._sorts !== null) {
        var _iterator2 = _createForOfIteratorHelper(_this._sorts),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var sort = _step2.value;
            fieldIdsSetToLoadOrNullIfAllFields[sort.fieldId] = true;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      // TODO (SeanKeenan): Comment back in when enabling groups
      // Same for group configs
      // if (this._groupLevels !== null) {
      //     for (const group of this._groupLevels) {
      //         fieldIdsSetToLoadOrNullIfAllFields[group.fieldId] = true;
      //     }
      // }

      var recordColorMode = _this._normalizedOpts.recordColorMode;
      if (recordColorMode && recordColorMode.type === _record_coloring.ModeTypes.BY_SELECT_FIELD) {
        fieldIdsSetToLoadOrNullIfAllFields[recordColorMode.selectField.id] = true;
      }
    }
    _this._fieldIdsSetToLoadOrNullIfAllFields = fieldIdsSetToLoadOrNullIfAllFields;
    _this.__groupedRecordQueryResultPool = new _object_pool.default(_grouped_record_query_result.default);
    Object.seal(_this);
    return _this;
  }
  /** @internal */
  (0, _inherits2.default)(TableOrViewQueryResult, _RecordQueryResult);
  return (0, _createClass2.default)(TableOrViewQueryResult, [{
    key: "_dataOrNullIfDeleted",
    get: function get() {
      if (this._sourceModel.isDeleted || this._recordStore.isDeleted) {
        return null;
      }
      return {
        recordIds: this._orderedRecordIds,
        groups: this._orderedGroups,
        groupLevels: this._loadedGroupLevels
      };
    }
    /** @internal */
    // istanbul ignore next
  }, {
    key: "__sourceModelId",
    get: function get() {
      return this._sourceModel.id;
    }

    /** @internal */
  }, {
    key: "__poolKey",
    get: function get() {
      return "".concat(this._serializedOpts, "::").concat(this._sourceModel.id);
    }

    /**
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * The table that records in this RecordQueryResult are part of
     */
  }, {
    key: "parentTable",
    get: function get() {
      return this._table;
    }
    /**
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * The view that was used to obtain this RecordQueryResult by calling
     * `view.selectRecords`. Null if the RecordQueryResult was obtained by calling
     * `table.selectRecords`.
     */
  }, {
    key: "parentView",
    get: function get() {
      return this._sourceModel instanceof _table.default ? null : this._sourceModel;
    }
    /**
     * The record IDs in this RecordQueryResult.
     * Throws if data is not loaded yet.
     * Can be watched.
     */
  }, {
    key: "recordIds",
    get: function get() {
      // The following statements have been carefully sequenced to ensure
      // that when this method fails, it reports the most salient error.
      var recordIds = this._data.recordIds; // Throws when the model has been deleted.
      (0, _error_utils.invariant)(this.isDataLoaded, 'RecordQueryResult data is not loaded');
      (0, _error_utils.invariant)(recordIds, 'No recordIds');
      return recordIds;
    }
    /**
     * The ordered GroupedRecordQueryResult's in this RecordQueryResult.
     * Throws if data is not loaded yet.
     * Can be watched.
     *
     * @hidden
     */
  }, {
    key: "groups",
    get: function get() {
      // The following statements have been carefully sequenced to ensure
      // that when this method fails, it reports the most salient error.
      var groups = this._data.groups; // Throws when the model has been deleted.
      (0, _error_utils.invariant)(this.isDataLoaded, 'RecordQueryResult data is not loaded');
      return groups !== null && groups !== void 0 ? groups : null;
    }
    /**
     * The GroupLevels in this RecordQueryResult.
     * Throws if data is not loaded yet.
     * Can be watched.
     *
     * @hidden
     */
  }, {
    key: "groupLevels",
    get: function get() {
      var groupLevels = this._data.groupLevels; // Throws when the model has been deleted.
      (0, _error_utils.invariant)(this.isDataLoaded, 'RecordQueryResult data is not loaded');
      return groupLevels ? groupLevels.map(singleLevel => _objectSpread(_objectSpread({}, singleLevel), {}, {
        field: this.parentTable.getFieldById(singleLevel.fieldId)
      })) : null;
    }
    /**
     * The set of record IDs in this RecordQueryResult.
     * Throws if data is not loaded yet.
     *
     * @internal
     */
  }, {
    key: "_getOrGenerateRecordIdsSet",
    value: function _getOrGenerateRecordIdsSet() {
      if (!this._recordIdsSet) {
        var recordIdsSet = {};
        var _iterator3 = _createForOfIteratorHelper(this.recordIds),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var recordId = _step3.value;
            recordIdsSet[recordId] = true;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        this._recordIdsSet = recordIdsSet;
      }
      return this._recordIdsSet;
    }
    /**
     * The fields that were used to create this RecordQueryResult.
     * Null if fields were not specified, which means the RecordQueryResult
     * will load all fields in the table.
     */
  }, {
    key: "fields",
    get: function get() {
      var fieldIdsOrNullIfAllFields = this._normalizedOpts.fieldIdsOrNullIfAllFields;
      if (fieldIdsOrNullIfAllFields) {
        var fields = [];
        // Filter out any deleted fields, since RecordQueryResult is "live".
        // It would be too cumbersome (and defeat part of the purpose of
        // using RecordQueryResult) if the user had to manually watch for deletion
        // on all the fields and recreate the RecordQueryResult.
        var _iterator4 = _createForOfIteratorHelper(fieldIdsOrNullIfAllFields),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var fieldId = _step4.value;
            var field = this._table.getFieldByIdIfExists(fieldId);
            if (field !== null) {
              fields.push(field);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        return fields;
      } else {
        return null;
      }
    }
    /** @internal */
  }, {
    key: "_cellValuesForSortWatchKeys",
    get: function get() {
      return this._sorts ? this._sorts.map(sort => "cellValuesInField:".concat(sort.fieldId)) : [];
    }
    /** @internal */
  }, {
    key: "_cellValuesForGroupWatchKeys",
    get: function get() {
      // _groupLevels can not be specified by the user during the query yet
      // istanbul ignore next
      return this._groupLevels ? this._groupLevels.map(group => "cellValuesInField:".concat(group.fieldId)) : [];
    }
    /** @internal */
  }, {
    key: "_sourceModelRecordIds",
    get: function get() {
      return this._sourceModel instanceof _table.default ? this._recordStore.recordIds : this._recordStore.getViewDataStore(this._sourceModel.id).visibleRecordIds;
    }
    /** @internal */
  }, {
    key: "_sourceModelGroups",
    get: function get() {
      return this._sourceModel instanceof _table.default ? null : this._recordStore.getViewDataStore(this._sourceModel.id).groups;
    }
    /** @internal */
  }, {
    key: "_sourceModelGroupLevels",
    get: function get() {
      return this._sourceModel instanceof _table.default ? null : this._recordStore.getViewDataStore(this._sourceModel.id).groupLevels;
    }
    /** @internal */
  }, {
    key: "_sourceModelRecords",
    get: function get() {
      return this._sourceModel instanceof _table.default ? this._recordStore.records : this._recordStore.getViewDataStore(this._sourceModel.id).visibleRecords;
    }
    /** @internal */
  }, {
    key: "_incrementCellValueKeyWatchCountAndWatchIfNecessary",
    value: function _incrementCellValueKeyWatchCountAndWatchIfNecessary(key, watchCallback) {
      if (!this._cellValueKeyWatchCounts[key]) {
        this._cellValueKeyWatchCounts[key] = 0;
        this._recordStore.watch(key, watchCallback, this);
      }
      this._cellValueKeyWatchCounts[key]++;
    }
    /** @internal */
  }, {
    key: "_decrementCellValueKeyWatchCountAndUnwatchIfPossible",
    value: function _decrementCellValueKeyWatchCountAndUnwatchIfPossible(key, watchCallback) {
      if (!this._cellValueKeyWatchCounts[key]) {
        // Key isn't watched, so just skip it. This matches behavior of Watchable,
        // where calling unwatch on a key that isn't watched just no-ops.
        return;
      }
      this._cellValueKeyWatchCounts[key]--;
      if (this._cellValueKeyWatchCounts[key] === 0) {
        // We're down to zero watches for this key, so we can actually unwatch it now.
        this._recordStore.unwatch(key, watchCallback, this);
        delete this._cellValueKeyWatchCounts[key];
      }
    }
    /** @inheritdoc */
  }, {
    key: "watch",
    value: function watch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(TableOrViewQueryResult.prototype), "watch", this).call(this, keys, callback, context);
      var _iterator5 = _createForOfIteratorHelper(validKeys),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var key = _step5.value;
          if (key.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix)) {
            var fieldId = key.substring(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix.length);
            if (this._fieldIdsSetToLoadOrNullIfAllFields && !(0, _private_utils.has)(this._fieldIdsSetToLoadOrNullIfAllFields, fieldId)) {
              throw (0, _error_utils.spawnError)("Can't watch field because it wasn't included in RecordQueryResult fields: %s", fieldId);
            }
            this._incrementCellValueKeyWatchCountAndWatchIfNecessary(key, this._onCellValuesInFieldChanged);
          }
          if (key === _record_query_result.default.WatchableKeys.cellValues) {
            if (this._fieldIdsSetToLoadOrNullIfAllFields) {
              for (var _i = 0, _Object$keys = Object.keys(this._fieldIdsSetToLoadOrNullIfAllFields); _i < _Object$keys.length; _i++) {
                var _fieldId = _Object$keys[_i];
                this._incrementCellValueKeyWatchCountAndWatchIfNecessary(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + _fieldId, this._onCellValuesChanged);
              }
            } else {
              this._incrementCellValueKeyWatchCountAndWatchIfNecessary(key, this._onCellValuesChanged);
            }
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return validKeys;
    }
    /** @inheritdoc */
  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(TableOrViewQueryResult.prototype), "unwatch", this).call(this, keys, callback, context);
      var _iterator6 = _createForOfIteratorHelper(validKeys),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var key = _step6.value;
          if (key.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix)) {
            this._decrementCellValueKeyWatchCountAndUnwatchIfPossible(key, this._onCellValuesInFieldChanged);
          }
          if (key === _record_query_result.default.WatchableKeys.cellValues) {
            if (this._fieldIdsSetToLoadOrNullIfAllFields) {
              for (var _i2 = 0, _Object$keys2 = Object.keys(this._fieldIdsSetToLoadOrNullIfAllFields); _i2 < _Object$keys2.length; _i2++) {
                var fieldId = _Object$keys2[_i2];
                this._decrementCellValueKeyWatchCountAndUnwatchIfPossible(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId, this._onCellValuesChanged);
              }
            } else {
              this._decrementCellValueKeyWatchCountAndUnwatchIfPossible(key, this._onCellValuesChanged);
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return validKeys;
    }
    /** @inheritdoc */
  }, {
    key: "loadDataAsync",
    value: (function () {
      var _loadDataAsync2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var sourceModelLoadPromise, cellValuesInFieldsLoadPromise;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this._sourceModel.isDeleted) {
                _context.next = 2;
                break;
              }
              throw this._spawnErrorForDeletion();
            case 2:
              if (this._fieldIdsSetToLoadOrNullIfAllFields) {
                cellValuesInFieldsLoadPromise = this._recordStore.loadCellValuesInFieldIdsAsync(Object.keys(this._fieldIdsSetToLoadOrNullIfAllFields));
              } else {
                // Load all fields.
                cellValuesInFieldsLoadPromise = this._recordStore.loadDataAsync();
              }
              if (this._sourceModel instanceof _table.default) {
                if (this._fieldIdsSetToLoadOrNullIfAllFields) {
                  sourceModelLoadPromise = this._recordStore.loadRecordMetadataAsync();
                } else {
                  // table.loadDataAsync is a superset of loadRecordMetadataAsync,
                  // so no need to load record metadata again.
                  sourceModelLoadPromise = null;
                }
              } else {
                sourceModelLoadPromise = this._recordStore.getViewDataStore(this._sourceModel.id).loadDataAsync();
              }
              this._mostRecentSourceModelLoadPromise = Promise.all([sourceModelLoadPromise, cellValuesInFieldsLoadPromise, this._loadRecordColorsAsync()]);
              _context.next = 7;
              return (0, _get2.default)((0, _getPrototypeOf2.default)(TableOrViewQueryResult.prototype), "loadDataAsync", this).call(this);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function loadDataAsync() {
        return _loadDataAsync2.apply(this, arguments);
      }
      return loadDataAsync;
    }()
    /**
     * @internal
     */
    )
  }, {
    key: "_getChangedKeysOnLoad",
    value: function _getChangedKeysOnLoad() {
      var changedKeys = [_record_query_result.default.WatchableKeys.records, _record_query_result.default.WatchableKeys.recordIds, _record_query_result.default.WatchableKeys.cellValues, _record_query_result.default.WatchableKeys.groups, _record_query_result.default.WatchableKeys.groupLevels];
      var fieldIds = this._normalizedOpts.fieldIdsOrNullIfAllFields || this._table.fields.map(field => field.id);
      var _iterator7 = _createForOfIteratorHelper(fieldIds),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var fieldId = _step7.value;
          changedKeys.push(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId);
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return changedKeys;
    }

    /** @internal */
  }, {
    key: "_loadDataAsync",
    value: (function () {
      var _loadDataAsync3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var viewDataStore, _iterator8, _step8, sort, field;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this._table.__tableOrViewQueryResultPool.registerObjectForReuseStrong(this);
              (0, _error_utils.invariant)(this._mostRecentSourceModelLoadPromise, 'No source model load promises');
              _context2.next = 4;
              return this._mostRecentSourceModelLoadPromise;
            case 4:
              if (this._sorts) {
                this._replaceVisList();
              }
              this._orderedRecordIds = this._generateOrderedRecordIds();
              this._orderedGroups = this._generateAndLoadOrderedGroups();
              // The server provided value and developer supplied value are the same, no conversion needed
              this._loadedGroupLevels = this._sourceModelGroupLevels;
              if (this._sourceModel instanceof _table.default) {
                this._recordStore.watch(_record_store.WatchableRecordStoreKeys.records, this._onRecordsChanged, this);
              } else {
                viewDataStore = this._recordStore.getViewDataStore(this._sourceModel.id);
                viewDataStore.watch(_view_data_store.WatchableViewDataStoreKeys.visibleRecords, this._onRecordsChanged, this);
                viewDataStore.watch(_view_data_store.WatchableViewDataStoreKeys.groups, this._onGroupsChanged, this);
                viewDataStore.watch(_view_data_store.WatchableViewDataStoreKeys.groupLevels, this._onGroupLevelsChanged, this);
              }
              this._recordStore.watch(this._cellValuesForSortWatchKeys, this._onCellValuesForSortChanged, this);
              this._recordStore.watch(this._cellValuesForGroupWatchKeys, this._onCellValuesForGroupChanged, this);
              this._table.watch(_table.WatchableTableKeys.fields, this._onTableFieldsChanged, this);
              if (this._sorts) {
                _iterator8 = _createForOfIteratorHelper(this._sorts);
                try {
                  for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                    sort = _step8.value;
                    field = this._table.getFieldByIdIfExists(sort.fieldId);
                    if (field) {
                      field.watch('type', this._onFieldConfigChanged, this);
                      field.watch('options', this._onFieldConfigChanged, this);
                    }
                  }
                } catch (err) {
                  _iterator8.e(err);
                } finally {
                  _iterator8.f();
                }
              }
              return _context2.abrupt("return", this._getChangedKeysOnLoad());
            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _loadDataAsync() {
        return _loadDataAsync3.apply(this, arguments);
      }
      return _loadDataAsync;
    }() /** @inheritdoc */)
  }, {
    key: "unloadData",
    value: function unloadData() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(TableOrViewQueryResult.prototype), "unloadData", this).call(this);
      if (this._sourceModel instanceof _table.default) {
        if (this._fieldIdsSetToLoadOrNullIfAllFields) {
          this._recordStore.unloadRecordMetadata();
        } else {
          this._recordStore.unloadData();
        }
      } else {
        // If the view is deleted, we can't get a data store for it.
        if (!this._sourceModel.isDeleted) {
          this._recordStore.getViewDataStore(this._sourceModel.id).unloadData();
        }
      }
      if (this._fieldIdsSetToLoadOrNullIfAllFields) {
        this._recordStore.unloadCellValuesInFieldIds(Object.keys(this._fieldIdsSetToLoadOrNullIfAllFields));
      }
      this._unloadRecordColors();
    }
    /** @internal */
  }, {
    key: "_unloadData",
    value: function _unloadData() {
      this._mostRecentSourceModelLoadPromise = null;
      if (this._sourceModel instanceof _table.default) {
        this._recordStore.unwatch(_record_store.WatchableRecordStoreKeys.records, this._onRecordsChanged, this);
      } else {
        if (!this._sourceModel.isDeleted) {
          var viewDataStore = this._recordStore.getViewDataStore(this._sourceModel.id);
          viewDataStore.unwatch(_view_data_store.WatchableViewDataStoreKeys.visibleRecords, this._onRecordsChanged, this);
          viewDataStore.unwatch(_view_data_store.WatchableViewDataStoreKeys.groups, this._onGroupsChanged, this);
          viewDataStore.unwatch(_view_data_store.WatchableViewDataStoreKeys.groupLevels, this._onGroupLevelsChanged, this);
        }
      }
      this._recordStore.unwatch(this._cellValuesForSortWatchKeys, this._onCellValuesForSortChanged, this);
      this._recordStore.unwatch(this._cellValuesForGroupWatchKeys, this._onCellValuesForGroupChanged, this);
      this._table.unwatch(_table.WatchableTableKeys.fields, this._onTableFieldsChanged, this);

      // If the table is deleted, can't call getFieldById on it below.
      if (!this._table.isDeleted && this._sorts) {
        var _iterator9 = _createForOfIteratorHelper(this._sorts),
          _step9;
        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var sort = _step9.value;
            var field = this._table.getFieldByIdIfExists(sort.fieldId);
            if (field) {
              field.unwatch('type', this._onFieldConfigChanged, this);
              field.unwatch('options', this._onFieldConfigChanged, this);
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
      }
      this._unloadOrderedGroupsIfNeeded();
      this._visList = null;
      this._orderedRecordIds = null;
      this._recordIdsSet = null;
      this._table.__tableOrViewQueryResultPool.unregisterObjectForReuseStrong(this);
    }
    /** @internal */
  }, {
    key: "_addRecordIdsToVisList",
    value: function _addRecordIdsToVisList(recordIds) {
      var visList = this._visList;
      (0, _error_utils.invariant)(visList, 'No vis list');
      var _iterator10 = _createForOfIteratorHelper(recordIds),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var recordId = _step10.value;
          var record = this._recordStore.getRecordByIdIfExists(recordId);
          (0, _error_utils.invariant)(record, 'Record missing in table');
          visList.addRecordData(record._data);
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
    /** @internal */
  }, {
    key: "_onGroupLevelsChanged",
    value: function _onGroupLevelsChanged(model, key, updates) {
      this._loadedGroupLevels = this._sourceModelGroupLevels;
      this._unloadRemovedGroupsAndLoadNewGroupsAndTriggerWatches();
      this._onChange(_record_query_result.default.WatchableKeys.groupLevels);
    }
    /** @internal */
  }, {
    key: "_onGroupsChanged",
    value: function _onGroupsChanged(model, key, updates) {
      this._unloadRemovedGroupsAndLoadNewGroupsAndTriggerWatches();
    }
    /** @internal */
  }, {
    key: "_onRecordsChanged",
    value: function _onRecordsChanged(model, key, updates) {
      if (model instanceof _view_data_store.default) {
        // For a view model, we don't get updates sent with the onChange event,
        // so we need to manually generate updates based on the old and new
        // recordIds.
        (0, _error_utils.invariant)(this._orderedRecordIds, '_orderedRecordIds unset');
        var visibleRecordIds = this._recordStore.getViewDataStore(model.viewId).visibleRecordIds;
        var _addedRecordIds = (0, _private_utils.arrayDifference)(visibleRecordIds, this._orderedRecordIds);
        var _removedRecordIds = (0, _private_utils.arrayDifference)(this._orderedRecordIds, visibleRecordIds);
        updates = {
          addedRecordIds: _addedRecordIds,
          removedRecordIds: _removedRecordIds
        };
      }
      if (!updates) {
        // If there are no updates, do nothing, since we'll handle the initial
        // callback when the record set is loaded (and we don't want to fire
        // a records change twice with no data).
        return;
      }
      var _updates = updates,
        addedRecordIds = _updates.addedRecordIds,
        removedRecordIds = _updates.removedRecordIds;
      if (this._sorts) {
        var visList = this._visList;
        (0, _error_utils.invariant)(visList, 'No vis list');
        if (removedRecordIds.length > 0) {
          visList.removeRecordIds(removedRecordIds);
        }
        if (addedRecordIds.length > 0) {
          this._addRecordIdsToVisList(addedRecordIds);
        }
      }
      if (this._recordIdsSet) {
        var _iterator11 = _createForOfIteratorHelper(addedRecordIds),
          _step11;
        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var recordId = _step11.value;
            this._recordIdsSet[recordId] = true;
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
        var _iterator12 = _createForOfIteratorHelper(removedRecordIds),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var _recordId = _step12.value;
            this._recordIdsSet[_recordId] = undefined;
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
      }

      // Now that we've applied our changes (if applicable), let's regenerate our recordIds.
      this._orderedRecordIds = this._generateOrderedRecordIds();
      this._onChange(_record_query_result.default.WatchableKeys.records, updates);
      this._onChange(_record_query_result.default.WatchableKeys.recordIds, updates);
    }
    /** @internal */
    // istanbul ignore next
  }, {
    key: "_onCellValuesForGroupChanged",
    value: function _onCellValuesForGroupChanged(recordStore, key, recordIds, fieldId) {
      // TODO(SeanKeenan): This isn't yet required as we don't yet support
      // specifying groups for a custom query, and this will only be called
      // if we specify groups (same as _onCellValuesForSortChanged)
      // This functionality and _onCellValuesForSortChanged should be
      // identical, but testing, validation, and careful thought is required.
    }
    /** @internal */
  }, {
    key: "_onCellValuesForSortChanged",
    value: function _onCellValuesForSortChanged(recordStore, key, recordIds, fieldId) {
      if (!recordIds || !fieldId) {
        // If there are no updates, do nothing, since we'll handle the initial
        // callback when the record set is loaded (and we don't want to fire
        // a records change twice with no data).
        return;
      }

      // NOTE: this will only ever be called if we have sorts, so it's safe to assert that we have
      // a vis list here.
      var visList = this._visList;
      (0, _error_utils.invariant)(visList, 'No vis list');
      (0, _error_utils.invariant)(recordIds.length > 0, 'field ID set without a corresponding record ID');

      // Only move recordIds that are already in the visList.
      // It's possible to have recordId that is not currently in the visList since
      // this callback can run before onRecordsChanged. (eg. when a deleted record is
      // restored, this is triggered for that record but the record is not yet in the visList:
      // onRecordsChanged actually adds it)
      // Note: cell value changes that result in the records being filtered out trigger
      //       onRecordsChanged on the View model, so we don't have to worry about that here.
      var visListRecordIdsSet = new Set(visList.getOrderedRecordIds());
      var recordIdsToMove = recordIds.filter(recordId => visListRecordIdsSet.has(recordId));
      visList.removeRecordIds(recordIdsToMove);
      this._addRecordIdsToVisList(recordIdsToMove);
      this._orderedRecordIds = this._generateOrderedRecordIds();
      var changeData = {
        addedRecordIds: [],
        removedRecordIds: []
      };
      this._onChange(_record_query_result.default.WatchableKeys.records, changeData);
      this._onChange(_record_query_result.default.WatchableKeys.recordIds, changeData);
    }
    /** @internal */
  }, {
    key: "_onFieldConfigChanged",
    value: function _onFieldConfigChanged(_field, _key) {
      // Field config changed for a field we rely on, so we need to replace our vis list.
      // NOTE: this will only ever be called if we have sorts, so it's safe to assume we
      // are using a vis list here.
      this._replaceVisList();
      this._orderedRecordIds = this._generateOrderedRecordIds();
    }
    /** @internal */
  }, {
    key: "_onTableFieldsChanged",
    value: function _onTableFieldsChanged(table, key, updates) {
      if (!this._sorts) {
        // If we don't have any sorts, we don't have to do anything in response to field changes.
        return;
      }
      var addedFieldIds = updates.addedFieldIds,
        removedFieldIds = updates.removedFieldIds;
      var fieldIdsSet = new Set(this._sorts.map(sort => sort.fieldId));

      // Check if any fields that we rely on were created or deleted. If they were,
      // replace our vis list.
      // NOTE: we need to check for created, since a field that we rely on can be
      // deleted and then undeleted.
      var wereAnyFieldsCreatedOrDeleted = false;
      var _iterator13 = _createForOfIteratorHelper(addedFieldIds),
        _step13;
      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var fieldId = _step13.value;
          // If a field that we rely on was created (i.e. it was undeleted), we need to
          // make sure we're watching it's config.
          if (fieldIdsSet.has(fieldId)) {
            wereAnyFieldsCreatedOrDeleted = true;
            var field = this._table.getFieldByIdIfExists(fieldId);
            (0, _error_utils.invariant)(field, 'Created field does not exist');
            field.watch('type', this._onFieldConfigChanged, this);
            field.watch('options', this._onFieldConfigChanged, this);
          }
        }

        // coverage analysis
        // istanbul ignore else
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
      if (!wereAnyFieldsCreatedOrDeleted) {
        wereAnyFieldsCreatedOrDeleted = removedFieldIds.some(fieldId => fieldIdsSet.has(fieldId));
      }
      if (wereAnyFieldsCreatedOrDeleted) {
        // One of the fields we're relying on was deleted,
        this._replaceVisList();
        this._orderedRecordIds = this._generateOrderedRecordIds();

        // Make sure we fire onChange events since the order may have changed
        // as a result.
        var changeData = {
          addedRecordIds: [],
          removedRecordIds: []
        };
        this._onChange(_record_query_result.default.WatchableKeys.records, changeData);
        this._onChange(_record_query_result.default.WatchableKeys.recordIds, changeData);

        // We do not unload/reload groupQueryResults if it's field is deleted as
        // it is responsible for failing to load if the field doesn't exist
      }
    }
    /** @internal */
  }, {
    key: "_onCellValuesChanged",
    value: function _onCellValuesChanged(table, key, updates) {
      if (!updates) {
        // If there are no updates, do nothing, since we'll handle the initial
        // callback when the record set is loaded (and we don't want to fire
        // a cellValues change twice with no data).
        return;
      }
      this._onChange(_record_query_result.default.WatchableKeys.cellValues, updates);
    }
    /** @internal */
  }, {
    key: "_onCellValuesInFieldChanged",
    value: function _onCellValuesInFieldChanged(table, key, recordIds, fieldId) {
      if (!recordIds && !fieldId) {
        // If there are no updates, do nothing, since we'll handle the initial
        // callback when the record set is loaded (and we don't want to fire
        // a cellValuesInField change twice with no data).
        return;
      }
      this._onChange(key, recordIds, fieldId);
    }
    /** @internal */
  }, {
    key: "_generateOrderedRecordIds",
    value: function _generateOrderedRecordIds() {
      if (this._sorts) {
        (0, _error_utils.invariant)(this._visList, 'Cannot generate record ids without a vis list');
        return this._visList.getOrderedRecordIds();
      } else {
        return this._sourceModelRecordIds;
      }
    }
    /** @internal */
  }, {
    key: "_generateAndLoadOrderedGroups",
    value: function _generateAndLoadOrderedGroups() {
      // istanbul ignore next
      if (this._groupLevels) {
        (0, _error_utils.invariant)(this._visList, 'Cannot generate record ids without a vis list');
        throw (0, _error_utils.spawnError)('custom group configs not supported');
      } else {
        // Get the group from the view itself
        var groupLevels = this._sourceModelGroupLevels;
        if (!this._sourceModelGroups || !groupLevels) {
          return null;
        }
        return this._sourceModelGroups.map(groupData => {
          var group = this.__groupedRecordQueryResultPool.getObjectForReuse(this, groupData, groupLevels, this._normalizedOpts, this._sdk);
          // Don't await the loading, let others check isDataLoaded.
          // (it doesn't take any time anyway). Loading also strong retains.
          group.loadDataAsync();
          return group;
        });
      }
    }
    /** @internal */
  }, {
    key: "_unloadOrderedGroupsIfNeeded",
    value: function _unloadOrderedGroupsIfNeeded() {
      if (this._orderedGroups) {
        var _iterator14 = _createForOfIteratorHelper(this._orderedGroups),
          _step14;
        try {
          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
            var group = _step14.value;
            group.unloadData();
          }
        } catch (err) {
          _iterator14.e(err);
        } finally {
          _iterator14.f();
        }
      }
    }
    /**
     * If groupings change then some groups will need to be created, and some removed
     * This (TODO: will) handle the diffing necessary to unload, and reload only the changed groups.
     * Also triggers the WatchableKeys.group, as by necessity this will have changed.
     *
     * @internal
     */
    // TODO: (SeanKeenan) Properly diff and only unload groups that need to be unloaded
    // In the meantime it's not too expensive to just unload everything, and GroupedRecordQueryResults
    // don't yet properly watch changes relevant to updating, so this isn't too bad.
    // (They do invalidate their recordId caches, which is some very cheap work that we could remove)
  }, {
    key: "_unloadRemovedGroupsAndLoadNewGroupsAndTriggerWatches",
    value: function _unloadRemovedGroupsAndLoadNewGroupsAndTriggerWatches() {
      this._unloadOrderedGroupsIfNeeded();
      this._orderedGroups = this._generateAndLoadOrderedGroups();
      this._onChange(_record_query_result.default.WatchableKeys.groups);
    }
    /** @internal */
  }, {
    key: "_replaceVisList",
    value: function _replaceVisList() {
      var airtableInterface = this._sdk.__airtableInterface;
      var appInterface = this._sdk.__appInterface;
      var recordDatas = this._sourceModelRecords.map(record => record._data);
      var fieldDatas = this._table.fields.map(field => field._data);
      var filteredSorts = this._getSortsWithDeletedFieldsFiltered();
      this._visList = airtableInterface.createVisList(appInterface, recordDatas, fieldDatas, filteredSorts);
    }
    /** @internal */
  }, {
    key: "_getSortsWithDeletedFieldsFiltered",
    value: function _getSortsWithDeletedFieldsFiltered() {
      (0, _error_utils.invariant)(this._sorts, 'No sorts');

      // Filter out any sorts levels that rely on deleted fields.
      // NOTE: we keep deleted fields around (rather than filtering them out
      // in realtime) in case a field gets undeleted, in which case we want to
      // keep using it.
      return this._sorts.filter(sort => {
        var field = this._table.getFieldByIdIfExists(sort.fieldId);
        return !!field;
      });
    }
    /** @internal */
  }, {
    key: "_spawnErrorForDeletion",
    value: function _spawnErrorForDeletion() {
      var sourceModelName = this._sourceModel instanceof _table.default ? 'table' : 'view';
      return (0, _error_utils.spawnError)("RecordQueryResult's underlying %s has been deleted", sourceModelName);
    }
  }]);
}(_record_query_result.default);
/** @internal */
(0, _defineProperty2.default)(TableOrViewQueryResult, "_className", 'TableOrViewQueryResult');
var _default = exports.default = TableOrViewQueryResult;