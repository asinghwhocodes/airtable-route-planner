"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.WatchableViewDataStoreKeys = void 0;
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _private_utils = require("../private_utils");
var _error_utils = require("../error_utils");
var _abstract_model_with_async_data = _interopRequireDefault(require("./abstract_model_with_async_data"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var WatchableViewDataStoreKeys = exports.WatchableViewDataStoreKeys = Object.freeze({
  visibleRecords: 'visibleRecords',
  visibleRecordIds: 'visibleRecordIds',
  groups: 'groups',
  groupLevels: 'groupLevels',
  recordColors: 'recordColors',
  allFieldIds: 'allFieldIds',
  visibleFieldIds: 'visibleFieldIds'
});

/** @internal */
// ViewDataStore contains loadable data for a specific view. That means the set of visible records,
// and field order/visibility information. View itself only contains core schema information. The
// data here doesn't belong in View as it's record data or conditionally loaded.
/** @internal */
var ViewDataStore = /*#__PURE__*/function (_AbstractModelWithAsy) {
  function ViewDataStore(sdk, parentRecordStore, viewId) {
    var _this;
    (0, _classCallCheck2.default)(this, ViewDataStore);
    _this = _callSuper(this, ViewDataStore, [sdk, "".concat(viewId, "-ViewDataStore")]);
    (0, _defineProperty2.default)(_this, "viewId", void 0);
    (0, _defineProperty2.default)(_this, "parentRecordStore", void 0);
    (0, _defineProperty2.default)(_this, "_mostRecentTableLoadPromise", void 0);
    (0, _defineProperty2.default)(_this, "_airtableInterface", void 0);
    _this.parentRecordStore = parentRecordStore;
    _this._airtableInterface = sdk.__airtableInterface;
    _this._mostRecentTableLoadPromise = null;
    _this.viewId = viewId;
    return _this;
  }
  (0, _inherits2.default)(ViewDataStore, _AbstractModelWithAsy);
  return (0, _createClass2.default)(ViewDataStore, [{
    key: "_dataOrNullIfDeleted",
    get: function get() {
      var _tableData$viewsById$;
      var tableData = this._baseData.tablesById[this.parentRecordStore.tableId];
      return (_tableData$viewsById$ = tableData === null || tableData === void 0 ? void 0 : tableData.viewsById[this.viewId]) !== null && _tableData$viewsById$ !== void 0 ? _tableData$viewsById$ : null;
    }
  }, {
    key: "_onChangeIsDataLoaded",
    value: function _onChangeIsDataLoaded() {
      // noop
    }
  }, {
    key: "isDataLoaded",
    get: function get() {
      return this._isDataLoaded && this.parentRecordStore.isRecordMetadataLoaded;
    }
  }, {
    key: "__onDataDeletion",
    value: function __onDataDeletion() {
      this._forceUnload();
    }
  }, {
    key: "loadDataAsync",
    value: function () {
      var _loadDataAsync2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var tableLoadPromise;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // Override this method to also load table data.
              // NOTE: it's important that we call loadDataAsync on the table here and not in
              // _loadDataAsync since we want the retain counts for the view and table to increase/decrease
              // in lock-step. If we load table data in _loadDataAsync, the table's retain
              // count only increments some of the time, which leads to unexpected behavior.
              tableLoadPromise = this.parentRecordStore.loadRecordMetadataAsync();
              this._mostRecentTableLoadPromise = tableLoadPromise;
              _context.next = 4;
              return (0, _get2.default)((0, _getPrototypeOf2.default)(ViewDataStore.prototype), "loadDataAsync", this).call(this);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function loadDataAsync() {
        return _loadDataAsync2.apply(this, arguments);
      }
      return loadDataAsync;
    }()
  }, {
    key: "_loadDataAsync",
    value: function () {
      var _loadDataAsync3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var tableLoadPromise, _yield$Promise$all, _yield$Promise$all2, viewData, _iterator, _step, record;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              // We need to be sure that the table data is loaded *before* we return
              // from this method.
              (0, _error_utils.invariant)(this._mostRecentTableLoadPromise, 'No table load promise');
              tableLoadPromise = this._mostRecentTableLoadPromise;
              _context2.next = 4;
              return Promise.all([this._airtableInterface.fetchAndSubscribeToViewDataAsync(this.parentRecordStore.tableId, this.viewId), tableLoadPromise]);
            case 4:
              _yield$Promise$all = _context2.sent;
              _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 1);
              viewData = _yield$Promise$all2[0];
              this._data.visibleRecordIds = viewData.visibleRecordIds;
              this._data.fieldOrder = viewData.fieldOrder;
              this._data.groups = viewData.groups;
              this._data.groupLevels = viewData.groupLevels;
              this._data.colorsByRecordId = viewData.colorsByRecordId;
              if (this._data.colorsByRecordId) {
                _iterator = _createForOfIteratorHelper(this.visibleRecords);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    record = _step.value;
                    if ((0, _private_utils.has)(this._data.colorsByRecordId, record.id)) {
                      record.__triggerOnChangeForRecordColorInViewId(this.viewId);
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              return _context2.abrupt("return", [WatchableViewDataStoreKeys.visibleRecords, WatchableViewDataStoreKeys.visibleRecordIds, WatchableViewDataStoreKeys.allFieldIds, WatchableViewDataStoreKeys.groups, WatchableViewDataStoreKeys.groupLevels, WatchableViewDataStoreKeys.visibleFieldIds, WatchableViewDataStoreKeys.recordColors]);
            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _loadDataAsync() {
        return _loadDataAsync3.apply(this, arguments);
      }
      return _loadDataAsync;
    }()
  }, {
    key: "unloadData",
    value: function unloadData() {
      // Override this method to also unload the table's data.
      // NOTE: it's important that we do this here, since we want the view and table's
      // retain counts to increment/decrement in lock-step. If we unload the table's
      // data in _unloadData, it leads to unexpected behavior.
      (0, _get2.default)((0, _getPrototypeOf2.default)(ViewDataStore.prototype), "unloadData", this).call(this);
      this.parentRecordStore.unloadRecordMetadata();
    }
  }, {
    key: "_unloadData",
    value: function _unloadData() {
      this._mostRecentTableLoadPromise = null;
      this._airtableInterface.unsubscribeFromViewData(this.parentRecordStore.tableId, this.viewId);
      if (!this.isDeleted) {
        this._data.visibleRecordIds = undefined;
        this._data.groups = undefined;
        this._data.colorsByRecordId = undefined;
      }
    }
  }, {
    key: "__generateChangesForParentTableAddMultipleRecords",
    value: function __generateChangesForParentTableAddMultipleRecords(recordIds) {
      var newVisibleRecordIds = [...this.visibleRecordIds, ...recordIds];
      return [{
        path: ['tablesById', this.parentRecordStore.tableId, 'viewsById', this.viewId, 'visibleRecordIds'],
        value: newVisibleRecordIds
      }];
    }
  }, {
    key: "__generateChangesForParentTableDeleteMultipleRecords",
    value: function __generateChangesForParentTableDeleteMultipleRecords(recordIds) {
      var recordIdsToDeleteSet = {};
      var _iterator2 = _createForOfIteratorHelper(recordIds),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var recordId = _step2.value;
          recordIdsToDeleteSet[recordId] = true;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var newVisibleRecordIds = this.visibleRecordIds.filter(recordId => !recordIdsToDeleteSet[recordId]);
      var changePayload = [{
        path: ['tablesById', this.parentRecordStore.tableId, 'viewsById', this.viewId, 'visibleRecordIds'],
        value: newVisibleRecordIds
      }];
      if (this._data.groups) {
        var newGroups = this.__recursivelyRemoveRecordsFromGroupsInPlace((0, _private_utils.cloneDeep)(this._data.groups), recordIdsToDeleteSet);
        changePayload.push({
          path: ['tablesById', this.parentRecordStore.tableId, 'viewsById', this.viewId, 'groups'],
          value: newGroups
        });
      }
      return changePayload;
    }
  }, {
    key: "__recursivelyRemoveRecordsFromGroupsInPlace",
    value: function __recursivelyRemoveRecordsFromGroupsInPlace(groups, recordIdsToDeleteSet) {
      if (!groups || groups.length === 0) {
        return groups;
      }
      return groups.map(group => {
        if (group.visibleRecordIds) {
          group.visibleRecordIds = group.visibleRecordIds.filter(id => !recordIdsToDeleteSet[id]);
        }
        this.__recursivelyRemoveRecordsFromGroupsInPlace(group.groups, recordIdsToDeleteSet);
        return group;
      });
    }

    /**
     * The record IDs that are not filtered out of this view.
     * Can be watched to know when records are created, deleted, reordered, or
     * filtered in and out of this view.
     */
  }, {
    key: "visibleRecordIds",
    get: function get() {
      var visibleRecordIds = this._data.visibleRecordIds;
      (0, _error_utils.invariant)(visibleRecordIds, 'View data is not loaded');

      // Freeze visibleRecordIds so users can't mutate it.
      // If it changes from liveapp, we get an entire new array which will
      // replace this one, so it's okay to freeze it.
      if (!Object.isFrozen(visibleRecordIds)) {
        Object.freeze(visibleRecordIds);
      }
      return visibleRecordIds;
    }

    /**
     * The records that are not filtered out of this view.
     * Can be watched to know when records are created, deleted, reordered, or
     * filtered in and out of this view.
     */
  }, {
    key: "visibleRecords",
    get: function get() {
      (0, _error_utils.invariant)(this.parentRecordStore.isRecordMetadataLoaded, 'Table data is not loaded');
      var visibleRecordIds = this._data.visibleRecordIds;
      (0, _error_utils.invariant)(visibleRecordIds, 'View data is not loaded');
      return visibleRecordIds.map(recordId => {
        var record = this.parentRecordStore.getRecordByIdIfExists(recordId);
        (0, _error_utils.invariant)(record, 'Record in view does not exist');
        return record;
      });
    }

    /**
     * Gets the groups in a view, can be watched to be notified if a record changes groups,
     * if a record is changed/deleted/created, if sort order of groups changes, grouping
     * heirarchy changes, or grouping field changes.
     *
     * @hidden
     */
  }, {
    key: "groups",
    get: function get() {
      (0, _error_utils.invariant)(this.parentRecordStore.isRecordMetadataLoaded, 'Table data is not loaded');
      var groups = this._data.groups;
      return groups !== null && groups !== void 0 ? groups : null;
    }

    /**
     * Gets the group config for this view, can be watched to know when groupLevels
     * changes (reorder, groups deleted, groups changed, grouped field changes)
     */
  }, {
    key: "groupLevels",
    get: function get() {
      (0, _error_utils.invariant)(this.parentRecordStore.isRecordMetadataLoaded, 'Table data is not loaded');
      var groupLevels = this._data.groupLevels;
      return groupLevels !== null && groupLevels !== void 0 ? groupLevels : null;
    }

    /**
     * Get the color name for the specified record in this view, or null if no
     * color is available. Watch with 'recordColors'
     *
     * @param recordOrRecordId the record/record id to get the color for
     */
  }, {
    key: "getRecordColor",
    value: function getRecordColor(record) {
      var _this$_data$colorsByR, _this$_data$colorsByR2;
      (0, _error_utils.invariant)(this.isDataLoaded, 'View data is not loaded');
      return (_this$_data$colorsByR = (_this$_data$colorsByR2 = this._data.colorsByRecordId) === null || _this$_data$colorsByR2 === void 0 ? void 0 : _this$_data$colorsByR2[record.id]) !== null && _this$_data$colorsByR !== void 0 ? _this$_data$colorsByR : null;
    }
  }, {
    key: "allFieldIds",
    get: function get() {
      var fieldOrder = this._data.fieldOrder;
      (0, _error_utils.invariant)(fieldOrder, 'View data is not loaded');
      return fieldOrder.fieldIds;
    }
  }, {
    key: "visibleFieldIds",
    get: function get() {
      var fieldOrder = this._data.fieldOrder;
      (0, _error_utils.invariant)(fieldOrder, 'View data is not loaded');
      var fieldIds = fieldOrder.fieldIds;
      return fieldIds.slice(0, fieldOrder.visibleFieldCount);
    }
  }, {
    key: "triggerOnChangeForDirtyPaths",
    value: function triggerOnChangeForDirtyPaths(dirtyPaths) {
      if (dirtyPaths.visibleRecordIds) {
        this._onChange(WatchableViewDataStoreKeys.visibleRecords);
        this._onChange(WatchableViewDataStoreKeys.visibleRecordIds);
      }
      if (dirtyPaths.fieldOrder) {
        this._onChange(WatchableViewDataStoreKeys.allFieldIds);
        // TODO(kasra): only trigger visibleFields if the *visible* field ids changed.
        this._onChange(WatchableViewDataStoreKeys.visibleFieldIds);
      }
      // Technically it's possible for groupLevels changing to cause a groups
      // change since we derive group information from the groupLevels (fieldId)
      if (dirtyPaths.groups || dirtyPaths.groupLevels) {
        this._onChange(WatchableViewDataStoreKeys.groups);
      }
      if (dirtyPaths.groupLevels) {
        this._onChange(WatchableViewDataStoreKeys.groupLevels);
      }
      if (dirtyPaths.colorsByRecordId) {
        var changedRecordIds = dirtyPaths.colorsByRecordId._isDirty ? null : Object.keys(dirtyPaths.colorsByRecordId);
        if (changedRecordIds) {
          // Checking isRecordMetadataLoaded fixes a timing issue:
          // When a new table loads in liveapp, we'll receive the record
          // colors before getting the response to our loadData call.
          // This is a temporary fix: we need a more general solution to
          // avoid processing events associated with subscriptions whose
          // data we haven't received yet.
          if (this.parentRecordStore.isRecordMetadataLoaded) {
            var _iterator3 = _createForOfIteratorHelper(changedRecordIds),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var recordId = _step3.value;
                var record = this.parentRecordStore.getRecordByIdIfExists(recordId);
                // Similar to above, we could be receiving the change notification
                // for a record color before receiving the new record itself.
                if (record) {
                  record.__triggerOnChangeForRecordColorInViewId(this.viewId);
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        }
        this._onChange(WatchableViewDataStoreKeys.recordColors, changedRecordIds);
      }
    }
  }], [{
    key: "_isWatchableKey",
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableViewDataStoreKeys, key);
    }
  }, {
    key: "_shouldLoadDataForKey",
    value: function _shouldLoadDataForKey(key) {
      return true;
    }
  }]);
}(_abstract_model_with_async_data.default);
/** @internal */
(0, _defineProperty2.default)(ViewDataStore, "_className", 'ViewDataStore');
var _default = exports.default = ViewDataStore;