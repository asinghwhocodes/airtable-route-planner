"use strict";

require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.get-own-property-descriptors.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.WatchableTableKeys = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.array.includes.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.object.from-entries.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.string.includes.js");
require("core-js/modules/web.dom-collections.for-each.js");
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _mutations = require("../types/mutations");
var _private_utils = require("../private_utils");
var _error_utils = require("../error_utils");
var _abstract_model = _interopRequireDefault(require("./abstract_model"));
var _view = _interopRequireDefault(require("./view"));
var _field = _interopRequireDefault(require("./field"));
var _object_pool = _interopRequireDefault(require("./object_pool"));
var _record_query_result = _interopRequireDefault(require("./record_query_result"));
var _table_or_view_query_result = _interopRequireDefault(require("./table_or_view_query_result"));
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks/models: Table */ /** */
// This doesn't follow our enum naming conventions because we want the keys
// to mirror the method/getter names on the model class.
var WatchableTableKeys = exports.WatchableTableKeys = Object.freeze({
  name: 'name',
  description: 'description',
  views: 'views',
  fields: 'fields'
});

/**
 * A key in {@link Table} that can be watched.
 * - `name`
 * - `description`
 * - `views`
 * - `fields`
 */
/**
 * Model class representing a table. Every {@link Base} has one or more tables.
 *
 * @docsPath models/Table
 */
var Table = /*#__PURE__*/function (_AbstractModel) {
  /**
   * @internal
   */
  function Table(parentBase, recordStore, tableId, sdk) {
    var _this;
    (0, _classCallCheck2.default)(this, Table);
    _this = _callSuper(this, Table, [sdk, tableId]);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_parentBase", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_viewModelsById", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_fieldModelsById", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_cachedFieldNamesById", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_recordStore", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "__tableOrViewQueryResultPool", void 0);
    _this._parentBase = parentBase;
    _this._recordStore = recordStore;
    _this._viewModelsById = {}; // View instances are lazily created by getViewById.
    _this._fieldModelsById = {}; // Field instances are lazily created by getFieldById.
    _this._cachedFieldNamesById = null;
    _this.__tableOrViewQueryResultPool = new _object_pool.default(_table_or_view_query_result.default);
    return _this;
  }

  /**
   * @internal
   */
  (0, _inherits2.default)(Table, _AbstractModel);
  return (0, _createClass2.default)(Table, [{
    key: "_dataOrNullIfDeleted",
    get: function get() {
      var _this$_baseData$table;
      return (_this$_baseData$table = this._baseData.tablesById[this._id]) !== null && _this$_baseData$table !== void 0 ? _this$_baseData$table : null;
    }
    /**
     * The base that this table belongs to.
     *
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * const table = base.getTableByName('Table 1');
     * console.log(table.parentBase.id === base.id);
     * // => true
     * ```
     */
  }, {
    key: "parentBase",
    get: function get() {
      return this._parentBase;
    }
    /**
     * The name of the table. Can be watched.
     *
     * @example
     * ```js
     * console.log(myTable.name);
     * // => 'Table 1'
     * ```
     */
  }, {
    key: "name",
    get: function get() {
      return this._data.name;
    }
    /**
     * The description of the table, if it has one. Can be watched.
     *
     * @example
     * ```js
     * console.log(myTable.description);
     * // => 'This is my table'
     * ```
     */
  }, {
    key: "description",
    get: function get() {
      return this._data.description;
    }
    /**
     * The URL for the table. You can visit this URL in the browser to be taken to the table in the Airtable UI.
     *
     * @example
     * ```js
     * console.log(myTable.url);
     * // => 'https://airtable.com/appxxxxxxxxxxxxxx/tblxxxxxxxxxxxxxx'
     * ```
     */
  }, {
    key: "url",
    get: function get() {
      return this._sdk.__airtableInterface.urlConstructor.getTableUrl(this.id);
    }
    /**
     * The table's primary field. Every table has exactly one primary
     * field. The primary field of a table will not change.
     *
     * @example
     * ```js
     * console.log(myTable.primaryField.name);
     * // => 'Name'
     * ```
     */
  }, {
    key: "primaryField",
    get: function get() {
      var primaryField = this.getFieldById(this._data.primaryFieldId);
      return primaryField;
    }
    /**
     * The fields in this table. The order is arbitrary, since fields are
     * only ordered in the context of a specific view.
     *
     * Can be watched to know when fields are created or deleted.
     *
     * @example
     * ```js
     * console.log(`This table has ${myTable.fields.length} fields`);
     * ```
     */
  }, {
    key: "fields",
    get: function get() {
      // TODO(kasra): is it confusing that this returns an array, since the order
      // is arbitrary?
      // TODO(kasra): cache and freeze this so it isn't O(n)
      var fields = [];
      for (var _i = 0, _Object$keys = Object.keys(this._data.fieldsById); _i < _Object$keys.length; _i++) {
        var fieldId = _Object$keys[_i];
        var field = this.getFieldById(fieldId);
        fields.push(field);
      }
      return fields;
    }
    /**
     * Gets the field matching the given ID, or `null` if that field does not exist in this table.
      * @param fieldId The ID of the field.
     * @example
     * ```js
     * const fieldId = 'fldxxxxxxxxxxxxxx';
     * const field = myTable.getFieldByIdIfExists(fieldId);
     * if (field !== null) {
     *     console.log(field.name);
     * } else {
     *     console.log('No field exists with that ID');
     * }
     * ```
     */
  }, {
    key: "getFieldByIdIfExists",
    value: function getFieldByIdIfExists(fieldId) {
      if (!this._data.fieldsById[fieldId]) {
        return null;
      } else {
        if (!this._fieldModelsById[fieldId]) {
          this._fieldModelsById[fieldId] = new _field.default(this._sdk, this, fieldId);
        }
        return this._fieldModelsById[fieldId];
      }
    }
    /**
     * Gets the field matching the given ID. Throws if that field does not exist in this table. Use
     * {@link getFieldByIdIfExists} instead if you are unsure whether a field exists with the given
     * ID.
     *
     * @param fieldId The ID of the field.
     * @example
     * ```js
     * const fieldId = 'fldxxxxxxxxxxxxxx';
     * const field = myTable.getFieldById(fieldId);
     * console.log(field.name);
     * // => 'Name'
     * ```
     */
  }, {
    key: "getFieldById",
    value: function getFieldById(fieldId) {
      var field = this.getFieldByIdIfExists(fieldId);
      if (!field) {
        throw (0, _error_utils.spawnError)("No field with ID %s in table '%s'", fieldId, this.name);
      }
      return field;
    }
    /**
     * Gets the field matching the given name, or `null` if no field exists with that name in this
     * table.
     *
     * @param fieldName The name of the field you're looking for.
     * @example
     * ```js
     * const field = myTable.getFieldByNameIfExists('Name');
     * if (field !== null) {
     *     console.log(field.id);
     * } else {
     *     console.log('No field exists with that name');
     * }
     * ```
     */
  }, {
    key: "getFieldByNameIfExists",
    value: function getFieldByNameIfExists(fieldName) {
      var _iterator = _createForOfIteratorHelper((0, _private_utils.entries)(this._data.fieldsById)),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
            fieldId = _step$value[0],
            fieldData = _step$value[1];
          if (fieldData.name === fieldName) {
            return this.getFieldByIdIfExists(fieldId);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return null;
    }
    /**
     * Gets the field matching the given name. Throws if no field exists with that name in this
     * table. Use {@link getFieldByNameIfExists} instead if you are unsure whether a field exists
     * with the given name.
     *
     * @param fieldName The name of the field you're looking for.
     * @example
     * ```js
     * const field = myTable.getFieldByName('Name');
     * console.log(field.id);
     * // => 'fldxxxxxxxxxxxxxx'
     * ```
     */
  }, {
    key: "getFieldByName",
    value: function getFieldByName(fieldName) {
      var field = this.getFieldByNameIfExists(fieldName);
      if (!field) {
        throw (0, _error_utils.spawnError)("No field named '%s' in table '%s'", fieldName, this.name);
      }
      return field;
    }
    /**
     * The field matching the given ID or name. Returns `null` if no matching field exists within
     * this table.
     *
     * This method is convenient when building an extension for a specific base, but for more generic
     * extensions the best practice is to use the {@link getFieldByIdIfExists} or
     * {@link getFieldByNameIfExists} methods instead.
     *
     * @param fieldIdOrName The ID or name of the field you're looking for.
     */
  }, {
    key: "getFieldIfExists",
    value: function getFieldIfExists(fieldIdOrName) {
      var _this$getFieldByIdIfE;
      return (_this$getFieldByIdIfE = this.getFieldByIdIfExists(fieldIdOrName)) !== null && _this$getFieldByIdIfE !== void 0 ? _this$getFieldByIdIfE : this.getFieldByNameIfExists(fieldIdOrName);
    }
    /**
     * The field matching the given ID or name. Throws if no matching field exists within this table.
     * Use {@link getFieldIfExists} instead if you are unsure whether a field exists with the given
     * name/ID.
     *
     * This method is convenient when building an extension for a specific base, but for more generic
     * extensions the best practice is to use the {@link getFieldById} or {@link getFieldByName} methods
     * instead.
     *
     * @param fieldIdOrName The ID or name of the field you're looking for.
     */
  }, {
    key: "getField",
    value: function getField(fieldIdOrName) {
      var field = this.getFieldIfExists(fieldIdOrName);
      if (!field) {
        throw (0, _error_utils.spawnError)("No field with ID or name '%s' in table '%s'", fieldIdOrName, this.name);
      }
      return field;
    }
    /**
     * The views in this table. Can be watched to know when views are created,
     * deleted, or reordered.
     *
     * @example
     * ```js
     * console.log(`This table has ${myTable.views.length} views`);
     * ```
     */
  }, {
    key: "views",
    get: function get() {
      // TODO(kasra): cache and freeze this so it isn't O(n)
      var views = [];
      this._data.viewOrder.forEach(viewId => {
        var view = this.getViewById(viewId);
        views.push(view);
      });
      return views;
    }
    /**
     * Gets the view matching the given ID, or `null` if that view does not exist in this table.
     *
     * @param viewId The ID of the view.
     * @example
     * ```js
     * const viewId = 'viwxxxxxxxxxxxxxx';
     * const view = myTable.getViewByIdIfExists(viewId);
     * if (view !== null) {
     *     console.log(view.name);
     * } else {
     *     console.log('No view exists with that ID');
     * }
     * ```
     */
  }, {
    key: "getViewByIdIfExists",
    value: function getViewByIdIfExists(viewId) {
      if (!this._data.viewsById[viewId]) {
        return null;
      } else {
        if (!this._viewModelsById[viewId]) {
          this._viewModelsById[viewId] = new _view.default(this._sdk, this, this._recordStore.getViewDataStore(viewId), viewId);
        }
        return this._viewModelsById[viewId];
      }
    }
    /**
     * Gets the view matching the given ID. Throws if that view does not exist in this table. Use
     * {@link getViewByIdIfExists} instead if you are unsure whether a view exists with the given
     * ID.
     *
     * @param viewId The ID of the view.
     * @example
     * ```js
     * const viewId = 'viwxxxxxxxxxxxxxx';
     * const view = myTable.getViewById(viewId);
     * console.log(view.name);
     * // => 'Grid view'
     * ```
     */
  }, {
    key: "getViewById",
    value: function getViewById(viewId) {
      var view = this.getViewByIdIfExists(viewId);
      if (!view) {
        throw (0, _error_utils.spawnError)("No view with ID %s in table '%s'", viewId, this.name);
      }
      return view;
    }
    /**
     * Gets the view matching the given name, or `null` if no view exists with that name in this
     * table.
     *
     * @param viewName The name of the view you're looking for.
     * @example
     * ```js
     * const view = myTable.getViewByNameIfExists('Name');
     * if (view !== null) {
     *     console.log(view.id);
     * } else {
     *     console.log('No view exists with that name');
     * }
     * ```
     */
  }, {
    key: "getViewByNameIfExists",
    value: function getViewByNameIfExists(viewName) {
      var _iterator2 = _createForOfIteratorHelper((0, _private_utils.entries)(this._data.viewsById)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
            viewId = _step2$value[0],
            viewData = _step2$value[1];
          if (viewData.name === viewName) {
            return this.getViewByIdIfExists(viewId);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return null;
    }
    /**
     * Gets the view matching the given name. Throws if no view exists with that name in this table.
     * Use {@link getViewByNameIfExists} instead if you are unsure whether a view exists with the
     * given name.
     *
     * @param viewName The name of the view you're looking for.
     * @example
     * ```js
     * const view = myTable.getViewByName('Name');
     * console.log(view.id);
     * // => 'viwxxxxxxxxxxxxxx'
     * ```
     */
  }, {
    key: "getViewByName",
    value: function getViewByName(viewName) {
      var view = this.getViewByNameIfExists(viewName);
      if (!view) {
        throw (0, _error_utils.spawnError)("No view named '%s' in table '%s'", viewName, this.name);
      }
      return view;
    }
    /**
     * The view matching the given ID or name. Returns `null` if no matching view exists within
     * this table.
     *
     * This method is convenient when building an extension for a specific base, but for more generic
     * extensions the best practice is to use the {@link getViewByIdIfExists} or
     * {@link getViewByNameIfExists} methods instead.
     *
     * @param viewIdOrName The ID or name of the view you're looking for.
     */
  }, {
    key: "getViewIfExists",
    value: function getViewIfExists(viewIdOrName) {
      var _this$getViewByIdIfEx;
      return (_this$getViewByIdIfEx = this.getViewByIdIfExists(viewIdOrName)) !== null && _this$getViewByIdIfEx !== void 0 ? _this$getViewByIdIfEx : this.getViewByNameIfExists(viewIdOrName);
    }
    /**
     * The view matching the given ID or name. Throws if no matching view exists within this table.
     * Use {@link getViewIfExists} instead if you are unsure whether a view exists with the given
     * name/ID.
     *
     * This method is convenient when building an extension for a specific base, but for more generic
     * extensions the best practice is to use the {@link getViewById} or {@link getViewByName} methods
     * instead.
     *
     * @param viewIdOrName The ID or name of the view you're looking for.
     */
  }, {
    key: "getView",
    value: function getView(viewIdOrName) {
      var view = this.getViewIfExists(viewIdOrName);
      if (!view) {
        throw (0, _error_utils.spawnError)("No view with ID or name '%s' in table '%s'", viewIdOrName, this.name);
      }
      return view;
    }
    /**
     * Select records from the table. Returns a {@link RecordQueryResult}.
     *
     * Consider using {@link useRecords} or {@link useRecordIds} instead, unless you need the
     * features of a QueryResult (e.g. `queryResult.getRecordById`). Record hooks handle
     * loading/unloading and updating your UI automatically, but manually `select`ing records is
     * useful for one-off data processing.
     *
     * @param opts Options for the query, such as sorts and fields.
     * @example
     * ```js
     * import {useBase, useRecords} from '@airtable/blocks/ui';
     * import React from 'react';
     *
     * function TodoList() {
     *     const base = useBase();
     *     const table = base.getTableByName('Tasks');
     *
     *     const queryResult = table.selectRecords();
     *     const records = useRecords(queryResult);
     *
     *     return (
     *         <ul>
     *             {records.map(record => (
     *                 <li key={record.id}>
     *                     {record.name || 'Unnamed record'}
     *                 </li>
     *             ))}
     *         </ul>
     *     );
     * }
     * ```
     */
  }, {
    key: "selectRecords",
    value: function selectRecords(opts) {
      var normalizedOpts = _record_query_result.default._normalizeOpts(this, this._recordStore, opts || {});
      return this.__tableOrViewQueryResultPool.getObjectForReuse(this._sdk, this, normalizedOpts);
    }
    /**
     * Select and load records from the table. Returns a {@link RecordQueryResult} promise where
     * record data has been loaded.
     *
     * Consider using {@link useRecords} or {@link useRecordIds} instead, unless you need the
     * features of a QueryResult (e.g. `queryResult.getRecordById`). Record hooks handle
     * loading/unloading and updating your UI automatically, but manually `select`ing records is
     * useful for one-off data processing.
     *
     * Once you've finished with your query, remember to call `queryResult.unloadData()`.
     *
     * @param opts Options for the query, such as sorts and fields.
     * @example
     * ```js
     * async function logRecordCountAsync(table) {
     *     const query = await table.selectRecordsAsync();
     *     console.log(query.recordIds.length);
     *     query.unloadData();
     * }
     * ```
     */
  }, {
    key: "selectRecordsAsync",
    value: (function () {
      var _selectRecordsAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(opts) {
        var queryResult;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              queryResult = this.selectRecords(opts);
              _context.next = 3;
              return queryResult.loadDataAsync();
            case 3:
              return _context.abrupt("return", queryResult);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function selectRecordsAsync(_x) {
        return _selectRecordsAsync.apply(this, arguments);
      }
      return selectRecordsAsync;
    }()
    /**
     * Returns the first view in the table where the type is one of `allowedViewTypes`, or `null` if
     * no such view exists in the table.
     *
     * @param allowedViewTypes An array of view types or a single view type to match against.
     * @param preferredViewOrViewId If a view or view ID is supplied and that view exists & has the
     * correct type, that view will be returned before checking the other views in the table.
     * @example
     * ```js
     * import {ViewType} from '@airtable/blocks/models';
     * const firstCalendarView = myTable.getFirstViewOfType(ViewType.CALENDAR);
     * if (firstCalendarView !== null) {
     *     console.log(firstCalendarView.name);
     * } else {
     *     console.log('No calendar views exist in the table');
     * }
     * ```
     */
    )
  }, {
    key: "getFirstViewOfType",
    value: function getFirstViewOfType(allowedViewTypes, preferredViewOrViewId) {
      var _this$views$find;
      if (!Array.isArray(allowedViewTypes)) {
        allowedViewTypes = (0, _private_utils.cast)([allowedViewTypes]);
      }
      if (preferredViewOrViewId) {
        var preferredView = this.getViewByIdIfExists(typeof preferredViewOrViewId === 'string' ? preferredViewOrViewId : preferredViewOrViewId.id);
        if (preferredView && allowedViewTypes.includes(preferredView.type)) {
          return preferredView;
        }
      }
      return (_this$views$find = this.views.find(view => {
        return allowedViewTypes.includes(view.type);
      })) !== null && _this$views$find !== void 0 ? _this$views$find : null;
    }
    // Experimental, do not document yet. Allows fetching default cell values for
    // a table or view. Before documenting, we should explore making this synchronous.
    /**
     * @internal
     */
    // istanbul ignore next
  }, {
    key: "getDefaultCellValuesByFieldIdAsync",
    value: function () {
      var _getDefaultCellValuesByFieldIdAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(opts) {
        var viewId, cellValuesByFieldId;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              viewId = opts && opts.view ? opts.view.id : null;
              _context2.next = 3;
              return this._sdk.__airtableInterface.fetchDefaultCellValuesByFieldIdAsync(this._id, viewId);
            case 3:
              cellValuesByFieldId = _context2.sent;
              return _context2.abrupt("return", cellValuesByFieldId);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getDefaultCellValuesByFieldIdAsync(_x2) {
        return _getDefaultCellValuesByFieldIdAsync.apply(this, arguments);
      }
      return getDefaultCellValuesByFieldIdAsync;
    }()
    /**
     * Updates cell values for a record.
     *
     * Throws an error if the user does not have permission to update the given cell values in
     * the record, or if invalid input is provided (eg. invalid cell values).
     *
     * Refer to {@link FieldType} for cell value write formats.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the updated
     * cell values to be persisted to Airtable servers.
     * Updates are applied optimistically locally, so your changes will be reflected in your extension
     * before the promise resolves.
     *
     * @param recordOrRecordId the record to update
     * @param fields cell values to update in that record, specified as object mapping `FieldId` or field name to value for that field.
     * @example
     * ```js
     * function updateRecord(record, recordFields) {
     *     if (table.hasPermissionToUpdateRecord(record, recordFields)) {
     *         table.updateRecordAsync(record, recordFields);
     *     }
     *     // The updated values will now show in your extension (eg in
     *     // `table.selectRecords()` result) but are still being saved to Airtable
     *     // servers (e.g. other users may not be able to see them yet).
     * }
     *
     * async function updateRecordAsync(record, recordFields) {
     *     if (table.hasPermissionToUpdateRecord(record, recordFields)) {
     *         await table.updateRecordAsync(record, recordFields);
     *     }
     *     // New record has been saved to Airtable servers.
     *     alert(`record with ID ${record.id} has been updated`);
     * }
     *
     * // Fields can be specified by name or ID
     * updateRecord(record1, {
     *     'Post Title': 'How to make: orange-mango pound cake',
     *     'Publication Date': '2020-01-01',
     * });
     * updateRecord(record2, {
     *     [postTitleField.id]: 'Cake decorating tips & tricks',
     *     [publicationDateField.id]: '2020-02-02',
     * });
     *
     * // Cell values should generally have format matching the output of
     * // record.getCellValue() for the field being updated
     * updateRecord(record1, {
     *     'Category (single select)': {name: 'Recipe'},
     *     'Tags (multiple select)': [{name: 'Desserts'}, {id: 'someChoiceId'}],
     *     'Images (attachment)': [{url: 'http://mywebsite.com/cake.png'}],
     *     'Related posts (linked records)': [{id: 'someRecordId'}],
     * });
     * ```
     */
  }, {
    key: "updateRecordAsync",
    value: (function () {
      var _updateRecordAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(recordOrRecordId, fields) {
        var recordId;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              recordId = typeof recordOrRecordId === 'string' ? recordOrRecordId : recordOrRecordId.id;
              _context3.next = 3;
              return this.updateRecordsAsync([{
                id: recordId,
                fields
              }]);
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateRecordAsync(_x3, _x4) {
        return _updateRecordAsync.apply(this, arguments);
      }
      return updateRecordAsync;
    }()
    /**
     * Checks whether the current user has permission to perform the given record update.
     *
     * Accepts partial input, in the same format as {@link updateRecordAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can update the specified record,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param recordOrRecordId the record to update
     * @param fields cell values to update in that record, specified as object mapping `FieldId` or field name to value for that field.
     * @example
     * ```js
     * // Check if user can update specific fields for a specific record.
     * const updateRecordCheckResult =
     *     table.checkPermissionsForUpdateRecord(record, {
     *         'Post Title': 'How to make: orange-mango pound cake',
     *         'Publication Date': '2020-01-01',
     *     });
     * if (!updateRecordCheckResult.hasPermission) {
     *     alert(updateRecordCheckResult.reasonDisplayString);
     * }
     *
     * // Like updateRecordAsync, you can use either field names or field IDs.
     * const updateRecordCheckResultWithFieldIds =
     *     table.checkPermissionsForUpdateRecord(record, {
     *         [postTitleField.id]: 'Cake decorating tips & tricks',
     *         [publicationDateField.id]: '2020-02-02',
     *     });
     *
     * // Check if user could update a given record, when you don't know the
     * // specific fields that will be updated yet (e.g. to check whether you should
     * // allow a user to select a certain record to update).
     * const updateUnknownFieldsCheckResult =
     *     table.checkPermissionsForUpdateRecord(record);
     *
     * // Check if user could update specific fields, when you don't know the
     * // specific record that will be updated yet. (for example, if the field is
     * // selected by the user and you want to check if your extension can write to it).
     * const updateUnknownRecordCheckResult =
     *     table.checkPermissionsForUpdateRecord(undefined, {
     *         'My field name': 'updated value',
     *         // You can use undefined if you know you're going to update a field,
     *         // but don't know the new cell value yet.
     *         'Another field name': undefined,
     *     });
     *
     * // Check if user could perform updates within the table, without knowing the
     * // specific record or fields that will be updated yet (e.g., to render your
     * // extension in "read only" mode).
     * const updateUnknownRecordAndFieldsCheckResult =
     *     table.checkPermissionsForUpdateRecord();
     * ```
     */
    )
  }, {
    key: "checkPermissionsForUpdateRecord",
    value: function checkPermissionsForUpdateRecord(recordOrRecordId, fields) {
      var recordId = typeof recordOrRecordId === 'object' && recordOrRecordId !== null ? recordOrRecordId.id : recordOrRecordId;
      return this.checkPermissionsForUpdateRecords([{
        id: recordId,
        fields
      }]);
    }
    /**
     * An alias for `checkPermissionsForUpdateRecord(recordOrRecordId, fields).hasPermission`.
     *
     * Checks whether the current user has permission to perform the given record update.
     *
     * Accepts partial input, in the same format as {@link updateRecordAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param recordOrRecordId the record to update
     * @param fields cell values to update in that record, specified as object mapping `FieldId` or field name to value for that field.
     * @example
     * ```js
     * // Check if user can update specific fields for a specific record.
     * const canUpdateRecord = table.hasPermissionToUpdateRecord(record, {
     *     'Post Title': 'How to make: orange-mango pound cake',
     *     'Publication Date': '2020-01-01',
     * });
     * if (!canUpdateRecord) {
     *     alert('not allowed!');
     * }
     *
     * // Like updateRecordAsync, you can use either field names or field IDs.
     * const canUpdateRecordWithFieldIds =
     *     table.hasPermissionToUpdateRecord(record, {
     *         [postTitleField.id]: 'Cake decorating tips & tricks',
     *         [publicationDateField.id]: '2020-02-02',
     *     });
     *
     * // Check if user could update a given record, when you don't know the
     * // specific fields that will be updated yet (e.g. to check whether you should
     * // allow a user to select a certain record to update).
     * const canUpdateUnknownFields = table.hasPermissionToUpdateRecord(record);
     *
     * // Check if user could update specific fields, when you don't know the
     * // specific record that will be updated yet (e.g. if the field is selected
     * // by the user and you want to check if your extension can write to it).
     * const canUpdateUnknownRecord =
     *     table.hasPermissionToUpdateRecord(undefined, {
     *         'My field name': 'updated value',
     *         // You can use undefined if you know you're going to update a field,
     *         // but don't know the new cell value yet.
     *         'Another field name': undefined,
     *     });
     *
     * // Check if user could perform updates within the table, without knowing the
     * // specific record or fields that will be updated yet. (for example, to
     * // render your extension in "read only" mode)
     * const canUpdateUnknownRecordAndFields = table.hasPermissionToUpdateRecord();
     * ```
     */
  }, {
    key: "hasPermissionToUpdateRecord",
    value: function hasPermissionToUpdateRecord(recordOrRecordId, fields) {
      return this.checkPermissionsForUpdateRecord(recordOrRecordId, fields).hasPermission;
    }
    /**
     * Updates cell values for records.
     *
     * Throws an error if the user does not have permission to update the given cell values in
     * the records, or if invalid input is provided (eg. invalid cell values).
     *
     * Refer to {@link FieldType} for cell value write formats.
     *
     * You may only update up to 50 records in one call to `updateRecordsAsync`.
     * See [Write back to Airtable](/guides/write-back-to-airtable) for more information
     * about write limits.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the
     * updates to be persisted to Airtable servers.
     * Updates are applied optimistically locally, so your changes will be reflected in your extension
     * before the promise resolves.
     *
     * @param records Array of objects containing recordId and fields/cellValues to update for that record (specified as an object mapping `FieldId` or field name to cell value)
     * @example
     * ```js
     * const recordsToUpdate = [
     *     // Fields can be specified by name or ID
     *     {
     *         id: record1.id,
     *         fields: {
     *             'Post Title': 'How to make: orange-mango pound cake',
     *             'Publication Date': '2020-01-01',
     *         },
     *     },
     *     {
     *         id: record2.id,
     *         fields: {
     *             // Sets the cell values to be empty.
     *             'Post Title': '',
     *             'Publication Date': '',
     *         },
     *     },
     *     {
     *         id: record3.id,
     *         fields: {
     *             [postTitleField.id]: 'Cake decorating tips & tricks',
     *             [publicationDateField.id]: '2020-02-02',
     *         },
     *     },
     *     // Cell values should generally have format matching the output of
     *     // record.getCellValue() for the field being updated
     *     {
     *         id: record4.id,
     *         fields: {
     *             'Category (single select)': {name: 'Recipe'},
     *             'Tags (multiple select)': [{name: 'Desserts'}, {id: 'choiceId'}],
     *             'Images (attachment)': [{url: 'http://mywebsite.com/cake.png'}],
     *             'Related posts (linked records)': [{id: 'someRecordId'}],
     *         },
     *     },
     * ];
     *
     * function updateRecords() {
     *     if (table.hasPermissionToUpdateRecords(recordsToUpdate)) {
     *         table.updateRecordsAsync(recordsToUpdate);
     *     }
     *     // The records are now updated within your extension (eg will be reflected in
     *     // `table.selectRecords()`) but are still being saved to Airtable servers
     *     // (e.g. they may not be updated for other users yet).
     * }
     *
     * async function updateRecordsAsync() {
     *     if (table.hasPermissionToUpdateRecords(recordsToUpdate)) {
     *         await table.updateRecordsAsync(recordsToUpdate);
     *     }
     *     // Record updates have been saved to Airtable servers.
     *     alert('records have been updated');
     * }
     * ```
     */
  }, {
    key: "updateRecordsAsync",
    value: (function () {
      var _updateRecordsAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(records) {
        var recordsWithCellValuesByFieldId;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              recordsWithCellValuesByFieldId = records.map(record => ({
                id: record.id,
                cellValuesByFieldId: this._cellValuesByFieldIdOrNameToCellValuesByFieldId(record.fields)
              }));
              _context4.next = 3;
              return this._sdk.__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES,
                tableId: this.id,
                records: recordsWithCellValuesByFieldId,
                opts: {
                  parseDateCellValueInColumnTimeZone: true
                }
              });
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function updateRecordsAsync(_x5) {
        return _updateRecordsAsync.apply(this, arguments);
      }
      return updateRecordsAsync;
    }()
    /**
     * Checks whether the current user has permission to perform the given record updates.
     *
     * Accepts partial input, in the same format as {@link updateRecordsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can update the specified records,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param records Array of objects containing recordId and fields/cellValues to update for that record (specified as an object mapping `FieldId` or field name to cell value)
     * @example
     * ```js
     * const recordsToUpdate = [
     *     {
     *         // Validating a complete record update
     *         id: record1.id,
     *         fields: {
     *             'Post Title': 'How to make: orange-mango pound cake',
     *             'Publication Date': '2020-01-01',
     *         },
     *     },
     *     {
     *         // Like updateRecordsAsync, fields can be specified by name or ID
     *         id: record2.id,
     *         fields: {
     *             [postTitleField.id]: 'Cake decorating tips & tricks',
     *             [publicationDateField.id]: '2020-02-02',
     *         },
     *     },
     *     {
     *         // Validating an update to a specific record, not knowing what
     *         // fields will be updated
     *         id: record3.id,
     *     },
     *     {
     *         // Validating an update to specific cell values, not knowing what
     *         // record will be updated
     *         fields: {
     *             'My field name': 'updated value for unknown record',
     *             // You can use undefined if you know you're going to update a
     *             // field, but don't know the new cell value yet.
     *             'Another field name': undefined,
     *         },
     *     },
     * ];
     *
     * const updateRecordsCheckResult =
     *     table.checkPermissionsForUpdateRecords(recordsToUpdate);
     * if (!updateRecordsCheckResult.hasPermission) {
     *     alert(updateRecordsCheckResult.reasonDisplayString);
     * }
     *
     * // Check if user could potentially update records.
     * // Equivalent to table.checkPermissionsForUpdateRecord()
     * const updateUnknownRecordAndFieldsCheckResult =
     *     table.checkPermissionsForUpdateRecords();
     * ```
     */
    )
  }, {
    key: "checkPermissionsForUpdateRecords",
    value: function checkPermissionsForUpdateRecords(records) {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.SET_MULTIPLE_RECORDS_CELL_VALUES,
        tableId: this.id,
        records: records ? records.map(record => ({
          id: record.id || undefined,
          cellValuesByFieldId: record.fields ? this._cellValuesByFieldIdOrNameToCellValuesByFieldId(record.fields) : undefined
        })) : undefined
      });
    }
    /**
     * An alias for `checkPermissionsForUpdateRecords(records).hasPermission`.
     *
     * Checks whether the current user has permission to perform the given record updates.
     *
     * Accepts partial input, in the same format as {@link updateRecordsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param records Array of objects containing recordId and fields/cellValues to update for that record (specified as an object mapping `FieldId` or field name to cell value)
     * @example
     * ```js
     * const recordsToUpdate = [
     *     {
     *         // Validating a complete record update
     *         id: record1.id,
     *         fields: {
     *             'Post Title': 'How to make: orange-mango pound cake',
     *             'Publication Date': '2020-01-01',
     *         },
     *     },
     *     {
     *         // Like updateRecordsAsync, fields can be specified by name or ID
     *         id: record2.id,
     *         fields: {
     *             [postTitleField.id]: 'Cake decorating tips & tricks',
     *             [publicationDateField.id]: '2020-02-02',
     *         },
     *     },
     *     {
     *         // Validating an update to a specific record, not knowing what
     *         // fields will be updated
     *         id: record3.id,
     *     },
     *     {
     *         // Validating an update to specific cell values, not knowing what
     *         // record will be updated
     *         fields: {
     *             'My field name': 'updated value for unknown record',
     *             // You can use undefined if you know you're going to update a
     *             // field, but don't know the new cell value yet.
     *             'Another field name': undefined,
     *         },
     *     },
     * ];
     *
     * const canUpdateRecords = table.hasPermissionToUpdateRecords(recordsToUpdate);
     * if (!canUpdateRecords) {
     *     alert('not allowed');
     * }
     *
     * // Check if user could potentially update records.
     * // Equivalent to table.hasPermissionToUpdateRecord()
     * const canUpdateUnknownRecordsAndFields =
     *     table.hasPermissionToUpdateRecords();
     * ```
     */
  }, {
    key: "hasPermissionToUpdateRecords",
    value: function hasPermissionToUpdateRecords(records) {
      return this.checkPermissionsForUpdateRecords(records).hasPermission;
    }
    /**
     * Delete the given record.
     *
     * Throws an error if the user does not have permission to delete the given record.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the
     * delete to be persisted to Airtable servers.
     * Updates are applied optimistically locally, so your changes will be reflected in your extension
     * before the promise resolves.
     *
     * @param recordOrRecordId the record to be deleted
     * @example
     * ```js
     * function deleteRecord(record) {
     *     if (table.hasPermissionToDeleteRecord(record)) {
     *         table.deleteRecordAsync(record);
     *     }
     *     // The record is now deleted within your extension (eg will not be returned
     *     // in `table.selectRecords`) but it is still being saved to Airtable
     *     // servers (e.g. it may not look deleted to other users yet).
     * }
     *
     * async function deleteRecordAsync(record) {
     *     if (table.hasPermissionToDeleteRecord(record)) {
     *         await table.deleteRecordAsync(record);
     *     }
     *     // Record deletion has been saved to Airtable servers.
     *     alert('record has been deleted');
     * }
     * ```
     */
  }, {
    key: "deleteRecordAsync",
    value: (function () {
      var _deleteRecordAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(recordOrRecordId) {
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.deleteRecordsAsync([recordOrRecordId]);
            case 2:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function deleteRecordAsync(_x6) {
        return _deleteRecordAsync.apply(this, arguments);
      }
      return deleteRecordAsync;
    }()
    /**
     * Checks whether the current user has permission to delete the specified record.
     *
     * Accepts optional input, in the same format as {@link deleteRecordAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can delete the specified record,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param recordOrRecordId the record to be deleted
     * @example
     * ```js
     * // Check if user can delete a specific record
     * const deleteRecordCheckResult =
     *     table.checkPermissionsForDeleteRecord(record);
     * if (!deleteRecordCheckResult.hasPermission) {
     *     alert(deleteRecordCheckResult.reasonDisplayString);
     * }
     *
     * // Check if user could potentially delete a record.
     * // Use when you don't know the specific record you want to delete yet (for
     * // example, to show/hide UI controls that let you select a record to delete).
     * const deleteUnknownRecordCheckResult =
     *     table.checkPermissionsForDeleteRecord();
     * ```
     */
    )
  }, {
    key: "checkPermissionsForDeleteRecord",
    value: function checkPermissionsForDeleteRecord(recordOrRecordId) {
      return this.checkPermissionsForDeleteRecords(recordOrRecordId ? [recordOrRecordId] : undefined);
    }
    /**
     * An alias for `checkPermissionsForDeleteRecord(recordOrRecordId).hasPermission`.
     *
     * Checks whether the current user has permission to delete the specified record.
     *
     * Accepts optional input, in the same format as {@link deleteRecordAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param recordOrRecordId the record to be deleted
     * @example
     * ```js
     * // Check if user can delete a specific record
     * const canDeleteRecord = table.hasPermissionToDeleteRecord(record);
     * if (!canDeleteRecord) {
     *     alert('not allowed');
     * }
     *
     * // Check if user could potentially delete a record.
     * // Use when you don't know the specific record you want to delete yet (for
     * // example, to show/hide UI controls that let you select a record to delete).
     * const canDeleteUnknownRecord = table.hasPermissionToDeleteRecord();
     * ```
     */
  }, {
    key: "hasPermissionToDeleteRecord",
    value: function hasPermissionToDeleteRecord(recordOrRecordId) {
      return this.checkPermissionsForDeleteRecord(recordOrRecordId).hasPermission;
    }
    /**
     * Delete the given records.
     *
     * Throws an error if the user does not have permission to delete the given records.
     *
     * You may only delete up to 50 records in one call to `deleteRecordsAsync`.
     * See [Write back to Airtable](/guides/write-back-to-airtable#size-limits-rate-limits) for
     * more information about write limits.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the
     * delete to be persisted to Airtable servers.
     * Updates are applied optimistically locally, so your changes will be reflected in your extension
     * before the promise resolves.
     *
     * @param recordsOrRecordIds Array of Records and RecordIds
     * @example
     * ```js
     *
     * function deleteRecords(records) {
     *     if (table.hasPermissionToDeleteRecords(records)) {
     *         table.deleteRecordsAsync(records);
     *     }
     *     // The records are now deleted within your extension (eg will not be
     *     // returned in `table.selectRecords()`) but are still being saved to
     *     // Airtable servers (e.g. they may not look deleted to other users yet).
     * }
     *
     * async function deleteRecordsAsync(records) {
     *     if (table.hasPermissionToDeleteRecords(records)) {
     *         await table.deleteRecordsAsync(records);
     *     }
     *     // Record deletions have been saved to Airtable servers.
     *     alert('records have been deleted');
     * }
     * ```
     */
  }, {
    key: "deleteRecordsAsync",
    value: (function () {
      var _deleteRecordsAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(recordsOrRecordIds) {
        var recordIds;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              recordIds = recordsOrRecordIds.map(recordOrRecordId => typeof recordOrRecordId === 'string' ? recordOrRecordId : recordOrRecordId.id);
              _context6.next = 3;
              return this._sdk.__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS,
                tableId: this.id,
                recordIds
              });
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function deleteRecordsAsync(_x7) {
        return _deleteRecordsAsync.apply(this, arguments);
      }
      return deleteRecordsAsync;
    }()
    /**
     * Checks whether the current user has permission to delete the specified records.
     *
     * Accepts optional input, in the same format as {@link deleteRecordsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can delete the specified records,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param recordsOrRecordIds the records to be deleted
     * @example
     * ```js
     * // Check if user can delete specific records
     * const deleteRecordsCheckResult =
     *     table.checkPermissionsForDeleteRecords([record1, record2]);
     * if (!deleteRecordsCheckResult.hasPermission) {
     *     alert(deleteRecordsCheckResult.reasonDisplayString);
     * }
     *
     * // Check if user could potentially delete records.
     * // Use when you don't know the specific records you want to delete yet (for
     * // example, to show/hide UI controls that let you select records to delete).
     * // Equivalent to table.hasPermissionToDeleteRecord()
     * const deleteUnknownRecordsCheckResult =
     *     table.checkPermissionsForDeleteRecords();
     * ```
     */
    )
  }, {
    key: "checkPermissionsForDeleteRecords",
    value: function checkPermissionsForDeleteRecords(recordsOrRecordIds) {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.DELETE_MULTIPLE_RECORDS,
        tableId: this.id,
        recordIds: recordsOrRecordIds ? recordsOrRecordIds.map(recordOrRecordId => typeof recordOrRecordId === 'string' ? recordOrRecordId : recordOrRecordId.id) : undefined
      });
    }
    /**
     * An alias for `checkPermissionsForDeleteRecords(recordsOrRecordIds).hasPermission`.
     *
     * Checks whether the current user has permission to delete the specified records.
     *
     * Accepts optional input, in the same format as {@link deleteRecordsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param recordsOrRecordIds the records to be deleted
     * @example
     * ```js
     * // Check if user can delete specific records
     * const canDeleteRecords =
     *     table.hasPermissionToDeleteRecords([record1, record2]);
     * if (!canDeleteRecords) {
     *     alert('not allowed!');
     * }
     *
     * // Check if user could potentially delete records.
     * // Use when you don't know the specific records you want to delete yet (for
     * // example, to show/hide UI controls that let you select records to delete).
     * // Equivalent to table.hasPermissionToDeleteRecord()
     * const canDeleteUnknownRecords = table.hasPermissionToDeleteRecords();
     * ```
     */
  }, {
    key: "hasPermissionToDeleteRecords",
    value: function hasPermissionToDeleteRecords(recordsOrRecordIds) {
      return this.checkPermissionsForDeleteRecords(recordsOrRecordIds).hasPermission;
    }

    /**
     * Creates a new record with the specified cell values.
     *
     * Throws an error if the user does not have permission to create the given records, or
     * if invalid input is provided (eg. invalid cell values).
     *
     * Refer to {@link FieldType} for cell value write formats.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the new
     * record to be persisted to Airtable servers.
     * Updates are applied optimistically locally, so your changes will be reflected in your extension
     * before the promise resolves.
     *
     * The returned promise will resolve to the RecordId of the new record once it is persisted.
     *
     * @param fields object mapping `FieldId` or field name to value for that field.
     * @example
     * ```js
     * function createNewRecord(recordFields) {
     *     if (table.hasPermissionToCreateRecord(recordFields)) {
     *         table.createRecordAsync(recordFields);
     *     }
     *     // You can now access the new record in your extension (eg
     *     // `table.selectRecords()`) but it is still being saved to Airtable
     *     // servers (e.g. other users may not be able to see it yet).
     * }
     *
     * async function createNewRecordAsync(recordFields) {
     *     if (table.hasPermissionToCreateRecord(recordFields)) {
     *         const newRecordId = await table.createRecordAsync(recordFields);
     *     }
     *     // New record has been saved to Airtable servers.
     *     alert(`new record with ID ${newRecordId} has been created`);
     * }
     *
     * // Fields can be specified by name or ID
     * createNewRecord({
     *     'Project Name': 'Advertising campaign',
     *     'Budget': 100,
     * });
     * createNewRecord({
     *     [projectNameField.id]: 'Cat video',
     *     [budgetField.id]: 200,
     * });
     *
     * // Cell values should generally have format matching the output of
     * // record.getCellValue() for the field being updated
     * createNewRecord({
     *     'Project Name': 'Cat video 2'
     *     'Category (single select)': {name: 'Video'},
     *     'Tags (multiple select)': [{name: 'Cats'}, {id: 'someChoiceId'}],
     *     'Assets (attachment)': [{url: 'http://mywebsite.com/cats.mp4'}],
     *     'Related projects (linked records)': [{id: 'someRecordId'}],
     * });
     * ```
     */
  }, {
    key: "createRecordAsync",
    value: (function () {
      var _createRecordAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
        var fields,
          recordIds,
          _args7 = arguments;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              fields = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};
              _context7.next = 3;
              return this.createRecordsAsync([{
                fields
              }]);
            case 3:
              recordIds = _context7.sent;
              return _context7.abrupt("return", recordIds[0]);
            case 5:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function createRecordAsync() {
        return _createRecordAsync.apply(this, arguments);
      }
      return createRecordAsync;
    }()
    /**
     * Checks whether the current user has permission to create the specified record.
     *
     * Accepts partial input, in the same format as {@link createRecordAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can create the specified record,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param fields object mapping `FieldId` or field name to value for that field.
     * @example
     * ```js
     * // Check if user can create a specific record, when you already know what
     * // fields/cell values will be set for the record.
     * const createRecordCheckResult = table.checkPermissionsForCreateRecord({
     *     'Project Name': 'Advertising campaign',
     *     'Budget': 100,
     * });
     * if (!createRecordCheckResult.hasPermission) {
     *     alert(createRecordCheckResult.reasonDisplayString);
     * }
     *
     * // Like createRecordAsync, you can use either field names or field IDs.
     * const checkResultWithFieldIds = table.checkPermissionsForCreateRecord({
     *     [projectNameField.id]: 'Cat video',
     *     [budgetField.id]: 200,
     * });
     *
     * // Check if user could potentially create a record.
     * // Use when you don't know the specific fields/cell values yet (for example,
     * // to show or hide UI controls that let you start creating a record.)
     * const createUnknownRecordCheckResult =
     *     table.checkPermissionsForCreateRecord();
     * ```
     */
    )
  }, {
    key: "checkPermissionsForCreateRecord",
    value: function checkPermissionsForCreateRecord(fields) {
      return this.checkPermissionsForCreateRecords([{
        fields: fields || undefined
      }]);
    }
    /**
     * An alias for `checkPermissionsForCreateRecord(fields).hasPermission`.
     *
     * Checks whether the current user has permission to create the specified record.
     *
     * Accepts partial input, in the same format as {@link createRecordAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param fields object mapping `FieldId` or field name to value for that field.
     * @example
     * ```js
     * // Check if user can create a specific record, when you already know what
     * // fields/cell values will be set for the record.
     * const canCreateRecord = table.hasPermissionToCreateRecord({
     *     'Project Name': 'Advertising campaign',
     *     'Budget': 100,
     * });
     * if (!canCreateRecord) {
     *     alert('not allowed!');
     * }
     *
     * // Like createRecordAsync, you can use either field names or field IDs.
     * const canCreateRecordWithFieldIds = table.hasPermissionToCreateRecord({
     *     [projectNameField.id]: 'Cat video',
     *     [budgetField.id]: 200,
     * });
     *
     * // Check if user could potentially create a record.
     * // Use when you don't know the specific fields/cell values yet (for example,
     * // to show or hide UI controls that let you start creating a record.)
     * const canCreateUnknownRecord = table.hasPermissionToCreateRecord();
     * ```
     */
  }, {
    key: "hasPermissionToCreateRecord",
    value: function hasPermissionToCreateRecord(fields) {
      return this.checkPermissionsForCreateRecord(fields).hasPermission;
    }
    /**
     * Creates new records with the specified cell values.
     *
     * Throws an error if the user does not have permission to create the given records, or
     * if invalid input is provided (eg. invalid cell values).
     *
     * Refer to {@link FieldType} for cell value write formats.
     *
     * You may only create up to 50 records in one call to `createRecordsAsync`.
     * See [Write back to Airtable](/guides/write-back-to-airtable#size-limits-rate-limits) for
     * more information about write limits.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the new
     * record to be persisted to Airtable servers.
     * Updates are applied optimistically locally, so your changes will be reflected in your extension
     * before the promise resolves.
     *
     * The returned promise will resolve to an array of RecordIds of the new records once the new
     * records are persisted.
     *
     * @param records Array of objects with a `fields` key mapping `FieldId` or field name to value for that field.
     * @example
     * ```js
     * const recordDefs = [
     *     // Fields can be specified by name or ID
     *     {
     *          fields: {
     *              'Project Name': 'Advertising campaign',
     *              'Budget': 100,
     *          },
     *     },
     *     {
     *          fields: {
     *              [projectNameField.id]: 'Cat video',
     *              [budgetField.id]: 200,
     *          },
     *     },
     *     // Specifying no fields will create a new record with no cell values set
     *     {
     *          fields: {},
     *     },
     *     // Cell values should generally have format matching the output of
     *     // record.getCellValue() for the field being updated
     *     {
     *          fields: {
     *              'Project Name': 'Cat video 2'
     *              'Category (single select)': {name: 'Video'},
     *              'Tags (multiple select)': [{name: 'Cats'}, {id: 'choiceId'}],
     *              'Assets (attachment)': [{url: 'http://mywebsite.com/cats.mp4'}],
     *              'Related projects (linked records)': [{id: 'someRecordId'}],
     *          },
     *     },
     * ];
     *
     * function createNewRecords() {
     *     if (table.hasPermissionToCreateRecords(recordDefs)) {
     *         table.createRecordsAsync(recordDefs);
     *     }
     *     // You can now access the new records in your extension (e.g.
     *     // `table.selectRecords()`) but they are still being saved to Airtable
     *     // servers (e.g. other users may not be able to see them yet.)
     * }
     *
     * async function createNewRecordsAsync() {
     *     if (table.hasPermissionToCreateRecords(recordDefs)) {
     *         const newRecordIds = await table.createRecordsAsync(recordDefs);
     *     }
     *     // New records have been saved to Airtable servers.
     *     alert(`new records with IDs ${newRecordIds} have been created`);
     * }
     * ```
     */
  }, {
    key: "createRecordsAsync",
    value: (function () {
      var _createRecordsAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(records) {
        var recordsToCreate;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              recordsToCreate = records.map(recordDef => {
                var recordDefKeys = (0, _private_utils.keys)(recordDef);
                var fields;
                if (recordDefKeys.length === 1 && recordDefKeys[0] === 'fields') {
                  fields = recordDef.fields;
                } else {
                  throw (0, _error_utils.spawnError)('Invalid record format. Please define field mappings using a `fields` key for each record definition object');
                }
                return {
                  id: this._sdk.__airtableInterface.idGenerator.generateRecordId(),
                  cellValuesByFieldId: this._cellValuesByFieldIdOrNameToCellValuesByFieldId(fields)
                };
              });
              _context8.next = 3;
              return this._sdk.__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS,
                tableId: this.id,
                records: recordsToCreate,
                opts: {
                  parseDateCellValueInColumnTimeZone: true
                }
              });
            case 3:
              return _context8.abrupt("return", recordsToCreate.map(record => record.id));
            case 4:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function createRecordsAsync(_x8) {
        return _createRecordsAsync.apply(this, arguments);
      }
      return createRecordsAsync;
    }()
    /**
     * Checks whether the current user has permission to create the specified records.
     *
     * Accepts partial input, in the same format as {@link createRecordsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can create the specified records,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param records Array of objects mapping `FieldId` or field name to value for that field.
     * @example
     * ```js
     * // Check if user can create specific records, when you already know what
     * // fields/cell values will be set for the records.
     * const createRecordsCheckResult = table.checkPermissionsForCreateRecords([
     *     // Like createRecordsAsync, fields can be specified by name or ID
     *     {
     *          fields: {
     *              'Project Name': 'Advertising campaign',
     *              'Budget': 100,
     *          },
     *     },
     *     {
     *          fields: {
     *              [projectNameField.id]: 'Cat video',
     *              [budgetField.id]: 200,
     *          },
     *     },
     *     {},
     * ]);
     * if (!createRecordsCheckResult.hasPermission) {
     *     alert(createRecordsCheckResult.reasonDisplayString);
     * }
     *
     * // Check if user could potentially create records.
     * // Use when you don't know the specific fields/cell values yet (for example,
     * // to show or hide UI controls that let you start creating records.)
     * // Equivalent to table.checkPermissionsForCreateRecord()
     * const createUnknownRecordCheckResult =
     *     table.checkPermissionsForCreateRecords();
     * ```
     */
    )
  }, {
    key: "checkPermissionsForCreateRecords",
    value: function checkPermissionsForCreateRecords(records) {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.CREATE_MULTIPLE_RECORDS,
        tableId: this.id,
        records: records ? records.map(record => ({
          id: undefined,
          cellValuesByFieldId: record.fields ? this._cellValuesByFieldIdOrNameToCellValuesByFieldId(record.fields) : undefined
        })) : undefined
      });
    }
    /**
     * An alias for `checkPermissionsForCreateRecords(records).hasPermission`.
     *
     * Checks whether the current user has permission to create the specified records.
     *
     * Accepts partial input, in the same format as {@link createRecordsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param records Array of objects mapping `FieldId` or field name to value for that field.
     * @example
     * ```js
     * // Check if user can create specific records, when you already know what fields/cell values
     * // will be set for the records.
     * const canCreateRecords = table.hasPermissionToCreateRecords([
     *     // Like createRecordsAsync, fields can be specified by name or ID
     *     {
     *          fields: {
     *              'Project Name': 'Advertising campaign',
     *              'Budget': 100,
     *          }
     *     },
     *     {
     *          fields: {
     *              [projectNameField.id]: 'Cat video',
     *              [budgetField.id]: 200,
     *          }
     *     },
     *     {},
     * ]);
     * if (!canCreateRecords) {
     *     alert('not allowed');
     * }
     *
     * // Check if user could potentially create records.
     * // Use when you don't know the specific fields/cell values yet (for example,
     * // to show or hide UI controls that let you start creating records).
     * // Equivalent to table.hasPermissionToCreateRecord()
     * const canCreateUnknownRecords = table.hasPermissionToCreateRecords();
     * ```
     */
  }, {
    key: "hasPermissionToCreateRecords",
    value: function hasPermissionToCreateRecords(records) {
      return this.checkPermissionsForCreateRecords(records).hasPermission;
    }
    /** @internal */
  }, {
    key: "_cellValuesByFieldIdOrNameToCellValuesByFieldId",
    value: function _cellValuesByFieldIdOrNameToCellValuesByFieldId(cellValuesByFieldIdOrName) {
      return Object.fromEntries((0, _private_utils.entries)(cellValuesByFieldIdOrName).map(_ref => {
        var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          fieldIdOrName = _ref2[0],
          cellValue = _ref2[1];
        var field = this.__getFieldMatching(fieldIdOrName);
        return [field.id, cellValue];
      }));
    }
    /**
     * Checks whether the current user has permission to create a field in this table.
     *
     * Accepts partial input, in the same format as {@link createFieldAsync}.
     *
     * Returns `{hasPermission: true}` if the current user can update the specified record,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param name name for the field. must be case-insensitive unique for the table
     * @param type type for the field
     * @param options options for the field. omit for fields without writable options
     * @param description description for the field. omit to leave blank
     *
     * @example
     * ```js
     * const createFieldCheckResult = table.checkPermissionsForCreateField();
     *
     * if (!createFieldCheckResult.hasPermission) {
     *     alert(createFieldCheckResult.reasonDisplayString);
     * }
     * ```
     */
  }, {
    key: "checkPermissionsForCreateField",
    value: function checkPermissionsForCreateField(name, type, options, description) {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.CREATE_SINGLE_FIELD,
        tableId: this.id,
        id: undefined,
        // Generated in createFieldAsync.
        name,
        config: type ? _objectSpread({
          type: type
        }, options ? {
          options
        } : null) : undefined,
        description
      });
    }

    /**
     * An alias for `checkPermissionsForCreateField(name, type, options, description).hasPermission`.
     *
     * Checks whether the current user has permission to create a field in this table.
     *
     * Accepts partial input, in the same format as {@link createFieldAsync}.
     *
     * @param name name for the field. must be case-insensitive unique for the table
     * @param type type for the field
     * @param options options for the field. omit for fields without writable options
     * @param description description for the field. omit to leave blank
     *
     * @example
     * ```js
     * const canCreateField = table.hasPermissionToCreateField();
     *
     * if (!canCreateField) {
     *     alert('not allowed!');
     * }
     * ```
     */
  }, {
    key: "hasPermissionToCreateField",
    value: function hasPermissionToCreateField(name, type, options, description) {
      return this.checkPermissionsForCreateField(name, type, options, description).hasPermission;
    }

    /**
     * Creates a new field.
     *
     * Similar to creating a field from the Airtable UI, the new field will not be visible
     * in views that have other hidden fields and views that are publicly shared.
     *
     * Throws an error if the user does not have permission to create a field, if invalid
     * name, type or options are provided, or if creating fields of this type is not supported.
     *
     * Refer to {@link FieldType} for supported field types, the write format for options, and
     * other specifics for certain field types.
     *
     * This action is asynchronous. Unlike new records, new fields are **not** created
     * optimistically locally. You must `await` the returned promise before using the new
     * field in your extension.
     *
     * @param name name for the field. must be case-insensitive unique
     * @param type type for the field
     * @param options options for the field. omit for fields without writable options
     * @param description description for the field. is optional and will be `''` if not specified
     * or if specified as `null`.
     *
     * @example
     * ```js
     * async function createNewSingleLineTextField(table, name) {
     *     if (table.hasPermissionToCreateField(name, FieldType.SINGLE_LINE_TEXT)) {
     *         await table.createFieldAsync(name, FieldType.SINGLE_LINE_TEXT);
     *     }
     * }
     *
     * async function createNewCheckboxField(table, name) {
     *     const options = {
     *         icon: 'check',
     *         color: 'greenBright',
     *     };
     *     if (table.hasPermissionToCreateField(name, FieldType.CHECKBOX, options)) {
     *         await table.createFieldAsync(name, FieldType.CHECKBOX, options);
     *     }
     * }
     *
     * async function createNewDateField(table, name) {
     *     const options = {
     *         dateFormat: {
     *             name: 'iso',
     *         },
     *     };
     *     if (table.hasPermissionToCreateField(name, FieldType.DATE, options)) {
     *         await table.createFieldAsync(name, FieldType.DATE, options);
     *     }
     * }
     * ```
     */
  }, {
    key: "createFieldAsync",
    value: (function () {
      var _createFieldAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9(name, type, options, description) {
        var fieldId;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              fieldId = this._sdk.__airtableInterface.idGenerator.generateFieldId();
              _context9.next = 3;
              return this._sdk.__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.CREATE_SINGLE_FIELD,
                tableId: this.id,
                id: fieldId,
                name,
                config: _objectSpread({
                  type: type
                }, options ? {
                  options
                } : null),
                // Coerce undefined to null so that only old SDKs pass "undefined" for description
                // '' is permitted, as we already set empty descriptions to '' when editing descriptions
                // from the UI
                description: description !== null && description !== void 0 ? description : null
              });
            case 3:
              return _context9.abrupt("return", this.getFieldById(fieldId));
            case 4:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function createFieldAsync(_x9, _x10, _x11, _x12) {
        return _createFieldAsync.apply(this, arguments);
      }
      return createFieldAsync;
    }()
    /**
     * @internal
     */
    )
  }, {
    key: "__getFieldMatching",
    value: function __getFieldMatching(fieldOrFieldIdOrFieldName) {
      var field;
      if (fieldOrFieldIdOrFieldName instanceof _field.default) {
        if (fieldOrFieldIdOrFieldName.parentTable.id !== this.id) {
          throw (0, _error_utils.spawnError)("Field '%s' is from a different table than table '%s'", fieldOrFieldIdOrFieldName.name, this.name);
        }
        field = fieldOrFieldIdOrFieldName;
      } else {
        field = this.getFieldByIdIfExists(fieldOrFieldIdOrFieldName) || this.getFieldByNameIfExists(fieldOrFieldIdOrFieldName);
        if (field === null) {
          throw (0, _error_utils.spawnError)("Field '%s' does not exist in table '%s'", fieldOrFieldIdOrFieldName, this.name);
        }
      }
      if (field.isDeleted) {
        throw (0, _error_utils.spawnError)("Field '%s' was deleted from table '%s'", field.name, this.name);
      }
      return field;
    }
    /**
     * @internal
     */
  }, {
    key: "__getViewMatching",
    value: function __getViewMatching(viewOrViewIdOrViewName) {
      var view;
      if (viewOrViewIdOrViewName instanceof _view.default) {
        if (viewOrViewIdOrViewName.parentTable.id !== this.id) {
          throw (0, _error_utils.spawnError)("View '%s' is from a different table than table '%s'", viewOrViewIdOrViewName.name, this.name);
        }
        view = viewOrViewIdOrViewName;
      } else {
        view = this.getViewByIdIfExists(viewOrViewIdOrViewName) || this.getViewByNameIfExists(viewOrViewIdOrViewName);
        if (view === null) {
          throw (0, _error_utils.spawnError)("View '%s' does not exist in table '%s'", viewOrViewIdOrViewName, this.name);
        }
      }
      if (view.isDeleted) {
        throw (0, _error_utils.spawnError)("View '%s' was deleted from table '%s'", view.name, this.name);
      }
      return view;
    }
    /**
     * @internal
     */
  }, {
    key: "__triggerOnChangeForDirtyPaths",
    value: function __triggerOnChangeForDirtyPaths(dirtyPaths) {
      var didTableSchemaChange = false;
      if (dirtyPaths.name) {
        this._onChange(WatchableTableKeys.name);
        didTableSchemaChange = true;
      }
      if (dirtyPaths.viewOrder) {
        this._onChange(WatchableTableKeys.views);
        didTableSchemaChange = true;

        // Clean up deleted views
        var _iterator3 = _createForOfIteratorHelper((0, _private_utils.entries)(this._viewModelsById)),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = (0, _slicedToArray2.default)(_step3.value, 2),
              viewId = _step3$value[0],
              viewModel = _step3$value[1];
            if (viewModel.isDeleted) {
              delete this._viewModelsById[viewId];
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      if (dirtyPaths.lock) {
        didTableSchemaChange = true;
      }
      if (dirtyPaths.externalSyncById) {
        didTableSchemaChange = true;
      }
      if (dirtyPaths.description) {
        this._onChange(WatchableTableKeys.description);
        didTableSchemaChange = true;
      }
      if (dirtyPaths.viewsById) {
        var _iterator4 = _createForOfIteratorHelper((0, _private_utils.entries)(dirtyPaths.viewsById)),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _step4$value = (0, _slicedToArray2.default)(_step4.value, 2),
              _viewId = _step4$value[0],
              dirtyViewPaths = _step4$value[1];
            // Directly access from _viewModelsById to avoid creating
            // a view model if it doesn't already exist. If it doesn't exist,
            // nothing can be subscribed to any events on it.
            var view = this._viewModelsById[_viewId];
            if (view) {
              var didViewSchemaChange = view.__triggerOnChangeForDirtyPaths(dirtyViewPaths);
              if (didViewSchemaChange) {
                didTableSchemaChange = true;
              }
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
      if (dirtyPaths.fieldsById) {
        // TODO: don't trigger schema change when autonumber typeOptions change.
        // That currently happens every time you create a row in a table with an
        // autonumber field.
        didTableSchemaChange = true;

        // Since tables don't have a field order, need to detect if a field
        // was created or deleted and trigger onChange for fields.
        var addedFieldIds = [];
        var removedFieldIds = [];
        var _iterator5 = _createForOfIteratorHelper((0, _private_utils.entries)(dirtyPaths.fieldsById)),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = (0, _slicedToArray2.default)(_step5.value, 2),
              fieldId = _step5$value[0],
              dirtyFieldPaths = _step5$value[1];
            if (dirtyFieldPaths && dirtyFieldPaths._isDirty) {
              // If the entire field is dirty, it was either created or deleted.
              if ((0, _private_utils.has)(this._data.fieldsById, fieldId)) {
                addedFieldIds.push(fieldId);
              } else {
                removedFieldIds.push(fieldId);
                var fieldModel = this._fieldModelsById[fieldId];
                if (fieldModel) {
                  // Remove the Field model if it was deleted.
                  delete this._fieldModelsById[fieldId];
                }
              }
            } else {
              // Directly access from _fieldModelsById to avoid creating
              // a field model if it doesn't already exist. If it doesn't exist,
              // nothing can be subscribed to any events on it.
              var field = this._fieldModelsById[fieldId];
              if (field) {
                field.__triggerOnChangeForDirtyPaths(dirtyFieldPaths);
              }
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        if (addedFieldIds.length > 0 || removedFieldIds.length > 0) {
          this._onChange(WatchableTableKeys.fields, {
            addedFieldIds,
            removedFieldIds
          });
        }

        // Clear out cached field names in case a field was added/removed/renamed.
        this._cachedFieldNamesById = null;
      }
      // NOTE: Record store onChange triggers must be performed AFTER field onChange triggers to
      // ensure the column type providers are not stale.
      this._recordStore.triggerOnChangeForDirtyPaths(dirtyPaths);
      return didTableSchemaChange;
    }
    /**
     * @internal
     */
  }, {
    key: "__getFieldNamesById",
    value: function __getFieldNamesById() {
      if (!this._cachedFieldNamesById) {
        var fieldNamesById = {};
        var _iterator6 = _createForOfIteratorHelper((0, _private_utils.entries)(this._data.fieldsById)),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _step6$value = (0, _slicedToArray2.default)(_step6.value, 2),
              fieldId = _step6$value[0],
              fieldData = _step6$value[1];
            fieldNamesById[fieldId] = fieldData.name;
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        this._cachedFieldNamesById = fieldNamesById;
      }
      return this._cachedFieldNamesById;
    }
  }], [{
    key: "_isWatchableKey",
    value: /** @internal */
    function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableTableKeys, key);
    }
  }]);
}(_abstract_model.default);
/** @internal */
(0, _defineProperty2.default)(Table, "_className", 'Table');
var _default = exports.default = Table;