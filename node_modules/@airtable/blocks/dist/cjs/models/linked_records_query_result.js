"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLinkedTableId = exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.string.starts-with.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _field = require("../types/field");
var _error_utils = require("../error_utils");
var _record_query_result = _interopRequireDefault(require("./record_query_result"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks/models: RecordQueryResult */ /** */
var getLinkedTableId = field => {
  var options = field.options;
  var linkedTableId = options && options.linkedTableId;
  (0, _error_utils.invariant)(typeof linkedTableId === 'string', 'linkedTableId must exist');
  return linkedTableId;
};

/** internal */
exports.getLinkedTableId = getLinkedTableId;
/**
 * Represents a set of records from a LinkedRecord cell value. See {@link RecordQueryResult} for main
 * documentation.
 *
 * Do not instantiate. You can get instances of this class by calling
 * `record.selectLinkedRecordsFromCell`.
 *
 * @docsPath models/query results/LinkedRecordsQueryResult
 */
var LinkedRecordsQueryResult = /*#__PURE__*/function (_RecordQueryResult) {
  /** @internal */
  function LinkedRecordsQueryResult(record, field, normalizedOpts, sdk) {
    var _this;
    (0, _classCallCheck2.default)(this, LinkedRecordsQueryResult);
    _this = _callSuper(this, LinkedRecordsQueryResult, [sdk, normalizedOpts]);
    // the record containing the linked-record cell this is a query of.
    /** @internal */
    (0, _defineProperty2.default)(_this, "_record", void 0);
    // the cell's field in the record
    /** @internal */
    (0, _defineProperty2.default)(_this, "_field", void 0);
    // the table we're linking to
    /** @internal */
    (0, _defineProperty2.default)(_this, "_linkedTable", void 0);
    // the records store for the origin table
    /** @internal */
    (0, _defineProperty2.default)(_this, "_originRecordStore", void 0);
    // the records store for the linked table
    /** @internal */
    (0, _defineProperty2.default)(_this, "_linkedRecordStore", void 0);
    // a RecordQueryResult containing all the rows in the linked table
    /** @internal */
    (0, _defineProperty2.default)(_this, "_linkedQueryResult", void 0);
    // is the query result currently valid. if the field config changes to link
    // to another table or not be a linked record field at all, isValid will
    // become false. once a LinkedRecordsQueryResult has become invalid, it will
    // not become valid again.
    /** @internal */
    (0, _defineProperty2.default)(_this, "_isValid", true);
    // a lazily-generated set of the record ids in the result set.
    /** @internal */
    (0, _defineProperty2.default)(_this, "_computedRecordIdsSet", null);
    // a lazily-generated array of the record ids in the query result.
    /** @internal */
    (0, _defineProperty2.default)(_this, "_computedFilteredSortedRecordIds", null);
    // how many times has each 'cellValuesInField:$FieldId' been watched?
    /** @internal */
    (0, _defineProperty2.default)(_this, "_cellValueChangeHandlerByFieldId", {});
    (0, _error_utils.invariant)(record.parentTable === field.parentTable, 'record and field must belong to the same table');
    _this._record = record;
    _this._field = field;
    _this._linkedTable = normalizedOpts.table;
    _this._originRecordStore = _this._sdk.base.__getRecordStore(_this._record.parentTable.id);
    _this._linkedRecordStore = normalizedOpts.recordStore;

    // we could rely on RecordQueryResult's reuse pool to make sure we get back
    // the same RecordQueryResult every time, but that would make it much harder
    // to make sure we unwatch everything from the old RecordQueryResult if e.g.
    // the field config changes to point at a different table
    _this._linkedQueryResult = _this._linkedTable.__tableOrViewQueryResultPool.getObjectForReuse(_this._sdk, _this._linkedTable, normalizedOpts);
    return _this;
  }

  /**
   * Is the query result currently valid? This value always starts as 'true',
   * but can become false if the record from which this result was created is
   * deleted, if the field is deleted, if the field config changes to link to
   * a different table, or if the field config changes to link to a type
   * other than MULTIPLE_RECORD_LINKS. Once `isValid` has become false, it
   * will never become true again. Many fields will throw on attempting to
   * access them, and watches will no longer fire.
   */
  (0, _inherits2.default)(LinkedRecordsQueryResult, _RecordQueryResult);
  return (0, _createClass2.default)(LinkedRecordsQueryResult, [{
    key: "isValid",
    get: function get() {
      return this._isValid;
    }

    /**
     * The table that records in this RecordQueryResult are part of
     *
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     */
  }, {
    key: "parentTable",
    get: function get() {
      (0, _error_utils.invariant)(this.isValid, 'LinkedRecordsQueryResult is no longer valid');
      return this._linkedTable;
    }

    /**
     * Ordered array of all the linked record ids. Watchable.
     */
  }, {
    key: "recordIds",
    get: function get() {
      (0, _error_utils.invariant)(this.isValid, 'LinkedRecordsQueryResult is no longer valid');
      (0, _error_utils.invariant)(this.isDataLoaded, 'LinkedRecordsQueryResult data is not loaded');

      // record ids are lazily generated
      this._generateComputedDataIfNeeded();
      (0, _error_utils.invariant)(this._computedFilteredSortedRecordIds, 'no recordIds');
      return this._computedFilteredSortedRecordIds;
    }

    /**
     * Ordered array of all the linked records. Watchable.
     */
  }, {
    key: "records",
    get: function get() {
      (0, _error_utils.invariant)(this.isValid, 'LinkedRecordsQueryResult is no longer valid');
      return this.recordIds.map(recordId => {
        var record = this._linkedRecordStore.getRecordByIdIfExists(recordId);
        (0, _error_utils.invariant)(record, 'No record for id: %s', recordId);
        return record;
      });
    }

    /**
     * The fields that were used to create this LinkedRecordsQueryResult.
     */
  }, {
    key: "fields",
    get: function get() {
      (0, _error_utils.invariant)(this.isValid, 'LinkedRecordsQueryResult is no longer valid');
      return this._linkedQueryResult.fields;
    }

    /** @inheritdoc */
  }, {
    key: "watch",
    value: function watch(keys, callback, context) {
      (0, _error_utils.invariant)(this.isValid, 'cannot watch an invalid LinkedRecordsQueryResult');
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(LinkedRecordsQueryResult.prototype), "watch", this).call(this, keys, callback, context);
      var _iterator = _createForOfIteratorHelper(validKeys),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          if (key === _record_query_result.default.WatchableKeys.cellValues) {
            this._watchLinkedQueryCellValuesIfNeededAfterWatch();
          }
          if (key.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix)) {
            var fieldId = key.substring(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix.length);
            this._watchLinkedQueryCellValuesInFieldIfNeededAfterWatch(fieldId);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return validKeys;
    }

    /** @inheritdoc */
  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      var arrayKeys = Array.isArray(keys) ? keys : [keys];
      var _iterator2 = _createForOfIteratorHelper(arrayKeys),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var key = _step2.value;
          if (key === _record_query_result.default.WatchableKeys.cellValues) {
            this._unwatchLinkedQueryCellValuesIfPossibleBeforeUnwatch();
          }
          if (key.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix)) {
            var fieldId = key.substring(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix.length);
            this._unwatchLinkedQueryCellValuesInFieldIfPossibleBeforeUnwatch(fieldId);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return (0, _get2.default)((0, _getPrototypeOf2.default)(LinkedRecordsQueryResult.prototype), "unwatch", this).call(this, arrayKeys, callback, context);
    }

    /** @inheritdoc */
  }, {
    key: "loadDataAsync",
    value: (function () {
      var _loadDataAsync2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return (0, _get2.default)((0, _getPrototypeOf2.default)(LinkedRecordsQueryResult.prototype), "loadDataAsync", this).call(this);
            case 2:
              if (this.isDataLoaded) {
                _context.next = 6;
                break;
              }
              _context.next = 5;
              return this.loadDataAsync();
            case 5:
              // there has to be an unloadData call for every loadDataAsync call.
              // call it here to offset calling loadDataAsync a second time
              this.unloadData();
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function loadDataAsync() {
        return _loadDataAsync2.apply(this, arguments);
      }
      return loadDataAsync;
    }() /** @internal */)
  }, {
    key: "_loadDataAsync",
    value: (function () {
      var _loadDataAsync3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var initiallyLoaded, changedKeys, fieldIds, _iterator3, _step3, fieldId;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this._record.__linkedRecordsQueryResultPool.registerObjectForReuseStrong(this);
              this._watchOrigin();
              this._watchLinkedQueryResult();
              initiallyLoaded = this._linkedQueryResult.isDataLoaded;
              _context2.next = 6;
              return Promise.all([this._sdk.base.__getRecordStore(this._record.parentTable.id).loadCellValuesInFieldIdsAsync([this._field.id]), this._linkedQueryResult.loadDataAsync(), this._loadRecordColorsAsync()]);
            case 6:
              this._invalidateComputedData();
              changedKeys = ['records', 'recordIds', 'recordColors']; // If the linked query result was not initially loaded, then the
              // `cellValues` event will be emitted via `_onLinkedCellValuesChange`.
              // Otherwise, it must be explicitly included here in order to promote
              // consistency.
              if (initiallyLoaded) {
                changedKeys.push('cellValues');
              }
              fieldIds = this._normalizedOpts.fieldIdsOrNullIfAllFields || this.parentTable.fields.map(field => field.id);
              _iterator3 = _createForOfIteratorHelper(fieldIds);
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  fieldId = _step3.value;
                  changedKeys.push(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              return _context2.abrupt("return", changedKeys);
            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _loadDataAsync() {
        return _loadDataAsync3.apply(this, arguments);
      }
      return _loadDataAsync;
    }() /** @internal */)
  }, {
    key: "_unloadData",
    value: function _unloadData() {
      // The inverse of this condition cannot be deterministically reproduced
      // in the testing environment.
      // istanbul ignore else
      if (this.isValid) {
        this._record.__linkedRecordsQueryResultPool.unregisterObjectForReuseStrong(this);
        this._unwatchOrigin();
        this._unwatchLinkedQueryResult();
        this._originRecordStore.unloadCellValuesInFieldIds([this._field.id]);
        this._linkedQueryResult.unloadData();
        this._unloadRecordColors();
        this._invalidateComputedData();
      }
    }

    /**
     * the key used to identify this query result in ObjectPool
     *
     * @hidden
     */
  }, {
    key: "__poolKey",
    get: function get() {
      return "".concat(this._serializedOpts, "::").concat(this._field.id, "::").concat(this._linkedTable.id, "::").concat(this.isValid);
    }

    /** @internal */
  }, {
    key: "_cellValuesWatchCount",
    get: function get() {
      return (this._changeWatchersByKey[_record_query_result.default.WatchableKeys.cellValues] || []).length;
    }

    /** @internal */
  }, {
    key: "_watchLinkedQueryCellValuesIfNeededAfterWatch",
    value: function _watchLinkedQueryCellValuesIfNeededAfterWatch() {
      if (this._cellValuesWatchCount === 1) {
        this._watchLinkedQueryCellValues();
      }
    }

    /** @internal */
  }, {
    key: "_unwatchLinkedQueryCellValuesIfPossibleBeforeUnwatch",
    value: function _unwatchLinkedQueryCellValuesIfPossibleBeforeUnwatch() {
      if (this._cellValuesWatchCount === 1 && this.isValid) {
        this._unwatchLinkedQueryCellValues();
      }
    }

    /** @internal */
  }, {
    key: "_cellValueWatchCountByFieldId",
    get: function get() {
      var countByFieldId = {};
      var watchKeys = Object.keys(this._changeWatchersByKey).filter(key => {
        return key.startsWith(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix);
      });
      var _iterator4 = _createForOfIteratorHelper(watchKeys),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var watchKey = _step4.value;
          var fieldId = watchKey.slice(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix.length);
          countByFieldId[fieldId] = this._changeWatchersByKey[watchKey].length;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return countByFieldId;
    }

    /** @internal */
  }, {
    key: "_watchLinkedQueryCellValuesInFieldIfNeededAfterWatch",
    value: function _watchLinkedQueryCellValuesInFieldIfNeededAfterWatch(fieldId) {
      if (this._cellValueWatchCountByFieldId[fieldId] === 1 && this.isValid) {
        this._watchLinkedQueryCellValuesInField(fieldId);
      }
    }

    /** @internal */
  }, {
    key: "_unwatchLinkedQueryCellValuesInFieldIfPossibleBeforeUnwatch",
    value: function _unwatchLinkedQueryCellValuesInFieldIfPossibleBeforeUnwatch(fieldId) {
      (0, _error_utils.invariant)(this._cellValueWatchCountByFieldId[fieldId], "cellValuesInField:%s over-free'd", fieldId);
      if (this._cellValueWatchCountByFieldId[fieldId] === 1 && this.isValid) {
        this._unwatchLinkedQueryCellValuesInField(fieldId);
      }
    }

    /** @internal */
  }, {
    key: "_watchOrigin",
    value: function _watchOrigin() {
      // if the cell values in the record change, we need to invalidate our
      // cached data and notify watchers
      this._record.watch("cellValueInField:".concat(this._field.id), this._onOriginCellValueChange, this);
      // if the field config changes, we need to invalidate cached data,
      // and potentially start watching a different table
      this._field.watch('type', this._onOriginFieldConfigChange, this);
      this._field.watch('options', this._onOriginFieldConfigChange, this);
      // if the underlying record is deleted, we need to invalidate this
      // result
      this._originRecordStore.watch('recordIds', this._onOriginRecordsChange, this);
      // if the linked field in the origin table is deleted, we need to
      // invalidate this result
      this._record.parentTable.watch('fields', this._onOriginFieldsChange, this);
    }

    /** @internal */
  }, {
    key: "_unwatchOrigin",
    value: function _unwatchOrigin() {
      this._record.unwatch("cellValueInField:".concat(this._field.id), this._onOriginCellValueChange, this);
      this._field.unwatch('type', this._onOriginFieldConfigChange, this);
      this._field.unwatch('options', this._onOriginFieldConfigChange, this);
      this._originRecordStore.unwatch('recordIds', this._onOriginRecordsChange, this);
      this._record.parentTable.unwatch('fields', this._onOriginFieldsChange, this);
    }

    /** @internal */
  }, {
    key: "_watchLinkedQueryResult",
    value: function _watchLinkedQueryResult() {
      // in the linked table, all we care about is the set of recordIds.
      // this watch fire when they're added/removed and when they change
      // order. we only care about order, because add/remove is handled by
      // watching the origin record
      this._linkedQueryResult.watch('recordIds', this._onLinkedRecordIdsChange, this);
    }

    /** @internal */
  }, {
    key: "_unwatchLinkedQueryResult",
    value: function _unwatchLinkedQueryResult() {
      this._linkedQueryResult.unwatch('recordIds', this._onLinkedRecordIdsChange, this);
    }

    /** @internal */
  }, {
    key: "_watchLinkedQueryCellValues",
    value: function _watchLinkedQueryCellValues() {
      this._linkedQueryResult.watch('cellValues', this._onLinkedCellValuesChange, this);
    }

    /** @internal */
  }, {
    key: "_unwatchLinkedQueryCellValues",
    value: function _unwatchLinkedQueryCellValues() {
      this._linkedQueryResult.unwatch('cellValues', this._onLinkedCellValuesChange, this);
    }

    /** @internal */
  }, {
    key: "_watchLinkedQueryCellValuesInField",
    value: function _watchLinkedQueryCellValuesInField(fieldId) {
      this._linkedQueryResult.watch(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId, this._getOnLinkedCellValuesInFieldChange(fieldId), this);
    }

    /** @internal */
  }, {
    key: "_unwatchLinkedQueryCellValuesInField",
    value: function _unwatchLinkedQueryCellValuesInField(fieldId) {
      this._linkedQueryResult.unwatch(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId, this._getOnLinkedCellValuesInFieldChange(fieldId), this);
    }

    /** @internal */
  }, {
    key: "_onLinkedRecordIdsChange",
    value: function _onLinkedRecordIdsChange() {
      if (!this.isDataLoaded || this._record.isDeleted) {
        //TODO(jamesmoody-at): Adding this._dataOrNullIfDeleted as an exit condition here is a temporary fix to address an issue where
        // we are not reseting isValid to true while restoring deleted records that contain linked record fields. It seems the only way
        // to do this is by creating a new LinkRecordsQueryResult instance but it seems like we might be reusing the original instance
        // that we've already set isValid to false with. We'll need to do more investigating to figure out the right way to restore these
        // records while keeping the behavior of isValid consistent
        return;
      }
      (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid');
      this._invalidateComputedData();

      // we don't actually know at this stage whether anything changed or
      // not. it may have done though, so notify watchers
      this._onChange('records');
      this._onChange('recordIds');
    }

    /**
     * This model doesn't use the `_data` computed property it inherits from
     * AbstractModel. It implements the following method only so that internal
     * checks for model deletion behave appropriately (the data itself is
     * inconsequential).
     *
     * @internal
     */
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      if (this._record.isDeleted || this._linkedRecordStore.isDeleted) {
        return null;
      }
      return {};
    }

    /** @internal */
  }, {
    key: "_onLinkedCellValuesChange",
    value: function _onLinkedCellValuesChange(queryResult, key, changes) {
      (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid');
      if (changes && changes.fieldIds && changes.recordIds) {
        var recordIdsSet = this._getOrGenerateRecordIdsSet();
        var recordIds = changes.recordIds.filter(id => recordIdsSet[id] === true);
        if (recordIds.length) {
          this._onChange('cellValues', {
            fieldIds: changes.fieldIds,
            recordIds
          });
        }
      } else {
        this._onChange('cellValues');
      }
    }

    /** @internal */
  }, {
    key: "_getOnLinkedCellValuesInFieldChange",
    value: function _getOnLinkedCellValuesInFieldChange(fieldId) {
      if (!this._cellValueChangeHandlerByFieldId[fieldId]) {
        this._cellValueChangeHandlerByFieldId[fieldId] = (queryResult, key, recordIds) => {
          (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid');

          // The linked record may finish loading before its parent. In
          // that case, the appropriate events will be triggered by the
          // `_loadDataAsync` method.
          if (!this.isDataLoaded) {
            return;
          }

          // The `else` branch will only be reached when the underlying
          // `RecordOrViewQueryResult` is loaded, unloaded, and then
          // loaded again. Because that query result is not directly
          // exposed to consumers, the condition can only be met when the
          // SDK is misused (e.g. repeatedly freeing related query
          // results). The `else` branch attempts to handle that
          // situation in a logical way, but it is not tested because it
          // is fundamentally invalid.
          // istanbul ignore else
          if (Array.isArray(recordIds)) {
            var recordIdsSet = this._getOrGenerateRecordIdsSet();
            var filteredRecordIds = recordIds.filter(id => typeof id === 'string' && recordIdsSet[id] === true);
            if (filteredRecordIds.length) {
              this._onChange(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId, filteredRecordIds);
            }
          } else {
            this._onChange(_record_query_result.default.WatchableCellValuesInFieldKeyPrefix + fieldId);
          }
        };
      }
      return this._cellValueChangeHandlerByFieldId[fieldId];
    }

    /** @internal */
  }, {
    key: "_onOriginCellValueChange",
    value: function _onOriginCellValueChange() {
      if (!this.isDataLoaded || this._field.isDeleted) {
        //TODO(jamesmoody-at): Adding this._dataOrNullIfDeleted as an exit condition here is a temporary fix to address an issue where
        // we are not resetting isValid to true while restoring deleted records that contain linked record fields. It seems the only way
        // to do this is by creating a new LinkRecordsQueryResult instance but it seems like we might be reusing the original instance
        // that we've already set isValid to false with. We'll need to do more investigating to figure out the right way to restore these
        // records while keeping the behavior of isValid consistent
        return;
      }
      (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid');

      // when the origin cell value (listing all the linked records) changes,
      // invalidate all the data we have stored - we need to completely
      // regenerate it
      this._invalidateComputedData();

      // notify watchers that our set of linked records has changed
      this._onChange('records');
      this._onChange('recordIds');
    }

    /** @internal */
  }, {
    key: "_onOriginRecordsChange",
    value: function _onOriginRecordsChange() {
      if (this._record.isDeleted) {
        this._isValid = false;
      }
    }

    /** @internal */
  }, {
    key: "_onOriginFieldsChange",
    value: function _onOriginFieldsChange() {
      if (this._field.isDeleted) {
        this._isValid = false;
      }
    }

    /** @internal */
  }, {
    key: "_onOriginFieldConfigChange",
    value: function _onOriginFieldConfigChange() {
      (0, _error_utils.invariant)(this.isValid, 'watch key change event whilst invalid');
      var type = this._field.type;
      if (type !== _field.FieldType.MULTIPLE_RECORD_LINKS) {
        this._invalidateQueryResult();
        return;
      }
      var linkedTableId = getLinkedTableId(this._field);
      if (linkedTableId !== this._linkedTable.id) {
        this._invalidateQueryResult();
        return;
      }
    }

    /** @internal */
  }, {
    key: "_invalidateQueryResult",
    value: function _invalidateQueryResult() {
      if (this.isDataLoaded) {
        this._unloadData();
      }
      if (this._cellValuesWatchCount > 0) {
        this._unwatchLinkedQueryCellValues();
      }
      for (var _i = 0, _Object$keys = Object.keys(this._cellValueWatchCountByFieldId); _i < _Object$keys.length; _i++) {
        var fieldId = _Object$keys[_i];
        this._unwatchLinkedQueryCellValuesInField(fieldId);
      }
      this._isValid = false;
      this._onChange('records');
      this._onChange('recordIds');
    }

    /** @internal */
  }, {
    key: "_invalidateComputedData",
    value: function _invalidateComputedData() {
      this._computedRecordIdsSet = null;
      this._computedFilteredSortedRecordIds = null;
    }

    /** @internal */
  }, {
    key: "_generateComputedDataIfNeeded",
    value: function _generateComputedDataIfNeeded() {
      if (!this._computedRecordIdsSet) {
        this._generateComputedData();
      }
    }

    /** @internal */
  }, {
    key: "_generateComputedData",
    value: function _generateComputedData() {
      var recordIdsSet = {};
      var rawCellValue = this._record.getCellValue(this._field);
      var cellValue = rawCellValue === null ? [] : rawCellValue;
      (0, _error_utils.invariant)(Array.isArray(cellValue), 'cellValue should be array');
      var _iterator5 = _createForOfIteratorHelper(cellValue),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var linkedRecord = _step5.value;
          (0, _error_utils.invariant)(linkedRecord && typeof linkedRecord === 'object', 'linked record should be object');
          var recordId = linkedRecord.id;
          (0, _error_utils.invariant)(typeof recordId === 'string', 'id should be present');

          // We need to use the query result as the source of truth for
          // recordIds, since when the client deletes a record from the linked
          // table, we update it optimistically but the origin cell value
          // doesn't update until receiving the push payload.
          if (this._linkedQueryResult.hasRecord(recordId)) {
            recordIdsSet[recordId] = true;
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      this._computedRecordIdsSet = recordIdsSet;
      if (this._normalizedOpts.sorts && this._normalizedOpts.sorts.length) {
        // when sorts are present, record order comes from the query result
        this._computedFilteredSortedRecordIds = this._linkedQueryResult.recordIds.filter(recordId => recordIdsSet[recordId] === true);
      } else {
        // with no sorts, record order is the same as in the cell in the
        // main Airtable UI. Since we generated recordIdsSet by iterating
        // over the cell value, we're guaranteed that the key order matches
        // the linked record order in the cell.
        this._computedFilteredSortedRecordIds = Object.keys(recordIdsSet);
      }
    }

    /** @internal */
  }, {
    key: "_getOrGenerateRecordIdsSet",
    value: function _getOrGenerateRecordIdsSet() {
      this._generateComputedDataIfNeeded();
      var recordIdsSet = this._computedRecordIdsSet;
      (0, _error_utils.invariant)(recordIdsSet, 'recordIdsSet must exist');
      return recordIdsSet;
    }
  }]);
}(_record_query_result.default);
/** @internal */
(0, _defineProperty2.default)(LinkedRecordsQueryResult, "_className", 'LinkedRecordsQueryResult');
var _default = exports.default = LinkedRecordsQueryResult;