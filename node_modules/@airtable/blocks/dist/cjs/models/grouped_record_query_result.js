"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _error_utils = require("../error_utils");
var _record_query_result = _interopRequireDefault(require("./record_query_result"));
var _object_pool = _interopRequireDefault(require("./object_pool"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks/models: RecordQueryResult */ /** */
/** @hidden */
// Even though we don't load the data, we still access it through `._data` so that
// we can be ensured the model hasn't been deleted.
/**
 * Represents a group of records returned from a group query. See {@link RecordQueryResult} for main
 * documentation.
 *
 * Do not instantiate. You can get instances of this class by calling
 * `recordQueryResult.groups`.
 *
 * @docsPath models/query results/GroupedRecordQueryResult
 * @hidden
 */
var GroupedRecordQueryResult = /*#__PURE__*/function (_RecordQueryResult) {
  /** @internal */
  function GroupedRecordQueryResult(parentQueryResult, groupData, groupLevel, normalizedOpts, sdk) {
    var _this;
    (0, _classCallCheck2.default)(this, GroupedRecordQueryResult);
    _this = _callSuper(this, GroupedRecordQueryResult, [sdk, normalizedOpts]);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_parentQueryResult", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_groupData", void 0);
    /**
     * This includes groupLevel for all children & parent grouped layers, the getter
     * returns only the groupLevels for this layer.
     *
     * @internal
     */
    (0, _defineProperty2.default)(_this, "_groupLevels", void 0);
    // This is the ordered list of groups.
    /** @internal */
    (0, _defineProperty2.default)(_this, "_orderedChildrenGroups", void 0);
    // lazily generated set of record ids
    /** @internal */
    (0, _defineProperty2.default)(_this, "_recordIdsSet", null);
    // lazily generated ordered array of recordIds
    (0, _defineProperty2.default)(_this, "_orderedRecordIds", null);
    /** @internal */
    (0, _defineProperty2.default)(_this, "__groupedRecordQueryResultPool", void 0);
    _this.__groupedRecordQueryResultPool = new _object_pool.default(GroupedRecordQueryResult);
    _this._parentQueryResult = parentQueryResult;
    _this._groupData = groupData;
    _this._groupLevels = groupLevel;
    var groupLevelDataSlicedForChildren = _this._groupLevels.slice(1);
    _this._orderedChildrenGroups = groupData.groups ? groupData.groups.map(singleGroupData => {
      var group = _this.__groupedRecordQueryResultPool.getObjectForReuse(_this, singleGroupData, groupLevelDataSlicedForChildren, normalizedOpts, sdk);
      // Don't await the loading, let others check isDataLoaded.
      // (it doesn't take any time anyway). Loading also strong retains.
      group.loadDataAsync();
      return group;
    }) : null;
    return _this;
  }

  /**
   * Gets children groups of this group (if any exist)
   */
  (0, _inherits2.default)(GroupedRecordQueryResult, _RecordQueryResult);
  return (0, _createClass2.default)(GroupedRecordQueryResult, [{
    key: "groups",
    get: function get() {
      return this._orderedChildrenGroups;
    }

    /** @internal */
  }, {
    key: "groupLevel",
    get: function get() {
      return this._data.groupLevels[0];
    }

    /**
     * Gets the fieldId that this group is grouped by
     */
  }, {
    key: "fieldId",
    get: function get() {
      return this.groupLevel.fieldId;
    }

    /**
     * Gets the field that this group is grouped by
     */
  }, {
    key: "field",
    get: function get() {
      return this.parentTable.getFieldById(this.fieldId);
    }

    // TODO (SeanKeenan) This is needed because we can't always iterate down and find
    // a record, it's possible to have "empty groups".
    // getValue() {
    // }

    // TODO (SeanKeenan)
    // getValueAsString() {
    // }

    /**
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * The table that records in this RecordQueryResult are part of
     */
  }, {
    key: "parentTable",
    get: function get() {
      return this._parentQueryResult.parentTable;
    }

    /**
     * Recursively gets all recordIds in the children groups, keeping recordIds in group order
     *
     * @internal
     */
  }, {
    key: "_computeRecordIds",
    value: function _computeRecordIds() {
      // If we are a leaf node, return the raw recordIds
      if (!this.groups) {
        var _this$_data$groupData;
        // Typescript can't infer if groups is empty visibleRecordIds must be populated
        // but the extra safety isn't bad. (istanbul also can't ignore just the ??)
        // istanbul ignore next
        return (_this$_data$groupData = this._data.groupData.visibleRecordIds) !== null && _this$_data$groupData !== void 0 ? _this$_data$groupData : [];
      }

      // Otherwise build the recordId's from children groups
      var recordIds = [];
      var _iterator = _createForOfIteratorHelper(this.groups),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var group = _step.value;
          recordIds.push(...group.recordIds);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return recordIds;
    }

    /**
     * Anytime the recordIds to return could have changed, we clear this so that
     * the next time the user requests recordIds it recomputes
     *
     * @internal
     */
  }, {
    key: "_invalidateComputedRecordIds",
    value: function _invalidateComputedRecordIds() {
      this._orderedRecordIds = null;
    }

    /**
     * Ordered array of all the record ids inside this group, in group order.
     * This returns all recordIds of all children groups (in grouped order).
     * Watchable.
     */
  }, {
    key: "recordIds",
    get: function get() {
      (0, _error_utils.invariant)(this.isDataLoaded, 'GroupedRecordQueryResult data is not loaded');
      if (this._orderedRecordIds === null) {
        this._orderedRecordIds = this._computeRecordIds();
      }
      return this._orderedRecordIds;
    }

    /**
     * The fields that were used to create the parent RecordQueryResult that created this GroupedRecordQueryResult.
     * This is separate from the field/fieldId property - which is the field this grouping is based upon.
     * Null if fields were not specified, which means the RecordQueryResult
     * will load all fields in the table.
     */
  }, {
    key: "fields",
    get: function get() {
      (0, _error_utils.invariant)(this.isDataLoaded, 'GroupedRecordQueryResult data is not loaded');
      return this._parentQueryResult.fields;
    }

    /** @inheritdoc */
  }, {
    key: "watch",
    value: function watch(keys, callback, context) {
      // TODO (SeanKeenan): This provides events even if they occur outside of this group
      // This is an issue that needs to be fixed before this API is made public
      var validKeys = this._parentQueryResult.watch(keys, callback, context);
      return validKeys;
    }

    /** @inheritdoc */
  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      return this._parentQueryResult.unwatch(keys, callback, context);
    }

    /** @inheritdoc */
  }, {
    key: "loadDataAsync",
    value: (function () {
      var _loadDataAsync2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return (0, _get2.default)((0, _getPrototypeOf2.default)(GroupedRecordQueryResult.prototype), "loadDataAsync", this).call(this);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function loadDataAsync() {
        return _loadDataAsync2.apply(this, arguments);
      }
      return loadDataAsync;
    }() /** @internal */)
  }, {
    key: "_getChangedKeysOnLoad",
    value: function _getChangedKeysOnLoad() {
      return this._parentQueryResult._getChangedKeysOnLoad();
    }

    /** @internal */
  }, {
    key: "_loadDataAsync",
    value: (function () {
      var _loadDataAsync3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this._parentQueryResult.__groupedRecordQueryResultPool.registerObjectForReuseStrong(this);

              // Ensure we invalidate our memoized computed recordIds whenever a relevant hook changes
              // TODO: (SeanKeenan) At the moment this should never be relevant, because groups are recreated
              // anytime the groups change - but this is how it should work once groups persist AND
              // watching recordIds only changes if records in this group change.
              // In the meantime this does ensure that a deleted GroupedRecordQuery with stale recordIds
              // doesn't return the cached array.
              this.watch(['recordIds', 'groups', 'groupLevels'], this._invalidateComputedRecordIds, this);
              this.watch(['recordIds'], this._invalidateRecordIdsSet, this);
              return _context2.abrupt("return", this._getChangedKeysOnLoad());
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _loadDataAsync() {
        return _loadDataAsync3.apply(this, arguments);
      }
      return _loadDataAsync;
    }() /** @internal */)
  }, {
    key: "_unloadData",
    value: function _unloadData() {
      // Ensure we invalidate our memoized computed recordIds whenever a relevant hook changes
      this.unwatch(['recordIds', 'groups', 'groupLevels'], this._invalidateComputedRecordIds, this);
      this.unwatch(['recordIds'], this._invalidateRecordIdsSet, this);

      // Invalidate both of the caches, as this object can no longer be accessed
      this._invalidateComputedRecordIds();
      this._invalidateRecordIdsSet();
      this._unloadChildrenGroupsIfNeeded();
      this._parentQueryResult.__groupedRecordQueryResultPool.unregisterObjectForReuseStrong(this);
    }

    /** @internal */
  }, {
    key: "__poolKey",
    get: function get() {
      // TODO (SeanKeenan) We don't have an actual groupId, but while id is unique; this should have id removed
      return "".concat(this._serializedOpts, "::").concat(this.id);
    }

    /**
     * This model doesn't actually load data, but it does use the `_data`
     * property so that checks for model deletion behave appropriately.
     *
     * This is considered deleted if the parent query result has been deleted.
     *
     * We return groupData, instead of precomputing all children groups because
     * we perform the computation+caching lazily on request
     *
     * @internal
     */
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      if (this._parentQueryResult._dataOrNullIfDeleted === null) {
        return null;
      }
      return {
        groupData: this._groupData,
        groupLevels: this._groupLevels
      };
    }

    /** @inheritdoc */
  }, {
    key: "isDataLoaded",
    get: function get() {
      return this._parentQueryResult.isDataLoaded;
    }

    /** @internal */
  }, {
    key: "_unloadChildrenGroupsIfNeeded",
    value: function _unloadChildrenGroupsIfNeeded() {
      if (this._orderedChildrenGroups) {
        var _iterator2 = _createForOfIteratorHelper(this._orderedChildrenGroups),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var group = _step2.value;
            group.unloadData();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }

    /** @internal */
  }, {
    key: "_invalidateRecordIdsSet",
    value: function _invalidateRecordIdsSet() {
      this._recordIdsSet = null;
    }

    /** @internal */
  }, {
    key: "_getOrGenerateRecordIdsSet",
    value: function _getOrGenerateRecordIdsSet() {
      // TODO (SeanKeenan): this logic is duplicated in tableOrViewQueryResult
      if (!this._recordIdsSet) {
        var recordIdsSet = {};
        var _iterator3 = _createForOfIteratorHelper(this.recordIds),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var recordId = _step3.value;
            recordIdsSet[recordId] = true;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        this._recordIdsSet = recordIdsSet;
      }
      return this._recordIdsSet;
    }
  }]);
}(_record_query_result.default);
/** @internal */
(0, _defineProperty2.default)(GroupedRecordQueryResult, "_className", 'GroupedRecordQueryResult');
var _default = exports.default = GroupedRecordQueryResult;