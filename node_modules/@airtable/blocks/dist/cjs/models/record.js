"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("core-js/modules/es.string.starts-with.js");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _field = require("../types/field");
var _private_utils = require("../private_utils");
var _error_utils = require("../error_utils");
var _color_utils = _interopRequireDefault(require("../color_utils"));
var _abstract_model = _interopRequireDefault(require("./abstract_model"));
var _object_pool = _interopRequireDefault(require("./object_pool"));
var _record_query_result = _interopRequireDefault(require("./record_query_result"));
var _linked_records_query_result = _interopRequireDefault(require("./linked_records_query_result"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks/models: Record */ /** */
var WatchableRecordKeys = Object.freeze({
  name: 'name',
  commentCount: 'commentCount',
  // TODO(kasra): these keys don't have matching getters (not that they should
  // it's just inconsistent...)
  cellValues: 'cellValues'
});
// TODO: load cell values in field when this is watched? This will
// cause the CellRenderer component to load cell values, which seems okay,
// but needs a little more thought.
var WatchableCellValueInFieldKeyPrefix = 'cellValueInField:';
// TODO: load view data when this is watched. see previous comment.
var WatchableColorInViewKeyPrefix = 'colorInView:';
/**
 * Any key within record that can be watched:
 * - `'name'`
 * - `'commentCount'`
 * - `'cellValues'`
 * - `'cellValueInField:' + someFieldId`
 * - `'colorInView:' + someViewId`
 */
/**
 * Model class representing a record in a table.
 *
 * Do not instantiate. You can get instances of this class by calling `table.selectRecords`
 * or `view.selectRecords` and using the resulting {@link RecordQueryResult}.
 *
 * @docsPath models/Record
 */
var Record = /*#__PURE__*/function (_AbstractModel) {
  /**
   * @internal
   */
  function Record(sdk, parentRecordStore, parentTable, recordId) {
    var _this;
    (0, _classCallCheck2.default)(this, Record);
    _this = _callSuper(this, Record, [sdk, recordId]);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_parentRecordStore", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_parentTable", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "__linkedRecordsQueryResultPool", void 0);
    _this._parentRecordStore = parentRecordStore;
    _this._parentTable = parentTable;
    _this.__linkedRecordsQueryResultPool = new _object_pool.default(_linked_records_query_result.default);
    return _this;
  }

  /**
   * @internal
   */
  (0, _inherits2.default)(Record, _AbstractModel);
  return (0, _createClass2.default)(Record, [{
    key: "_dataOrNullIfDeleted",
    get: function get() {
      var _recordsById$this$_id;
      var tableData = this._baseData.tablesById[this.parentTable.id];
      if (!tableData) {
        return null;
      }
      var recordsById = tableData.recordsById;
      (0, _error_utils.invariant)(recordsById, 'Record data is not loaded');
      return (_recordsById$this$_id = recordsById[this._id]) !== null && _recordsById$this$_id !== void 0 ? _recordsById$this$_id : null;
    }
    /**
     * The table that this record belongs to. Should never change because records aren't moved between tables.
     *
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * @example
     * ```js
     * import {useRecords} from '@airtable/blocks/ui';
     * const records = useRecords(myTable);
     * console.log(records[0].parentTable.id === myTable.id);
     * // => true
     * ```
     */
  }, {
    key: "parentTable",
    get: function get() {
      return this._parentTable;
    }
    /**
     * @internal
     */
  }, {
    key: "_getFieldMatching",
    value: function _getFieldMatching(fieldOrFieldIdOrFieldName) {
      return this.parentTable.__getFieldMatching(fieldOrFieldIdOrFieldName);
    }
    /**
     * @internal
     */
  }, {
    key: "_getViewMatching",
    value: function _getViewMatching(viewOrViewIdOrViewName) {
      return this.parentTable.__getViewMatching(viewOrViewIdOrViewName);
    }

    /**
     * @internal
     *
     * For use when we need the raw public API cell value. Specifically makes a difference
     * for lookup fields, where we translate the format to a blocks-specific format in getCellValue.
     * That format is incompatible with fieldTypeProvider methods, which expect the public API
     * format - use _getRawCellValue instead.
     */
  }, {
    key: "_getRawCellValue",
    value: function _getRawCellValue(field) {
      (0, _error_utils.invariant)(this._parentRecordStore.areCellValuesLoadedForFieldId(field.id), 'Cell values for field %s are not loaded', field.id);
      var cellValuesByFieldId = this._data.cellValuesByFieldId;
      if (!cellValuesByFieldId) {
        return null;
      }
      var cellValue = cellValuesByFieldId[field.id] !== undefined ? cellValuesByFieldId[field.id] : null;
      if (typeof cellValue === 'object' && cellValue !== null) {
        // Copy non-primitives.
        // TODO(kasra): maybe freezeDeep instead?
        return (0, _private_utils.cloneDeep)(cellValue);
      } else {
        return cellValue;
      }
    }
    /**
     * Gets the cell value of the given field for this record.
     *
     * @param fieldOrFieldIdOrFieldName The field (or field ID or field name) whose cell value you'd like to get.
     * @example
     * ```js
     * const cellValue = myRecord.getCellValue(mySingleLineTextField);
     * console.log(cellValue);
     * // => 'cell value'
     * ```
     */
  }, {
    key: "getCellValue",
    value: function getCellValue(fieldOrFieldIdOrFieldName) {
      var field = this._getFieldMatching(fieldOrFieldIdOrFieldName);
      var cellValue = this._getRawCellValue(field);

      // HACK: migrate to new public lookup cell value format if needed
      if (typeof cellValue === 'object' && cellValue !== null && field.type === _field.FieldType.MULTIPLE_LOOKUP_VALUES && !this._sdk.__airtableInterface.sdkInitData.isUsingNewLookupCellValueFormat) {
        var cellValueForMigration = [];
        (0, _error_utils.invariant)(Array.isArray(cellValue.linkedRecordIds), 'linkedRecordIds');
        var _iterator = _createForOfIteratorHelper(cellValue.linkedRecordIds),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var linkedRecordId = _step.value;
            (0, _error_utils.invariant)(typeof linkedRecordId === 'string', 'linkedRecordId');
            var _ref = cellValue,
              valuesByLinkedRecordId = _ref.valuesByLinkedRecordId;
            (0, _error_utils.invariant)(valuesByLinkedRecordId && typeof valuesByLinkedRecordId === 'object', 'valuesByLinkedRecordId');
            var value = valuesByLinkedRecordId[linkedRecordId];
            if (Array.isArray(value)) {
              var _iterator2 = _createForOfIteratorHelper(value),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var v = _step2.value;
                  cellValueForMigration.push({
                    linkedRecordId,
                    value: v
                  });
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            } else {
              cellValueForMigration.push({
                linkedRecordId,
                value
              });
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return cellValueForMigration;
      }
      return cellValue;
    }
    /**
     * Gets the cell value of the given field for this record, formatted as a `string`.
     *
     * @param fieldOrFieldIdOrFieldName The field (or field ID or field name) whose cell value you'd like to get.
     * @example
     * ```js
     * const stringValue = myRecord.getCellValueAsString(myNumberField);
     * console.log(stringValue);
     * // => '42'
     * ```
     */
  }, {
    key: "getCellValueAsString",
    value: function getCellValueAsString(fieldOrFieldIdOrFieldName) {
      var field = this._getFieldMatching(fieldOrFieldIdOrFieldName);
      (0, _error_utils.invariant)(this._parentRecordStore.areCellValuesLoadedForFieldId(field.id), 'Cell values for field %s are not loaded', field.id);
      var cellValue = this._getRawCellValue(field);
      if (cellValue === null || cellValue === undefined) {
        return '';
      } else {
        var airtableInterface = this._sdk.__airtableInterface;
        var appInterface = this._sdk.__appInterface;
        return airtableInterface.fieldTypeProvider.convertCellValueToString(appInterface, cellValue, field._data);
      }
    }
    /**
     * Returns a URL that is suitable for rendering an attachment on the current client.
     * The URL that is returned will only work for the current user.
     *
     * @param attachmentId The ID of the attachment.
     * @param attachmentUrl The attachment's URL (which is not suitable for rendering on the client).
     * @example
     * ```js
     * import React from 'react';
     *
     * function RecordAttachments(props) {
     *     const {record, attachmentField} = props;
     *     const attachmentCellValue = record.getCellValue(attachmentField);
     *     if (attachmentCellValue === null) {
     *         return null;
     *     }
     *     return (
     *         <div>
     *             {attachmentCellValue.map(attachmentObj => {
     *                 const clientUrl =
     *                     record.getAttachmentClientUrlFromCellValueUrl(
     *                         attachmentObj.id,
     *                         attachmentObj.url
     *                     );
     *                 return (
     *                     <img key={attachmentObj.id} src={clientUrl} width={200} />
     *                 );
     *             })}
     *         </div>
     *     );
     * }
     * ```
     */
  }, {
    key: "getAttachmentClientUrlFromCellValueUrl",
    value: function getAttachmentClientUrlFromCellValueUrl(attachmentId, attachmentUrl) {
      var airtableInterface = this._sdk.__airtableInterface;
      var appInterface = this._sdk.__appInterface;
      return airtableInterface.urlConstructor.getAttachmentClientUrl(appInterface, attachmentId, attachmentUrl);
    }
    /**
     * Gets the color of this record in a given view, or null if the record has no color in that
     * view.
     *
     * Can be watched with the 'colorInView:${ViewId}' key.
     *
     * @param viewOrViewIdOrViewName The view (or view ID or view name) to use for record coloring.
     */
  }, {
    key: "getColorInView",
    value: function getColorInView(viewOrViewIdOrViewName) {
      var view = this._getViewMatching(viewOrViewIdOrViewName);
      return this._parentRecordStore.getViewDataStore(view.id).getRecordColor(this);
    }
    /**
     * Gets the CSS hex string for this record in a given view, or null if the record has no color
     * in that view.
     *
     * Can be watched with the 'colorInView:${ViewId}' key.
     *
     * @param viewOrViewIdOrViewName The view (or view ID or view name) to use for record coloring.
     */
  }, {
    key: "getColorHexInView",
    value: function getColorHexInView(viewOrViewIdOrViewName) {
      var color = this.getColorInView(viewOrViewIdOrViewName);
      if (!color) {
        return null;
      }
      return _color_utils.default.getHexForColor(color);
    }
    /**
     * Select records referenced in a `multipleRecordLinks` cell value. Returns a query result
     * containing the records in the given `multipleRecordLinks` field.
     * See {@link RecordQueryResult} for more.
     *
     * @param fieldOrFieldIdOrFieldName The `multipleRecordLinks` field (or field ID or field name) to use.
     * @param opts Options for the query, such as sorts and fields.
     */
  }, {
    key: "selectLinkedRecordsFromCell",
    value: function selectLinkedRecordsFromCell(fieldOrFieldIdOrFieldName) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var field = this._getFieldMatching(fieldOrFieldIdOrFieldName);
      var linkedTableId = field.options && field.options.linkedTableId;
      (0, _error_utils.invariant)(typeof linkedTableId === 'string', 'linkedTableId must be set');
      var linkedTable = this._sdk.base.getTableById(linkedTableId);
      var linkedRecordStore = this._sdk.base.__getRecordStore(linkedTableId);
      var normalizedOpts = _record_query_result.default._normalizeOpts(linkedTable, linkedRecordStore, opts);
      return this.__linkedRecordsQueryResultPool.getObjectForReuse(this, field, normalizedOpts, this._sdk);
    }
    /**
     * Select and load records referenced in a `multipleRecordLinks` cell value. Returns a query result
     * promise containing the records in the given `multipleRecordLinks` field.
     * See {@link RecordQueryResult} for more.
     *
     * Remember to call `queryResult.unloadData` once you're finished with the query.
     *
     * @param fieldOrFieldIdOrFieldName The `multipleRecordLinks` field (or field ID or field name) to use.
     * @param opts Options for the query, such as sorts and fields.
     */
  }, {
    key: "selectLinkedRecordsFromCellAsync",
    value: (function () {
      var _selectLinkedRecordsFromCellAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(fieldOrFieldIdOrFieldName) {
        var opts,
          queryResult,
          _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              queryResult = this.selectLinkedRecordsFromCell(fieldOrFieldIdOrFieldName, opts);
              _context.next = 4;
              return queryResult.loadDataAsync();
            case 4:
              return _context.abrupt("return", queryResult);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function selectLinkedRecordsFromCellAsync(_x) {
        return _selectLinkedRecordsFromCellAsync.apply(this, arguments);
      }
      return selectLinkedRecordsFromCellAsync;
    }()
    /**
     * The URL for the record. You can visit this URL in the browser to be taken to the record in the Airtable UI.
     *
     * @example
     * ```js
     * console.log(myRecord.url);
     * // => 'https://airtable.com/appxxxxxxxxxxxxxx/tblxxxxxxxxxxxxxx/recxxxxxxxxxxxxxx'
     * ```
     */
    )
  }, {
    key: "url",
    get: function get() {
      return this._sdk.__airtableInterface.urlConstructor.getRecordUrl(this.id, this.parentTable.id);
    }
    /**
     * The primary cell value in this record, formatted as a `string`.
     *
     * @example
     * ```js
     * console.log(myRecord.name);
     * // => '42'
     * ```
     */
  }, {
    key: "name",
    get: function get() {
      return this.getCellValueAsString(this.parentTable.primaryField);
    }
    /**
     * The number of comments on this record.
     *
     * @example
     * ```js
     * const commentCount = myRecord.commentCount;
     * const isSingular = commentCount === 1;
     * console.log(
     *     `This record has ${commentCount} comment${isSingular ? '' : 's'}`
     * );
     * ```
     */
  }, {
    key: "commentCount",
    get: function get() {
      return this._data.commentCount;
    }
    /**
     * The created time of this record.
     *
     * @example
     * ```js
     * console.log(`
     *     This record was created at ${myRecord.createdTime.toISOString()}
     * `);
     * ```
     */
  }, {
    key: "createdTime",
    get: function get() {
      return new Date(this._data.createdTime);
    }
    /**
     * @internal
     */
  }, {
    key: "__triggerOnChangeForDirtyPaths",
    value: function __triggerOnChangeForDirtyPaths(dirtyPaths) {
      var cellValuesByFieldId = dirtyPaths.cellValuesByFieldId,
        commentCount = dirtyPaths.commentCount;
      if (cellValuesByFieldId && !(0, _private_utils.isObjectEmpty)(cellValuesByFieldId)) {
        // TODO: don't trigger changes for fields that aren't supposed to be loaded
        // (in some cases, e.g. record created, liveapp will send cell values
        // that we're not subscribed to).

        this._onChange(WatchableRecordKeys.cellValues, Object.keys(cellValuesByFieldId));
        if (cellValuesByFieldId[this.parentTable.primaryField.id]) {
          this._onChange(WatchableRecordKeys.name);
        }
        for (var _i = 0, _Object$keys = Object.keys(cellValuesByFieldId); _i < _Object$keys.length; _i++) {
          var fieldId = _Object$keys[_i];
          this._onChange(WatchableCellValueInFieldKeyPrefix + fieldId, fieldId);
        }
      }
      if (commentCount) {
        this._onChange(WatchableRecordKeys.commentCount);
      }
    }
    /**
     * @internal
     */
  }, {
    key: "__triggerOnChangeForRecordColorInViewId",
    value: function __triggerOnChangeForRecordColorInViewId(viewId) {
      this._onChange(WatchableColorInViewKeyPrefix + viewId);
    }
  }], [{
    key: "_isWatchableKey",
    value: /** @internal */
    function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableRecordKeys, key) || key.startsWith(WatchableCellValueInFieldKeyPrefix) || key.startsWith(WatchableColorInViewKeyPrefix);
    }
  }]);
}(_abstract_model.default);
/** @internal */
(0, _defineProperty2.default)(Record, "_className", 'Record');
var _default = exports.default = Record;