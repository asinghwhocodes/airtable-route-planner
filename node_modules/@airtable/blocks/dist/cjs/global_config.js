"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
require("core-js/modules/es.array.map.js");
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _watchable = _interopRequireDefault(require("./watchable"));
var _error_utils = require("./error_utils");
var _mutations = require("./types/mutations");
var _private_utils = require("./private_utils");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks: globalConfig */ /** */
/**
 * You can watch any top-level key in global config. Use '*' to watch every change.
 */
// NOTE: GlobalConfig is essentially a wrapper around a generic key-value store.
// It's called GlobalConfig in order to convey two main points about its intended
// usage:
// 1) that it is synced 'globally' across clients (at some point we might make
//    a UserConfig which would be scoped to an individual user), and
// 2) that is should be used mainly for configuration of the block (kv store
//    as a name seems a bit too vague in terms of intended usage).
/**
 * A key-value store for persisting configuration options for an extension installation.
 *
 * The contents will be synced in real-time to all logged-in users of the installation.
 * Contents will not be updated in real-time when the installation is running in
 * a publicly shared base.
 *
 * Any key can be watched to know when the value of the key changes. If you want your
 * component to automatically re-render whenever any key on GlobalConfig changes, try using the
 * {@link useGlobalConfig} hook.
 *
 * You should not need to construct this object yourself.
 *
 * The maximum allowed size for a given GlobalConfig instance is 150kB.
 * The maximum number of keys for a given GlobalConfig instance is 1000.
 *
 * @example
 * ```js
 * import {globalConfig} from '@airtable/blocks';
 * ```
 * @docsPath models/GlobalConfig
 */
var GlobalConfig = /*#__PURE__*/function (_Watchable) {
  /**
   * @internal
   */
  function GlobalConfig(initialKvValuesByKey, sdk) {
    var _this;
    (0, _classCallCheck2.default)(this, GlobalConfig);
    _this = _callSuper(this, GlobalConfig);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_sdk", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_kvStore", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_airtableInterface", void 0);
    _this._kvStore = initialKvValuesByKey;
    _this._sdk = sdk;
    _this._airtableInterface = sdk.__airtableInterface;
    return _this;
  }

  /**
   * @internal
   */
  (0, _inherits2.default)(GlobalConfig, _Watchable);
  return (0, _createClass2.default)(GlobalConfig, [{
    key: "__getTopLevelKey",
    value: function __getTopLevelKey(key) {
      if (Array.isArray(key)) {
        return key[0];
      }
      return key;
    }
    /**
     * @internal
     */
  }, {
    key: "_formatKeyAsPath",
    value: function _formatKeyAsPath(key) {
      if (!Array.isArray(key)) {
        return [key];
      }
      return key;
    }

    /**
     * @internal
     */
  }, {
    key: "_validatePath",
    value: function _validatePath(path, store) {
      var validation = this._airtableInterface.globalConfigHelpers.validatePath(path, store);
      if (!validation.isValid) {
        return validation;
      }
      if (path[0] === '*') {
        return {
          isValid: false,
          reason: "cannot use '*' as a top-level key"
        };
      }
      return {
        isValid: true
      };
    }
    /**
     * Get the value at a path. Throws an error if the path is invalid.
     *
     * Returns undefined if no value exists at that path.
     *
     * @param key A string for the top-level key, or an array of strings describing the path to the value.
     * @example
     * ```js
     * import {globalConfig} from '@airtable/blocks';
     *
     * const topLevelValue = globalConfig.get('topLevelKey');
     * const nestedValue = globalConfig.get(['topLevelKey', 'nested', 'deeply']);
     * ```
     */
  }, {
    key: "get",
    value: function get(key) {
      var path = this._formatKeyAsPath(key);
      var pathValidationResult = this._validatePath(path, this._kvStore);
      if (!pathValidationResult.isValid) {
        throw (0, _error_utils.spawnError)('Invalid globalConfig path: %s', pathValidationResult.reason);
      }
      var value = (0, _private_utils.getValueAtOwnPath)(this._kvStore, path);
      // value is returned as `unknown` from getValueAtOwnPath, but we know it must be a `GlobalConfigValue | void`
      return value;
    }

    /**
     * Checks whether the current user has permission to set the given global config key.
     *
     * Accepts partial input, in the same format as {@link setAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can set the specified key,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise.  `reasonDisplayString` may
     * be used to display an error message to the user.
     *
     * @param key A string for the top-level key, or an array of strings describing the path to set.
     * @param value The value to set at the specified path. Use `undefined` to delete the value at the given path.
     *
     * @example
     * ```js
     * // Check if user can update a specific key and value.
     * const setCheckResult =
     *     globalConfig.checkPermissionsForSet('favoriteColor', 'purple');
     * if (!setCheckResult.hasPermission) {
     *     alert(setCheckResult.reasonDisplayString);
     * }
     *
     * // Check if user can update a specific key without knowing the value
     * const setKeyCheckResult =
     *     globalConfig.checkPermissionsForSet('favoriteColor');
     *
     * // Check if user can update globalConfig without knowing key or value
     * const setUnknownKeyCheckResult = globalConfig.checkPermissionsForSet();
     * ```
     */
  }, {
    key: "checkPermissionsForSet",
    value: function checkPermissionsForSet(key, value) {
      return this.checkPermissionsForSetPaths([{
        path: key ? this._formatKeyAsPath(key) : undefined,
        value
      }]);
    }
    /**
     * An alias for `globalConfig.checkPermissionsForSet(key, value).hasPermission`.
     *
     * Checks whether the current user has permission to set the given global config key.
     *
     * Accepts partial input, in the same format as {@link setAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param key A string for the top-level key, or an array of strings describing the path to set.
     * @param value The value to set at the specified path. Use `undefined` to delete the value at the given path.
     *
     * @example
     * ```js
     * // Check if user can update a specific key and value.
     * const canSetFavoriteColorToPurple =
     *     globalConfig.hasPermissionToSet('favoriteColor', 'purple');
     * if (!canSetFavoriteColorToPurple) {
     *     alert('Not allowed!');
     * }
     *
     * // Check if user can update a specific key without knowing the value
     * const canSetFavoriteColor = globalConfig.hasPermissionToSet('favoriteColor');
     *
     * // Check if user can update globalConfig without knowing key or value
     * const canSetGlobalConfig = globalConfig.hasPermissionToSet();
     * ```
     */
  }, {
    key: "hasPermissionToSet",
    value: function hasPermissionToSet(key, value) {
      return this.checkPermissionsForSet(key, value).hasPermission;
    }
    /**
     * Sets a value at a path. Throws an error if the path or value is invalid.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the
     * update to be persisted to Airtable servers.
     *
     * Updates are applied optimistically locally, so your change will be reflected in
     * {@link GlobalConfig} before the promise resolves.
     *
     * @param key A string for the top-level key, or an array of strings describing the path to set.
     * @param value The value to set at the specified path. Use `undefined` to delete the value at the given path.
     * @example
     * ```js
     * import {globalConfig} from '@airtable/blocks';
     *
     * function updateFavoriteColorIfPossible(color) {
     *     if (globalConfig.hasPermissionToSetPaths('favoriteColor', color)) {
     *         globalConfig.setAsync('favoriteColor', color);
     *     }
     *     // The update is now applied within your extension (eg will be
     *     // reflected in globalConfig) but are still being saved to
     *     // Airtable servers (e.g. may not be updated for other users yet)
     * }
     *
     * async function updateFavoriteColorIfPossibleAsync(color) {
     *     if (globalConfig.hasPermissionToSet('favoriteColor', color)) {
     *         await globalConfig.setAsync('favoriteColor', color);
     *     }
     *     // globalConfig updates have been saved to Airtable servers.
     *     alert('favoriteColor has been updated');
     * }
     * ```
     */
  }, {
    key: "setAsync",
    value: (function () {
      var _setAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(key, value) {
        var path;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              path = this._formatKeyAsPath(key);
              _context.next = 3;
              return this.setPathsAsync([{
                path,
                value
              }]);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function setAsync(_x, _x2) {
        return _setAsync.apply(this, arguments);
      }
      return setAsync;
    }()
    /**
     * Checks whether the current user has permission to perform the specified updates to global config.
     *
     * Accepts partial input, in the same format as {@link setPathsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * Returns `{hasPermission: true}` if the current user can set the specified key,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param updates The paths and values to set.
     * @example
     * ```js
     * // Check if user can update a specific keys and values.
     * const setPathsCheckResult = globalConfig.checkPermissionsForSet([
     *     {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
     *     {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
     * ]);
     * if (!setPathsCheckResult.hasPermission) {
     *     alert(setPathsCheckResult.reasonDisplayString);
     * }
     *
     * // Check if user could potentially set globalConfig values.
     * // Equivalent to globalConfig.checkPermissionsForSet()
     * const setUnknownPathsCheckResult =
     *     globalConfig.checkPermissionsForSetPaths();
     * ```
     */
    )
  }, {
    key: "checkPermissionsForSetPaths",
    value: function checkPermissionsForSetPaths(updates) {
      return this._sdk.__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS,
        updates: updates ? updates.map(_ref => {
          var path = _ref.path,
            value = _ref.value;
          return {
            path: path || undefined,
            value
          };
        }) : undefined
      });
    }
    /**
     * An alias for `globalConfig.checkPermissionsForSetPaths(updates).hasPermission`.
     *
     * Checks whether the current user has permission to perform the specified updates to global
     * config.
     *
     * Accepts partial input, in the same format as {@link setPathsAsync}.
     * The more information provided, the more accurate the permissions check will be.
     *
     * @param updates The paths and values to set.
     *
     * @example
     * ```js
     * // Check if user can update a specific keys and values.
     * const canSetPaths = globalConfig.hasPermissionToSetPaths([
     *     {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
     *     {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
     * ]);
     * if (!canSetPaths) {
     *     alert('not allowed!');
     * }
     *
     * // Check if user could potentially set globalConfig values.
     * // Equivalent to globalConfig.hasPermissionToSet()
     * const canSetAnyPaths = globalConfig.hasPermissionToSetPaths();
     * ```
     */
  }, {
    key: "hasPermissionToSetPaths",
    value: function hasPermissionToSetPaths(updates) {
      return this.checkPermissionsForSetPaths(updates).hasPermission;
    }
    /**
     * Sets multiple values. Throws if any path or value is invalid.
     *
     * This action is asynchronous: `await` the returned promise if you wish to wait for the
     * updates to be persisted to Airtable servers.
     * Updates are applied optimistically locally, so your changes will be reflected in
     * {@link GlobalConfig} before the promise resolves.
     *
     * @param updates The paths and values to set.
     * @example
     * ```js
     * import {globalConfig} from '@airtable/blocks';
     *
     * const updates = [
     *     {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
     *     {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
     * ];
     *
     * function applyUpdatesIfPossible() {
     *     if (globalConfig.hasPermissionToSetPaths(updates)) {
     *         globalConfig.setPathsAsync(updates);
     *     }
     *     // The updates are now applied within your extension (eg will be reflected in
     *     // globalConfig) but are still being saved to Airtable servers (e.g. they
     *     // may not be updated for other users yet)
     * }
     *
     * async function applyUpdatesIfPossibleAsync() {
     *     if (globalConfig.hasPermissionToSetPaths(updates)) {
     *         await globalConfig.setPathsAsync(updates);
     *     }
     *     // globalConfig updates have been saved to Airtable servers.
     *     alert('globalConfig has been updated');
     * }
     * ```
     */
  }, {
    key: "setPathsAsync",
    value: (function () {
      var _setPathsAsync = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(updates) {
        var _iterator, _step, update, pathValidation;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (this.hasPermissionToSetPaths(updates)) {
                _context2.next = 2;
                break;
              }
              throw (0, _error_utils.spawnError)('Your permission level does not allow setting globalConfig values');
            case 2:
              _iterator = _createForOfIteratorHelper(updates);
              _context2.prev = 3;
              _iterator.s();
            case 5:
              if ((_step = _iterator.n()).done) {
                _context2.next = 12;
                break;
              }
              update = _step.value;
              pathValidation = this._validatePath(update.path, this._kvStore);
              if (pathValidation.isValid) {
                _context2.next = 10;
                break;
              }
              throw (0, _error_utils.spawnError)('Invalid globalConfig path: %s', pathValidation.reason);
            case 10:
              _context2.next = 5;
              break;
            case 12:
              _context2.next = 17;
              break;
            case 14:
              _context2.prev = 14;
              _context2.t0 = _context2["catch"](3);
              _iterator.e(_context2.t0);
            case 17:
              _context2.prev = 17;
              _iterator.f();
              return _context2.finish(17);
            case 20:
              _context2.next = 22;
              return this._sdk.__mutations.applyMutationAsync({
                type: _mutations.MutationTypes.SET_MULTIPLE_GLOBAL_CONFIG_PATHS,
                updates
              });
            case 22:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[3, 14, 17, 20]]);
      }));
      function setPathsAsync(_x3) {
        return _setPathsAsync.apply(this, arguments);
      }
      return setPathsAsync;
    }()
    /**
     * @internal
     * this shouldn't be called directly - instead, use this._sdk.__applyGlobalConfigUpdates()
     */
    )
  }, {
    key: "__setMultipleKvPaths",
    value: function __setMultipleKvPaths(updates) {
      // This helper validates updates and throw errors if necessary.
      // To avoid the case where an error is encountered after some updates have already been
      // applied (where we'd have to crash the block instead of letting the developer catch the
      // error), it doesn't mutate the current store: it returns newKvStore with changes applied.
      var _this$_airtableInterf = this._airtableInterface.globalConfigHelpers.validateAndApplyUpdates(updates, this._kvStore),
        newKvStore = _this$_airtableInterf.newKvStore,
        changedTopLevelKeys = _this$_airtableInterf.changedTopLevelKeys;

      // The updates are all good! Replace our kvStore with the new version.
      this._kvStore = newKvStore;

      // Now loop over the top level keys to fire change events.
      var _iterator2 = _createForOfIteratorHelper(changedTopLevelKeys),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var key = _step2.value;
          this._onChange(key);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (changedTopLevelKeys.length) {
        this._onChange('*');
      }
    }
  }], [{
    key: "_isWatchableKey",
    value: /** @internal */
    function _isWatchableKey(key) {
      // The user can store any arbitrary key in the global config, so there's
      // not much we can do here to check if a key is valid.
      return true;
    }
  }]);
}(_watchable.default);
/** @internal */
(0, _defineProperty2.default)(GlobalConfig, "_className", 'GlobalConfig');
var _default = exports.default = GlobalConfig;