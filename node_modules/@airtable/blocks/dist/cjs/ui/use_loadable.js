"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useLoadable;
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.promise.js");
require("core-js/modules/es.regexp.to-string.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _react = require("react");
var _useSubscription = require("use-subscription");
var _private_utils = require("../private_utils");
var _error_utils = require("../error_utils");
var _use_array_identity = _interopRequireDefault(require("./use_array_identity"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; } /** @module @airtable/blocks/ui: useLoadable */ /** */
// rather than asking for an AbstractModelWithAsyncData, we define a much more specific interface
// that enforces 'isDataLoaded' as a watchable key.
/**
 * A model that can be loaded.
 * Usually a {@link Cursor}, {@link RecordQueryResult}, or a {@link ViewMetadataQueryResult}.
 */

var SUSPENSE_CLEAN_UP_MS = 60000;

/**
 * Options object for the {@link useLoadable} hook.
 */

/**
 * When you're writing an extension, not all of the data in your base is available to work with straight
 * away. We need to load it from Airtable first. This hook is a low-level tool for managing that.
 * You might not need to use it directly though - if you're working with a {@link RecordQueryResult}, try
 * {@link useRecords}, {@link useRecordIds}, or {@link useRecordById} first.
 *
 * When you need to use a loadable model, `useLoadable(theModel)` will make sure that the model is
 * loaded when your component mounts, and unloaded when your component unmounts. By default, you
 * don't need to worry about waiting for the data to load - the hook uses React Suspense to make
 * sure the rest of your component doesn't run until the data is loaded. Whilst the data is
 * loading, the entire extension will show a loading indicator. If you want to change where that
 * indicator shows or how it looks, use [`<React.Suspense />`](https://reactjs.org/docs/react-api.html#reactsuspense|)
 * around the component that uses the hook.
 *
 * You can pass several models to `useLoadable` in an array - it will load all of them simultaneously.
 * We'll memoize this array using shallow equality, so there's no need to use `useMemo`.
 *
 * If you need more control, you can pass `{shouldSuspend: false}` as a second argument to
 * the hook. In that case though, `useLoadable` will cause your component to re-render whenever the
 * load-state of any model you passed in changes, and you should check each model's `.isDataLoaded`
 *  property before trying to use the data you loaded.
 *
 * @param models The models to load.
 * @param opts Optional options to control how the hook works.
 *
 * @example
 * ```js
 * import {useCursor, useLoadable, useWatchable} from '@airtable/blocks/ui';
 *
 *  function SelectedRecordIds() {
 *      const cursor = useCursor();
 *      // load selected records
 *      useLoadable(cursor);
 *
 *      // re-render whenever the list of selected records changes
 *      useWatchable(cursor, ['selectedRecordIds']);
 *
 *      // render the list of selected record ids
 *      return <div>Selected records: {cursor.selectedRecordIds.join(', ')}</div>;
 *  }
 * ```
 *
 * @example
 * ```js
 *  import {useLoadable} from '@airtable/blocks/ui';
 *
 *  function LoadTwoQueryResults({queryResultA, queryResultB}) {
 *      // load the queryResults:
 *      useLoadable([queryResultA, queryResultB]);
 *
 *      // now, we can use the data
 *      return <SomeFancyComponent />;
 *  }
 * ```
 *
 * @example
 * ```js
 *  import {useLoadable, useBase} from '@airtable/blocks/ui';
 *
 *  function LoadAllRecords() {
 *      const base = useBase();
 *
 *      // get a query result for every table in the base:
 *      const queryResults = base.tables.map(table => table.selectRecords());
 *
 *      // load them all:
 *      useLoadable(queryResults);
 *
 *      // use the data:
 *      return <SomeFancyComponent queryResults={queryResults} />;
 *  }
 * ```
 * @docsPath UI/hooks/useLoadable
 * @hook
 */
function useLoadable(models) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    shouldSuspend: true
  };
  var shouldSuspend = opts && (0, _private_utils.has)(opts, 'shouldSuspend') ? opts.shouldSuspend : true;
  var constModels = (0, _use_array_identity.default)(Array.isArray(models) ? models : [models]);
  var compactModels = (0, _react.useMemo)(() => {
    var compacted = (0, _private_utils.compact)(constModels);
    var _iterator = _createForOfIteratorHelper(compacted),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var model = _step.value;
        if (typeof model.loadDataAsync !== 'function') {
          throw (0, _error_utils.spawnError)('useLoadable called with %s, which is not a loadable', typeof model === 'object' ? model.toString() : typeof model);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return compacted;
  }, [constModels]);

  // .every returns `true` in the case of an empty array
  var areAllModelsLoaded = compactModels.every(model => model.isDataLoaded);
  if (shouldSuspend && !areAllModelsLoaded) {
    var suspensePromise = Promise.all(compactModels.map(model => model.loadDataAsync())).then(() => {
      // if data isn't loaded and we're in suspense mode, we need to start the data loading and
      // throw the load promise. when we throw though, the render tree gets thrown away and none
      // of out hooks will be retained - so we can't attach this QueryResult to a component
      // lifecycle and use that to unload it. Instead, we load it and keep it loaded for a long
      // enough time that it can resolve and then be rendered successfully. After the timeout has
      // passed, we unload it, allowing the data to be released as long as it's not used anywhere
      // else in the extension.
      setTimeout(() => {
        var _iterator2 = _createForOfIteratorHelper(compactModels),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var model = _step2.value;
            model.unloadData();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }, SUSPENSE_CLEAN_UP_MS);
    }).catch(error => {
      // eslint-disable-next-line no-console
      console.error(error);
      throw error;
    });
    throw suspensePromise;
  }

  // re-render when loaded state changes. technically, we could use `useWatchable` here, but as
  // our LoadableModel isn't a Watchable, we can't. There's no way to preserve flow errors when
  // watching something that doesn't have a 'isDataLoaded' watch key and use `Watchable`.
  var modelIsLoadedSubscription = (0, _react.useMemo)(() => ({
    getCurrentValue: () => compactModels.map(model => model.isDataLoaded).join(','),
    subscribe: onChange => {
      var _iterator3 = _createForOfIteratorHelper(compactModels),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var model = _step3.value;
          model.watch('isDataLoaded', onChange);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return () => {
        var _iterator4 = _createForOfIteratorHelper(compactModels),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var model = _step4.value;
            model.unwatch('isDataLoaded', onChange);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      };
    }
  }), [compactModels]);
  (0, _useSubscription.useSubscription)(modelIsLoadedSubscription);

  // the main part of this hook comes down to managing the query result data loading in sync with
  // the component lifecycle. That means loading the data when the component mounts, and
  // unloading it when the component unmounts.
  (0, _react.useEffect)(() => {
    var _iterator5 = _createForOfIteratorHelper(compactModels),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var model = _step5.value;
        model.loadDataAsync();
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    return () => {
      var _iterator6 = _createForOfIteratorHelper(compactModels),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var model = _step6.value;
          model.unloadData();
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    };
  }, [compactModels]);
}