"use strict";

require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.weak-map.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__injectSdkIntoInitializeBlock = __injectSdkIntoInitializeBlock;
exports.__resetHasBeenInitialized = __resetHasBeenInitialized;
exports.initializeBlock = initializeBlock;
var React = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var _error_utils = require("../error_utils");
var _airtable_interface = _interopRequireDefault(require("../injected/airtable_interface"));
var _airtable_interface2 = require("../types/airtable_interface");
var _block_wrapper = _interopRequireDefault(require("./block_wrapper"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/** @module @airtable/blocks/ui: initializeBlock */ /** */

var hasBeenInitialized = false;

/** */

/** @hidden */

/** @hidden */

/** @hidden */

/**
 * `initializeBlock` takes the top-level React component in your tree and renders it. It is conceptually similar to `ReactDOM.render`, but takes care of some Extensions-specific things.
 *
 * @param getEntryElement A function that returns your React Node.
 *
 * @example
 * ```js
 * import {initializeBlock} from '@airtable/blocks/ui';
 * import React from 'react';
 *
 * function App() {
 *     return (
 *         <div>Hello world ðŸš€</div>
 *     );
 * }
 *
 * initializeBlock(() => <App />);
 * ```
 * @docsPath UI/utils/initializeBlock
 */
function initializeBlock(getEntryElement) {
  var _airtableInterface$sd;
  var entryPoints = typeof getEntryElement === 'function' ? {
    dashboard: getEntryElement
  } : getEntryElement;
  var body = typeof document !== 'undefined' ? document.body : null;
  if (!body) {
    throw (0, _error_utils.spawnError)('initializeBlock should only be called from browser environments');
  }
  if (hasBeenInitialized) {
    throw (0, _error_utils.spawnError)('initializeBlock should only be called once');
  }
  hasBeenInitialized = true;
  var airtableInterface = (0, _airtable_interface.default)();
  var entryElement;
  // runContext can be undefined if running from an old version client version (before 01/2021)
  // TODO (SeanKeenan): Remove nullish coelescing once old clients are no longer a concern
  var runContext = (_airtableInterface$sd = airtableInterface.sdkInitData.runContext) !== null && _airtableInterface$sd !== void 0 ? _airtableInterface$sd : {
    type: _airtable_interface2.BlockRunContextType.DASHBOARD_APP
  };
  switch (runContext.type) {
    case _airtable_interface2.BlockRunContextType.DASHBOARD_APP:
      {
        if (entryPoints.dashboard === undefined) {
          throw (0, _error_utils.spawnError)('If running an extension within the dashboard, it must have a dashboard initialization function');
        }
        if (typeof entryPoints.dashboard !== 'function') {
          throw (0, _error_utils.spawnError)('initializeBlock must contain a dashboard function that returns a React element');
        }
        entryElement = entryPoints.dashboard();
        break;
      }
    case _airtable_interface2.BlockRunContextType.VIEW:
      {
        if (entryPoints.view === undefined) {
          throw (0, _error_utils.spawnError)('If running an extension within a view, it must have a view initialization function');
        }
        if (typeof entryPoints.view !== 'function') {
          throw (0, _error_utils.spawnError)('initializeBlock must contain a view function that returns a React element');
        }
        var table = sdk.base.getTableById(runContext.tableId);
        var view = table.getViewById(runContext.viewId);
        entryElement = entryPoints.view({
          table,
          view
        });
        break;
      }
    default:
      throw (0, _error_utils.spawnError)('Invalid context to run ');
  }
  if (! /*#__PURE__*/React.isValidElement(entryElement)) {
    throw (0, _error_utils.spawnError)("The first argument to initializeBlock didn't return a valid React element");
  }
  sdk.__setBatchedUpdatesFn(_reactDom.default.unstable_batchedUpdates);
  var container = document.createElement('div');
  body.appendChild(container);
  _reactDom.default.render( /*#__PURE__*/React.createElement(_block_wrapper.default, {
    sdk: sdk
  }, entryElement), container);
}
var sdk;

// The application-level Sdk instance must be injected dynamically to avoid
// circular dependencies at the time of module resolution.
function __injectSdkIntoInitializeBlock(_sdk) {
  sdk = _sdk;
}

// Exclusively for tests
function __resetHasBeenInitialized() {
  hasBeenInitialized = false;
}