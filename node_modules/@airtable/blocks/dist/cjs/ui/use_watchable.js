"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useWatchable;
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.map.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _react = require("react");
var _useSubscription = require("use-subscription");
var _error_utils = require("../error_utils");
var _private_utils = require("../private_utils");
var _use_array_identity = _interopRequireDefault(require("./use_array_identity"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; } /** @module @airtable/blocks/ui: useWatchable */ /** */
/**
 * A React hook for watching data in Airtable models like {@link Table} and {@link Record}. Each
 * model has several watchable keys that can be used with this hook to have your component
 * automatically re-render when data in the models changes. You can also provide an optional
 * callback if you need to do anything other than re-render when the data changes.
 *
 * This is a low-level tool that you should only use when you specifically need it. There are more
 * convenient model-specific hooks available:
 *
 * * For {@link Base}, {@link Table}, {@link View}, or {@link Field}, use {@link useBase}.
 * * For {@link RecordQueryResult} or {@link Record}, use {@link useRecords}, {@link useRecordIds}, or {@link useRecordById}.
 * * For {@link Viewport}, use {@link useViewport}.
 * * For {@link SettingsButton}, use {@link useSettingsButton}.
 *
 * If you're writing a class component and still want to be able to use hooks, try {@link withHooks}.
 *
 * @param models The model or models to watch.
 * @param keys The key or keys to watch. Non-optional, but may be null.
 * @param callback An optional callback to call when any of the watch keys change.
 *
 * @example
 * ```js
 * import {useWatchable} from '@airtable/blocks/ui';
 *
 * function TableName({table}) {
 *     useWatchable(table, 'name');
 *     return <span>The table name is {table.name}</span>;
 * }
 *
 * function ViewNameAndType({view}) {
 *     useWatchable(view, ['name', 'type']);
 *     return <span>The view name is {view.name} and the type is {view.type}</span>;
 * }
 *
 * function RecordValuesAndColorInViewIfExists({record, field, view}) {
 *     useWatchable(record, ['cellValues', view ? `colorInView:${view.id}` : null]);
 *     return <span>
 *         The record has cell value {record.getCellValue(field)} in {field.name}.
 *         {view ? `The record has color ${record.getColorInView(view)} in ${view.name}.` : null}
 *     </span>
 * }
 * ```
 *
 * @example
 * ```js
 * import {useWatchable} from '@airtable/blocks/ui';
 *
 * function ActiveView({cursor}) {
 *     useWatchable(cursor, 'activeViewId', () => {
 *          alert('active view changed!!!')
 *     });
 *
 *     return <span>Active view id: {cursor.activeViewId}</span>;
 * }
 * ```
 * @docsPath UI/hooks/useWatchable
 * @hook
 */
function useWatchable(models, keys, callback) {
  if (keys === undefined) {
    throw (0, _error_utils.spawnError)('Invalid call to useWatchable: keys cannot be undefined. ' + 'Pass a key or array of keys corresponding to the model being watched as the second ' + 'argument.');
  }
  var compactModels = (0, _use_array_identity.default)((0, _private_utils.compact)(Array.isArray(models) ? models : [models]));
  var compactKeys = (0, _use_array_identity.default)((0, _private_utils.compact)(Array.isArray(keys) ? keys : [keys]));

  // use a ref to the callback so consumers don't have to provide their own memoization to avoid
  // unwatching and rewatching every render
  var callbackRef = (0, _react.useRef)(callback);
  callbackRef.current = callback;

  // we use a subscription to model.__getWatchableKey() to track changes. This is because
  // __getWatchableKey will return a value that is:
  //   1. identical by === if nothing watchable in the model has changed. That means we won't
  //      trigger unnecessary re-renders if nothing has changed. Without this, every initial
  //      mount will be double-rendered as useSubscription will think the model changed in the
  //      async gap
  //   2. will be !== if anything watchable in the model has changed. Without this, we might not
  //      re-render when information that we care about has changed.
  //   3. is unique to that model. This means that if we change models, we're guaranteed to get
  //      re-rendered.
  var watchSubscription = (0, _react.useMemo)(() => {
    return {
      getCurrentValue: () => compactModels.map(model => model.__getWatchableKey()).join(','),
      subscribe: notifyChange => {
        // sometimes, watching and unwatching a key has side effects - typically, these
        // only happen when watching or unwatching something for the first or last time, as
        // we use ref-counting to avoid unnecessary side effects. When the keys or models
        // for this subscription change, we teardown the old subscription and create a new
        // one. Often though, underlying model-key pairs will be the same - we'll remove
        // the old subscription, but instantly re-add it. In this case, we don't want to
        // trigger any side effects. To work around this, we defer unwatching the previous
        // models and keys until _after_ we've watched the new ones. That way, the ref-
        // count never reaches 0. We don't want the old watches to actually trigger in that
        // time though - so `isDisabled` prevents that.
        var isDisabled = false;
        var onChange = function onChange(model, key) {
          if (isDisabled) {
            return;
          }
          notifyChange();
          if (callbackRef.current) {
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            callbackRef.current(model, key, ...args);
          }
        };
        var _iterator = _createForOfIteratorHelper(compactModels),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var model = _step.value;
            model.watch(compactKeys, onChange);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return () => {
          isDisabled = true;
          setTimeout(() => {
            var _iterator2 = _createForOfIteratorHelper(compactModels),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var model = _step2.value;
                model.unwatch(compactKeys, onChange);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }, 0);
        };
      }
    };
  }, [compactModels, compactKeys]);

  // we don't care about the return value - we just want useSubscription to correctly handle
  // re-rendering the component for us
  (0, _useSubscription.useSubscription)(watchSubscription);
}