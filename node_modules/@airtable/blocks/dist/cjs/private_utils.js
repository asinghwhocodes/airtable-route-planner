"use strict";

require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.array.from.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.regexp.to-string.js");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayDifference = arrayDifference;
exports.assertEnumValue = assertEnumValue;
exports.cast = cast;
exports.clamp = clamp;
exports.cloneDeep = cloneDeep;
exports.compact = compact;
exports.createEnum = createEnum;
exports.createPropTypeFromEnum = createPropTypeFromEnum;
exports.createResponsivePropTypeFromEnum = createResponsivePropTypeFromEnum;
exports.debounce = debounce;
exports.entries = entries;
exports.fireAndForgetPromise = fireAndForgetPromise;
exports.flattenDeep = flattenDeep;
exports.getEnumValueIfExists = getEnumValueIfExists;
exports.getId = getId;
exports.getLocaleAndDefaultLocale = getLocaleAndDefaultLocale;
exports.getLocallyUniqueId = getLocallyUniqueId;
exports.getValueAtOwnPath = getValueAtOwnPath;
exports.has = has;
exports.isBlockDevelopmentRestrictionEnabled = isBlockDevelopmentRestrictionEnabled;
Object.defineProperty(exports, "isDeepEqual", {
  enumerable: true,
  get: function get() {
    return _fastDeepEqual.default;
  }
});
exports.isEnumValue = isEnumValue;
exports.isNullOrUndefinedOrEmpty = isNullOrUndefinedOrEmpty;
exports.isObjectEmpty = isObjectEmpty;
exports.keyBy = keyBy;
exports.keys = keys;
exports.uniqBy = uniqBy;
exports.values = values;
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.filter.js");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.object.entries.js");
require("core-js/modules/es.object.to-string.js");
require("core-js/modules/es.object.values.js");
require("core-js/modules/es.set.js");
require("core-js/modules/es.weak-map.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _propTypes = _interopRequireDefault(require("prop-types"));
var _airtable_interface = _interopRequireDefault(require("./injected/airtable_interface"));
var _error_utils = require("./error_utils");
var _create_responsive_prop_type = _interopRequireDefault(require("./ui/system/utils/create_responsive_prop_type"));
var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/** @hidden */

/** @hidden */

/** @hidden */

/**
 * Get the type of all the values of an object.
 *
 * Same as the legacy Flow `$Values<T>` type.
 *
 * @hidden
 */

/** @hidden */

/**
 * Extract the type of `ref` from a react component
 *
 * @hidden
 */

/**
 * Allows creating an object map type with a dynamic key type.
 *
 * TypeScript only allows `string` for `K` in `{[key: K]: V}` so we need a utility to bridge
 * the gap.
 *
 * This is an alias for TypeScript’s `Record` type, but the name “record” is confusing given our
 * Airtable domain model.
 *
 * @hidden
 */

/**
 * Creates an enum from provided string arguments.
 *
 * Useful for consumer-facing enums (eg `Button#variant`) where we want to make the external
 * developer experience convenient by providing a string value, but also want to internally
 * reference enum values using object notation.
 *
 * @hidden
 */
function createEnum() {
  var spec = {};
  for (var _len = arguments.length, enumValues = new Array(_len), _key = 0; _key < _len; _key++) {
    enumValues[_key] = arguments[_key];
  }
  for (var _i = 0, _enumValues = enumValues; _i < _enumValues.length; _i++) {
    var value = _enumValues[_i];
    spec[value] = value;
  }
  return Object.freeze(spec);
}

/**
 * Creates a React propType for a provided enum.
 *
 * @hidden
 */
function createPropTypeFromEnum(enumData) {
  return _propTypes.default.oneOf(values(enumData));
}

/**
 * Creates a responsive React propType for a provided enum.
 *
 * This allows the prop to be either a valid enum property, or a map of viewport sizes to valid enum
 * properties.
 *
 * @hidden
 */
function createResponsivePropTypeFromEnum(enumData) {
  var propType = createPropTypeFromEnum(enumData);
  return (0, _create_responsive_prop_type.default)(propType);
}

/**
 * Creates a Type for an enum created using `createEnum`.
 *
 * @hidden
 */

/**
 * Safely cast a value to the type passed in as a type parameter.
 *
 * This was added in the TypeScript migration to provide a safe translation for Flow’s type cast
 * operator `(x: T)`.
 *
 * @hidden
 */
function cast(x) {
  return x;
}

/**
 * @hidden
 */
function cloneDeep(obj) {
  var jsonString = JSON.stringify(obj);
  if (jsonString === undefined) {
    return obj;
  }
  return JSON.parse(jsonString);
}

// typescript has a stricter definition for Object.values and Object.entries that return mixed in place
// of the actual values. This is because for non-exact objects, that's the only sound definition.
// You can call Object.values with a value typed as {x: number} that actually looks like
// {x: number, y: string}, for example. Returning mixed isn't particularly useful though, so we
// provide these unsound wrappers instead.
// TODO: consider renaming these with unsound_ prefixes.
/**
 * @hidden
 */
function keys(obj) {
  return Object.keys(obj);
}

/**
 * @hidden
 */
function values(obj) {
  return Object.values(obj);
}

/**
 * @hidden
 */
function entries(obj) {
  // @ts-ignore
  return Object.entries(obj);
}

// Result values are discarded and errors are thrown asynchronously.
// NOTE: this is different from the one in u: the function passed
// in must be fully bound with all of its arguments and will be immediately
// called (this does not return a function). This makes it work better with
// Flow: you get argument type checking by using `.bind`.
/**
 * @hidden
 */
function fireAndForgetPromise(fn) {
  fn().catch(err => {
    // Defer til later, so the error doesn't cause the promise to be rejected.
    setTimeout(() => {
      throw err;
    }, 0);
  });
}

/**
 * @hidden
 */
function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var invertedEnumCache = new WeakMap();
/**
 * @hidden
 */
function getInvertedEnumMemoized(enumObj) {
  var existingInvertedEnum = invertedEnumCache.get(enumObj);
  if (existingInvertedEnum) {
    // typescript can't type WeakMap precisely enough to know that it's being used as this sort of cache
    return existingInvertedEnum;
  }
  var invertedEnum = {};
  var _iterator = _createForOfIteratorHelper(keys(enumObj)),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var enumKey = _step.value;
      var enumValue = enumObj[enumKey];
      invertedEnum[enumValue] = enumKey;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  invertedEnumCache.set(enumObj, invertedEnum);
  return invertedEnum;
}

/**
 * @hidden
 */
function getEnumValueIfExists(enumObj, valueToCheck) {
  var invertedEnum = getInvertedEnumMemoized(enumObj);
  if (has(invertedEnum, valueToCheck) && invertedEnum[valueToCheck]) {
    var enumKey = invertedEnum[valueToCheck];
    return enumObj[enumKey];
  }
  return null;
}

/**
 * @hidden
 */
function assertEnumValue(enumObj, valueToCheck) {
  var enumValue = getEnumValueIfExists(enumObj, valueToCheck);
  if (!enumValue) {
    throw (0, _error_utils.spawnError)('Unknown enum value %s', valueToCheck);
  }
  return enumValue;
}

/**
 * @hidden
 */
function isEnumValue(enumObj, valueToCheck) {
  return getEnumValueIfExists(enumObj, valueToCheck) !== null;
}

/**
 * @hidden
 */
function isObjectEmpty(obj) {
  for (var key in obj) {
    if (has(obj, key)) {
      return false;
    }
  }
  return true;
}

/**
 * @hidden
 */
function isNullOrUndefinedOrEmpty(value) {
  return value === null || value === undefined || (typeof value === 'string' || Array.isArray(value)) && value.length === 0 || typeof value === 'object' && value !== null && isObjectEmpty(value);
}

/**
 * @hidden
 */
function compact(array) {
  var result = [];
  var _iterator2 = _createForOfIteratorHelper(array),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var item = _step2.value;
      if (item !== null && item !== undefined) {
        result.push(item);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return result;
}

/**
 * @hidden
 */
function clamp(n, lowerBound, upperBound) {
  if (n < lowerBound) {
    return lowerBound;
  } else if (n > upperBound) {
    return upperBound;
  } else {
    return n;
  }
}

/** @hidden */

/**
 * @hidden
 */
function flattenDeep(array) {
  // @ts-ignore
  return array.flat(Infinity);
}

// For cases where the object keys aren't strings, it's the consumer's responsibility
// to convert them to strings in getKey, e.g. keyBy(collection, o => String(o.id))
/**
 * @hidden
 */
function keyBy(array, getKey) {
  var result = {};
  var _iterator3 = _createForOfIteratorHelper(array),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var item = _step3.value;
      result[getKey(item)] = item;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return result;
}

/**
 * @hidden
 */
function getId(_ref) {
  var id = _ref.id;
  return id;
}

/**
 * @hidden
 */
function uniqBy(array, getKey) {
  var usedKeys = new Set();
  var result = [];
  var _iterator4 = _createForOfIteratorHelper(array),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var item = _step4.value;
      var key = getKey(item);
      if (!usedKeys.has(key)) {
        result.push(item);
        usedKeys.add(key);
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return result;
}
var idCount = 0;
/** @hidden */
function getLocallyUniqueId() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return "".concat(prefix, ".").concat(idCount++);
}
var plainObjectPrototype = Object.getPrototypeOf({});
/**
 * A more restrictive version of Lodash's `get`. Notable differences:
 * - Will only search an object's own properties
 * - Only allows indexing into plain objects - searching in `number`, `string`, `Array`, `null`, or non-plain objects will throw
 *
 * @hidden
 */
function getValueAtOwnPath(value, path) {
  var currentValue = value;
  var _iterator5 = _createForOfIteratorHelper(path),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var part = _step5.value;
      if (currentValue === undefined) {
        return undefined;
      }
      if (typeof currentValue !== 'object' || currentValue === null) {
        throw (0, _error_utils.spawnError)("Cannot get '%s' in primitive value", part);
      }
      if (Array.isArray(currentValue)) {
        throw (0, _error_utils.spawnError)("Cannot get '%s' in array", part);
      }
      var prototype = Object.getPrototypeOf(currentValue);
      if (prototype !== null && prototype !== plainObjectPrototype) {
        throw (0, _error_utils.spawnError)("Cannot get '%s' in non-plain object", part);
      }
      currentValue = has(currentValue, part) ? currentValue[part] : undefined;
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  return currentValue;
}

/** @hidden */
function arrayDifference(a, b) {
  var bSet = new Set(b);
  return a.filter(item => !bSet.has(item));
}

/** @hidden */
function debounce(fn, timeoutMs) {
  var lastTimeoutId = null;
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (lastTimeoutId !== null) {
      clearTimeout(lastTimeoutId);
    }
    lastTimeoutId = setTimeout(() => {
      lastTimeoutId = null;
      fn(...args);
    }, timeoutMs);
  };
}

/** @hidden */
function isBlockDevelopmentRestrictionEnabled() {
  return (0, _airtable_interface.default)().sdkInitData.baseData.isBlockDevelopmentRestrictionEnabled;
}

/**
 * Added for use in Gantt View, to enable i18n.
 *
 * @hidden
 * */
function getLocaleAndDefaultLocale() {
  var sdkInitData = (0, _airtable_interface.default)().sdkInitData;
  return {
    locale: sdkInitData.locale,
    defaultLocale: sdkInitData.defaultLocale
  };
}