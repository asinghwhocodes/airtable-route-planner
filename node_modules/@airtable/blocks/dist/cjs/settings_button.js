"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _watchable = _interopRequireDefault(require("./watchable"));
var _private_utils = require("./private_utils");
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /** @module @airtable/blocks: settingsButton */ /** */
var WatchableSettingsButtonKeys = Object.freeze({
  isVisible: 'isVisible',
  click: 'click'
});

/**
 * A watchable key in {@link SettingsButton}.
 * - `isVisible`
 * - `click`
 */
/**
 * Interface to the settings button that lives outside the extension's viewport.
 *
 * The {@link useSettingsButton} hook is the recommended way to use the settings button, but you can
 * also use it with {@link useWatchable} if you want more granular control (for example, to only
 * show the button conditionally).
 *
 * @alias settingsButton
 * @example
 * ```js
 * import {settingsButton} from '@airtable/blocks';
 * import {useWatchable} from '@airtable/blocks/ui';
 *
 * function AppWithSettings({shouldShowSettingsButton}) {
 *     useEffect(() => {
 *         // A count of calls to `show()` and `hide()` is maintained internally. The button will
 *         // stay visible if there are more calls to `show()` than `hide()` - so here, we check
 *         // `isVisible` so we only we only call them when necessary.
 *         // The button is not visible by default.
 *         if (shouldShowSettingsButton && !settingsButton.isVisible) {
 *             settingsButton.show();
 *         } else if (!shouldShowSettingsButton && settingsButton.isVisible) {
 *             settingsButton.hide();
 *         }
 *     });
 *
 *     useWatchable(settingsButton, 'click', function() {
 *         alert('Clicked!');
 *     });
 * }
 * ```
 * @docsPath models/SettingsButton
 */
var SettingsButton = /*#__PURE__*/function (_Watchable) {
  /** @internal */
  function SettingsButton(airtableInterface) {
    var _this;
    (0, _classCallCheck2.default)(this, SettingsButton);
    _this = _callSuper(this, SettingsButton);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_refCount", void 0);
    /** @internal */
    (0, _defineProperty2.default)(_this, "_airtableInterface", void 0);
    _this._refCount = 0;
    _this._airtableInterface = airtableInterface;
    return _this;
  }

  /**
   * Whether the settings button is being shown.
   * Can be watched.
   */
  (0, _inherits2.default)(SettingsButton, _Watchable);
  return (0, _createClass2.default)(SettingsButton, [{
    key: "isVisible",
    get: function get() {
      return this._refCount > 0;
    }

    /**
     * Show the settings button.
     */
  }, {
    key: "show",
    value: function show() {
      // Is now visible: trigger change watches and set it to be visible
      if (this._refCount === 0) {
        this._onChange(WatchableSettingsButtonKeys.isVisible, true);
        this._airtableInterface.setSettingsButtonVisibility(true);
      }
      this._refCount += 1;
    }

    /**
     * Hide the settings button.
     *
     * Note: A count of calls to `show()` and `hide()` is maintained internally. The button will
     * stay visible if there are more calls to `show()` than `hide()`.
     */
  }, {
    key: "hide",
    value: function hide() {
      // Be forgiving if hide() is called too many times, since we don't expose the count
      if (this._refCount > 0) {
        this._refCount -= 1;
      }

      // Should no longer be visible: trigger change watches and set it to be not visible
      if (this._refCount === 0) {
        this._onChange(WatchableSettingsButtonKeys.isVisible, false);
        this._airtableInterface.setSettingsButtonVisibility(false);
      }
    }

    /** @internal */
  }, {
    key: "__onClick",
    value: function __onClick() {
      this._onChange(WatchableSettingsButtonKeys.click);
    }
  }], [{
    key: "_isWatchableKey",
    value: /** @internal */
    function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableSettingsButtonKeys, key);
    }
  }]);
}(_watchable.default);
/** @internal */
(0, _defineProperty2.default)(SettingsButton, "_className", 'SettingsButton');
var _default = exports.default = SettingsButton;